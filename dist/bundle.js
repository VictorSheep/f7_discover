/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _framework = __webpack_require__(1);

	var _framework2 = _interopRequireDefault(_framework);

	var _jquery = __webpack_require__(2);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _foo = __webpack_require__(3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(0, _foo.foo)("Hello Babel");
	//console.log("Hello Node");

	/* Framework7 */
	var app = new _framework2.default({
	  // App root element
	  root: '#app',
	  // App Name
	  name: 'My App',
	  // App id
	  id: 'com.myapp.test',
	  // Enable swipe panel
	  panel: {
	    swipe: 'left'
	  },
	  // Add default routes
	  routes: [{
	    name: 'about',
	    path: '/about/',
	    url: 'about.html'
	  }, {
	    name: 'games-list',
	    path: '/games-list/',
	    templateUrl: './views/games-list.html',
	    options: {
	      context: {
	        games: ['Kirby', 'TrakMania', 'Compote Adventures']
	      }
	    },
	    on: {
	      pageAfterIn: function pageAfterIn(e, page) {
	        // do something after page gets into the view
	      },
	      pageInit: function pageInit(e, page) {
	        // do something when page initialized

	        var games = [{
	          name: 'Kirby',
	          date: '1995',
	          note: 8
	        }, {
	          name: 'TrakMania',
	          date: '1998',
	          note: 7
	        }, {
	          name: 'Compote Adventures',
	          date: '2007',
	          note: 10
	        }];

	        (0, _jquery2.default)(document).ready(function () {

	          var $div = (0, _jquery2.default)(".view .page-content ul#games-list");
	          console.log('$', $div);

	          for (var i = 0; i < games.length; i++) {
	            var g = games[i];
	            var divg = document.createElement('li');
	            divg.className = 'game' + i;
	            divg.innerHTML = '\n              <h5 class="title">' + g.name + '</h5>\n              <a class="button">\n                <i class="f7-icons ios-only">arrow_right</i>\n                <i class="material-icons md-only">arrow_next</i>\n              </a>\n            ';
	            $div.append(divg);
	          }
	        });
	      }
	    }
	  }, {
	    name: 'game',
	    path: '/game/',
	    templateUrl: './views/game.html/',
	    options: {
	      context: {
	        gameId: 0
	      }
	    }
	  }, {
	    name: 'config',
	    path: '/config/',
	    templateUrl: './views/config.html'
	  }, {
	    path: '(.*)',
	    url: './pages/404.html'
	  }]
	  // ... other parameters
	});

	var mainView = app.views.create('.view-main');
	var aboutView = app.views.create('.view-about');
	var gamesListView = app.views.create('.games-list');

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Framework7 2.0.7
	 * Full featured mobile HTML framework for building iOS & Android apps
	 * http://framework7.io/
	 *
	 * Copyright 2014-2018 Vladimir Kharlampidi
	 *
	 * Released under the MIT License
	 *
	 * Released on: January 27, 2018
	 */

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.Framework7 = factory());
	}(this, (function () { 'use strict';

	/**
	 * Template7 1.3.5
	 * Mobile-first HTML template engine
	 * 
	 * http://www.idangero.us/template7/
	 * 
	 * Copyright 2018, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 * 
	 * Licensed under MIT
	 * 
	 * Released on: January 22, 2018
	 */
	var t7ctx;
	if (typeof window !== 'undefined') {
	  t7ctx = window;
	} else if (typeof global !== 'undefined') {
	  t7ctx = global;
	} else {
	  t7ctx = undefined;
	}

	var Template7Context = t7ctx;

	var Template7Utils = {
	  quoteSingleRexExp: new RegExp('\'', 'g'),
	  quoteDoubleRexExp: new RegExp('"', 'g'),
	  isFunction: function isFunction(func) {
	    return typeof func === 'function';
	  },
	  escape: function escape(string) {
	    return (typeof Template7Context !== 'undefined' && Template7Context.escape) ?
	      Template7Context.escape(string) :
	      string
	        .replace(/&/g, '&amp;')
	        .replace(/</g, '&lt;')
	        .replace(/>/g, '&gt;')
	        .replace(/"/g, '&quot;');
	  },
	  helperToSlices: function helperToSlices(string) {
	    var quoteDoubleRexExp = Template7Utils.quoteDoubleRexExp;
	    var quoteSingleRexExp = Template7Utils.quoteSingleRexExp;
	    var helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
	    var slices = [];
	    var shiftIndex;
	    var i;
	    var j;
	    for (i = 0; i < helperParts.length; i += 1) {
	      var part = helperParts[i];
	      var blockQuoteRegExp = (void 0);
	      var openingQuote = (void 0);
	      if (i === 0) { slices.push(part); }
	      else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
	        blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
	        openingQuote = part.indexOf('"') === 0 ? '"' : '\'';
	        // Plain String
	        if (part.match(blockQuoteRegExp).length === 2) {
	          // One word string
	          slices.push(part);
	        } else {
	          // Find closed Index
	          shiftIndex = 0;
	          for (j = i + 1; j < helperParts.length; j += 1) {
	            part += " " + (helperParts[j]);
	            if (helperParts[j].indexOf(openingQuote) >= 0) {
	              shiftIndex = j;
	              slices.push(part);
	              break;
	            }
	          }
	          if (shiftIndex) { i = shiftIndex; }
	        }
	      } else if (part.indexOf('=') > 0) {
	        // Hash
	        var hashParts = part.split('=');
	        var hashName = hashParts[0];
	        var hashContent = hashParts[1];
	        if (!blockQuoteRegExp) {
	          blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
	          openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
	        }
	        if (hashContent.match(blockQuoteRegExp).length !== 2) {
	          shiftIndex = 0;
	          for (j = i + 1; j < helperParts.length; j += 1) {
	            hashContent += " " + (helperParts[j]);
	            if (helperParts[j].indexOf(openingQuote) >= 0) {
	              shiftIndex = j;
	              break;
	            }
	          }
	          if (shiftIndex) { i = shiftIndex; }
	        }
	        var hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
	        slices.push(hash);
	      } else {
	        // Plain variable
	        slices.push(part);
	      }
	    }
	    return slices;
	  },
	  stringToBlocks: function stringToBlocks(string) {
	    var blocks = [];
	    var i;
	    var j;
	    if (!string) { return []; }
	    var stringBlocks = string.split(/({{[^{^}]*}})/);
	    for (i = 0; i < stringBlocks.length; i += 1) {
	      var block = stringBlocks[i];
	      if (block === '') { continue; }
	      if (block.indexOf('{{') < 0) {
	        blocks.push({
	          type: 'plain',
	          content: block,
	        });
	      } else {
	        if (block.indexOf('{/') >= 0) {
	          continue;
	        }
	        block = block
	          .replace(/{{([#/])*([ ])*/, '{{$1')
	          .replace(/([ ])*}}/, '}}');
	        if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
	          // Simple variable
	          blocks.push({
	            type: 'variable',
	            contextName: block.replace(/[{}]/g, ''),
	          });
	          continue;
	        }
	        // Helpers
	        var helperSlices = Template7Utils.helperToSlices(block);
	        var helperName = helperSlices[0];
	        var isPartial = helperName === '>';
	        var helperContext = [];
	        var helperHash = {};
	        for (j = 1; j < helperSlices.length; j += 1) {
	          var slice = helperSlices[j];
	          if (Array.isArray(slice)) {
	            // Hash
	            helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
	          } else {
	            helperContext.push(slice);
	          }
	        }

	        if (block.indexOf('{#') >= 0) {
	          // Condition/Helper
	          var helperContent = '';
	          var elseContent = '';
	          var toSkip = 0;
	          var shiftIndex = (void 0);
	          var foundClosed = false;
	          var foundElse = false;
	          var depth = 0;
	          for (j = i + 1; j < stringBlocks.length; j += 1) {
	            if (stringBlocks[j].indexOf('{{#') >= 0) {
	              depth += 1;
	            }
	            if (stringBlocks[j].indexOf('{{/') >= 0) {
	              depth -= 1;
	            }
	            if (stringBlocks[j].indexOf(("{{#" + helperName)) >= 0) {
	              helperContent += stringBlocks[j];
	              if (foundElse) { elseContent += stringBlocks[j]; }
	              toSkip += 1;
	            } else if (stringBlocks[j].indexOf(("{{/" + helperName)) >= 0) {
	              if (toSkip > 0) {
	                toSkip -= 1;
	                helperContent += stringBlocks[j];
	                if (foundElse) { elseContent += stringBlocks[j]; }
	              } else {
	                shiftIndex = j;
	                foundClosed = true;
	                break;
	              }
	            } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
	              foundElse = true;
	            } else {
	              if (!foundElse) { helperContent += stringBlocks[j]; }
	              if (foundElse) { elseContent += stringBlocks[j]; }
	            }
	          }
	          if (foundClosed) {
	            if (shiftIndex) { i = shiftIndex; }
	            if (helperName === 'raw') {
	              blocks.push({
	                type: 'plain',
	                content: helperContent,
	              });
	            } else {
	              blocks.push({
	                type: 'helper',
	                helperName: helperName,
	                contextName: helperContext,
	                content: helperContent,
	                inverseContent: elseContent,
	                hash: helperHash,
	              });
	            }
	          }
	        } else if (block.indexOf(' ') > 0) {
	          if (isPartial) {
	            helperName = '_partial';
	            if (helperContext[0]) {
	              if (helperContext[0].indexOf('[') === 0) { helperContext[0] = helperContext[0].replace(/[[\]]/g, ''); }
	              else { helperContext[0] = "\"" + (helperContext[0].replace(/"|'/g, '')) + "\""; }
	            }
	          }
	          blocks.push({
	            type: 'helper',
	            helperName: helperName,
	            contextName: helperContext,
	            hash: helperHash,
	          });
	        }
	      }
	    }
	    return blocks;
	  },
	  parseJsVariable: function parseJsVariable(expression, replace, object) {
	    return expression.split(/([+ -*/^])/g).map(function (part) {
	      if (part.indexOf(replace) < 0) { return part; }
	      if (!object) { return JSON.stringify(''); }
	      var variable = object;
	      if (part.indexOf((replace + ".")) >= 0) {
	        part.split((replace + "."))[1].split('.').forEach(function (partName) {
	          if (variable[partName]) { variable = variable[partName]; }
	          else { variable = 'undefined'; }
	        });
	      }
	      return JSON.stringify(variable);
	    }).join('');
	  },
	  parseJsParents: function parseJsParents(expression, parents) {
	    return expression.split(/([+ -*^])/g).map(function (part) {
	      if (part.indexOf('../') < 0) { return part; }
	      if (!parents || parents.length === 0) { return JSON.stringify(''); }
	      var levelsUp = part.split('../').length - 1;
	      var parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];

	      var variable = parentData;
	      var parentPart = part.replace(/..\//g, '');
	      parentPart.split('.').forEach(function (partName) {
	        if (variable[partName]) { variable = variable[partName]; }
	        else { variable = 'undefined'; }
	      });
	      return JSON.stringify(variable);
	    }).join('');
	  },
	  getCompileVar: function getCompileVar(name, ctx, data) {
	    if ( data === void 0 ) data = 'data_1';

	    var variable = ctx;
	    var parts;
	    var levelsUp = 0;
	    var newDepth;
	    if (name.indexOf('../') === 0) {
	      levelsUp = name.split('../').length - 1;
	      newDepth = variable.split('_')[1] - levelsUp;
	      variable = "ctx_" + (newDepth >= 1 ? newDepth : 1);
	      parts = name.split('../')[levelsUp].split('.');
	    } else if (name.indexOf('@global') === 0) {
	      variable = 'Template7.global';
	      parts = name.split('@global.')[1].split('.');
	    } else if (name.indexOf('@root') === 0) {
	      variable = 'root';
	      parts = name.split('@root.')[1].split('.');
	    } else {
	      parts = name.split('.');
	    }
	    for (var i = 0; i < parts.length; i += 1) {
	      var part = parts[i];
	      if (part.indexOf('@') === 0) {
	        var dataLevel = data.split('_')[1];
	        if (levelsUp > 0) {
	          dataLevel = newDepth;
	        }
	        if (i > 0) {
	          variable += "[(data_" + dataLevel + " && data_" + dataLevel + "." + (part.replace('@', '')) + ")]";
	        } else {
	          variable = "(data_" + dataLevel + " && data_" + dataLevel + "." + (part.replace('@', '')) + ")";
	        }
	      } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
	        variable += "[" + part + "]";
	      } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
	        variable = part.replace('this', ctx);
	      } else {
	        variable += "." + part;
	      }
	    }
	    return variable;
	  },
	  getCompiledArguments: function getCompiledArguments(contextArray, ctx, data) {
	    var arr = [];
	    for (var i = 0; i < contextArray.length; i += 1) {
	      if (/^['"]/.test(contextArray[i])) { arr.push(contextArray[i]); }
	      else if (/^(true|false|\d+)$/.test(contextArray[i])) { arr.push(contextArray[i]); }
	      else {
	        arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
	      }
	    }

	    return arr.join(', ');
	  },
	};

	/* eslint no-eval: "off" */
	var Template7Helpers = {
	  _partial: function _partial(partialName, options) {
	    var ctx = this;
	    var p = Template7Class.partials[partialName];
	    if (!p || (p && !p.template)) { return ''; }
	    if (!p.compiled) {
	      p.compiled = new Template7Class(p.template).compile();
	    }
	    Object.keys(options.hash).forEach(function (hashName) {
	      ctx[hashName] = options.hash[hashName];
	    });
	    return p.compiled(ctx, options.data, options.root);
	  },
	  escape: function escape(context) {
	    if (typeof context !== 'string') {
	      throw new Error('Template7: Passed context to "escape" helper should be a string');
	    }
	    return Template7Utils.escape(context);
	  },
	  if: function if$1(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (ctx) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	  unless: function unless(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (!ctx) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	  each: function each(context, options) {
	    var ctx = context;
	    var ret = '';
	    var i = 0;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    if (Array.isArray(ctx)) {
	      if (options.hash.reverse) {
	        ctx = ctx.reverse();
	      }
	      for (i = 0; i < ctx.length; i += 1) {
	        ret += options.fn(ctx[i], { first: i === 0, last: i === ctx.length - 1, index: i });
	      }
	      if (options.hash.reverse) {
	        ctx = ctx.reverse();
	      }
	    } else {
	      // eslint-disable-next-line
	      for (var key in ctx) {
	        i += 1;
	        ret += options.fn(ctx[key], { key: key });
	      }
	    }
	    if (i > 0) { return ret; }
	    return options.inverse(this);
	  },
	  with: function with$1(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = context.call(this); }
	    return options.fn(ctx);
	  },
	  join: function join(context, options) {
	    var ctx = context;
	    if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
	    return ctx.join(options.hash.delimiter || options.hash.delimeter);
	  },
	  js: function js(expression, options) {
	    var data = options.data;
	    var func;
	    var execute = expression;
	    ('index first last key').split(' ').forEach(function (prop) {
	      if (typeof data[prop] !== 'undefined') {
	        var re1 = new RegExp(("this.@" + prop), 'g');
	        var re2 = new RegExp(("@" + prop), 'g');
	        execute = execute
	          .replace(re1, JSON.stringify(data[prop]))
	          .replace(re2, JSON.stringify(data[prop]));
	      }
	    });
	    if (options.root && execute.indexOf('@root') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
	    }
	    if (execute.indexOf('@global') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
	    }
	    if (execute.indexOf('../') >= 0) {
	      execute = Template7Utils.parseJsParents(execute, options.parents);
	    }
	    if (execute.indexOf('return') >= 0) {
	      func = "(function(){" + execute + "})";
	    } else {
	      func = "(function(){return (" + execute + ")})";
	    }
	    return eval(func).call(this);
	  },
	  js_if: function js_if(expression, options) {
	    var data = options.data;
	    var func;
	    var execute = expression;
	    ('index first last key').split(' ').forEach(function (prop) {
	      if (typeof data[prop] !== 'undefined') {
	        var re1 = new RegExp(("this.@" + prop), 'g');
	        var re2 = new RegExp(("@" + prop), 'g');
	        execute = execute
	          .replace(re1, JSON.stringify(data[prop]))
	          .replace(re2, JSON.stringify(data[prop]));
	      }
	    });
	    if (options.root && execute.indexOf('@root') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
	    }
	    if (execute.indexOf('@global') >= 0) {
	      execute = Template7Utils.parseJsVariable(execute, '@global', Template7Class.global);
	    }
	    if (execute.indexOf('../') >= 0) {
	      execute = Template7Utils.parseJsParents(execute, options.parents);
	    }
	    if (execute.indexOf('return') >= 0) {
	      func = "(function(){" + execute + "})";
	    } else {
	      func = "(function(){return (" + execute + ")})";
	    }
	    var condition = eval(func).call(this);
	    if (condition) {
	      return options.fn(this, options.data);
	    }

	    return options.inverse(this, options.data);
	  },
	};
	Template7Helpers.js_compare = Template7Helpers.js_if;

	var Template7Options = {};
	var Template7Partials = {};
	var script = Template7Context.document.createElement('script');
	Template7Context.document.head.appendChild(script);

	var Template7Class = function Template7Class(template) {
	  var t = this;
	  t.template = template;
	};

	var staticAccessors = { options: { configurable: true },partials: { configurable: true },helpers: { configurable: true } };
	Template7Class.prototype.compile = function compile (template, depth) {
	    if ( template === void 0 ) template = this.template;
	    if ( depth === void 0 ) depth = 1;

	  var t = this;
	  if (t.compiled) { return t.compiled; }

	  if (typeof template !== 'string') {
	    throw new Error('Template7: Template must be a string');
	  }
	  var stringToBlocks = Template7Utils.stringToBlocks;
	    var getCompileVar = Template7Utils.getCompileVar;
	    var getCompiledArguments = Template7Utils.getCompiledArguments;

	  var blocks = stringToBlocks(template);
	  var ctx = "ctx_" + depth;
	  var data = "data_" + depth;
	  if (blocks.length === 0) {
	    return function empty() { return ''; };
	  }

	  function getCompileFn(block, newDepth) {
	    if (block.content) { return t.compile(block.content, newDepth); }
	    return function empty() { return ''; };
	  }
	  function getCompileInverse(block, newDepth) {
	    if (block.inverseContent) { return t.compile(block.inverseContent, newDepth); }
	    return function empty() { return ''; };
	  }

	  var resultString = '';
	  if (depth === 1) {
	    resultString += "(function (" + ctx + ", " + data + ", root) {\n";
	  } else {
	    resultString += "(function (" + ctx + ", " + data + ") {\n";
	  }
	  if (depth === 1) {
	    resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
	    resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
	    resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
	    resultString += 'root = root || ctx_1 || {};\n';
	  }
	  resultString += 'var r = \'\';\n';
	  var i;
	  for (i = 0; i < blocks.length; i += 1) {
	    var block = blocks[i];
	    // Plain block
	    if (block.type === 'plain') {
	      // eslint-disable-next-line
	      resultString += "r +='" + ((block.content).replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'')) + "';";
	      continue;
	    }
	    var variable = (void 0);
	    var compiledArguments = (void 0);
	    // Variable block
	    if (block.type === 'variable') {
	      variable = getCompileVar(block.contextName, ctx, data);
	      resultString += "r += c(" + variable + ", " + ctx + ");";
	    }
	    // Helpers block
	    if (block.type === 'helper') {
	      var parents = (void 0);
	      if (ctx !== 'ctx_1') {
	        var level = ctx.split('_')[1];
	        var parentsString = "ctx_" + (level - 1);
	        for (var j = level - 2; j >= 1; j -= 1) {
	          parentsString += ", ctx_" + j;
	        }
	        parents = "[" + parentsString + "]";
	      } else {
	        parents = "[" + ctx + "]";
	      }
	      var dynamicHelper = (void 0);
	      if (block.helperName.indexOf('[') === 0) {
	        block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
	        dynamicHelper = true;
	      }
	      if (dynamicHelper || block.helperName in Template7Helpers) {
	        compiledArguments = getCompiledArguments(block.contextName, ctx, data);
	        resultString += "r += (Template7Helpers" + (dynamicHelper ? ("[" + (block.helperName) + "]") : ("." + (block.helperName))) + ").call(" + ctx + ", " + (compiledArguments && ((compiledArguments + ", "))) + "{hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	      } else if (block.contextName.length > 0) {
	        throw new Error(("Template7: Missing helper: \"" + (block.helperName) + "\""));
	      } else {
	        variable = getCompileVar(block.helperName, ctx, data);
	        resultString += "if (" + variable + ") {";
	        resultString += "if (isArray(" + variable + ")) {";
	        resultString += "r += (Template7Helpers.each).call(" + ctx + ", " + variable + ", {hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	        resultString += '}else {';
	        resultString += "r += (Template7Helpers.with).call(" + ctx + ", " + variable + ", {hash:" + (JSON.stringify(block.hash)) + ", data: " + data + " || {}, fn: " + (getCompileFn(block, depth + 1)) + ", inverse: " + (getCompileInverse(block, depth + 1)) + ", root: root, parents: " + parents + "});";
	        resultString += '}}';
	      }
	    }
	  }
	  resultString += '\nreturn r;})';

	  if (depth === 1) {
	    // eslint-disable-next-line
	    t.compiled = eval(resultString);
	    return t.compiled;
	  }
	  return resultString;
	};
	staticAccessors.options.get = function () {
	  return Template7Options;
	};
	staticAccessors.partials.get = function () {
	  return Template7Partials;
	};
	staticAccessors.helpers.get = function () {
	  return Template7Helpers;
	};

	Object.defineProperties( Template7Class, staticAccessors );

	function Template7() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var template = args[0];
	  var data = args[1];
	  if (args.length === 2) {
	    var instance = new Template7Class(template);
	    var rendered = instance.compile()(data);
	    instance = null;
	    return (rendered);
	  }
	  return new Template7Class(template);
	}
	Template7.registerHelper = function registerHelper(name, fn) {
	  Template7Class.helpers[name] = fn;
	};
	Template7.unregisterHelper = function unregisterHelper(name) {
	  Template7Class.helpers[name] = undefined;
	  delete Template7Class.helpers[name];
	};
	Template7.registerPartial = function registerPartial(name, template) {
	  Template7Class.partials[name] = { template: template };
	};
	Template7.unregisterPartial = function unregisterPartial(name) {
	  if (Template7Class.partials[name]) {
	    Template7Class.partials[name] = undefined;
	    delete Template7Class.partials[name];
	  }
	};
	Template7.compile = function compile(template, options) {
	  var instance = new Template7Class(template, options);
	  return instance.compile();
	};

	Template7.options = Template7Class.options;
	Template7.helpers = Template7Class.helpers;
	Template7.partials = Template7Class.partials;

	/**
	 * Dom7 2.0.1
	 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
	 * http://framework7.io/docs/dom.html
	 *
	 * Copyright 2017, Vladimir Kharlampidi
	 * The iDangero.us
	 * http://www.idangero.us/
	 *
	 * Licensed under MIT
	 *
	 * Released on: October 2, 2017
	 */
	var Dom7 = function Dom7(arr) {
	  var self = this;
	  // Create array-like object
	  for (var i = 0; i < arr.length; i += 1) {
	    self[i] = arr[i];
	  }
	  self.length = arr.length;
	  // Return collection with methods
	  return this;
	};

	function $$1$1(selector, context) {
	  var arr = [];
	  var i = 0;
	  if (selector && !context) {
	    if (selector instanceof Dom7) {
	      return selector;
	    }
	  }
	  if (selector) {
	      // String
	    if (typeof selector === 'string') {
	      var els;
	      var tempParent;
	      var html = selector.trim();
	      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	        var toCreate = 'div';
	        if (html.indexOf('<li') === 0) { toCreate = 'ul'; }
	        if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }
	        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }
	        if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }
	        if (html.indexOf('<option') === 0) { toCreate = 'select'; }
	        tempParent = document.createElement(toCreate);
	        tempParent.innerHTML = html;
	        for (i = 0; i < tempParent.childNodes.length; i += 1) {
	          arr.push(tempParent.childNodes[i]);
	        }
	      } else {
	        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	          // Pure ID selector
	          els = [document.getElementById(selector.trim().split('#')[1])];
	        } else {
	          // Other selectors
	          els = (context || document).querySelectorAll(selector.trim());
	        }
	        for (i = 0; i < els.length; i += 1) {
	          if (els[i]) { arr.push(els[i]); }
	        }
	      }
	    } else if (selector.nodeType || selector === window || selector === document) {
	      // Node/element
	      arr.push(selector);
	    } else if (selector.length > 0 && selector[0].nodeType) {
	      // Array of elements or instance of Dom
	      for (i = 0; i < selector.length; i += 1) {
	        arr.push(selector[i]);
	      }
	    }
	  }
	  return new Dom7(arr);
	}

	$$1$1.fn = Dom7.prototype;
	$$1$1.Class = Dom7;
	$$1$1.Dom7 = Dom7;

	function unique(arr) {
	  var uniqueArray = [];
	  for (var i = 0; i < arr.length; i += 1) {
	    if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }
	  }
	  return uniqueArray;
	}
	function toCamelCase(string) {
	  return string.toLowerCase().replace(/-(.)/g, function (match, group1) { return group1.toUpperCase(); });
	}

	function requestAnimationFrame(callback) {
	  if (window.requestAnimationFrame) { return window.requestAnimationFrame(callback); }
	  else if (window.webkitRequestAnimationFrame) { return window.webkitRequestAnimationFrame(callback); }
	  return window.setTimeout(callback, 1000 / 60);
	}
	function cancelAnimationFrame(id) {
	  if (window.cancelAnimationFrame) { return window.cancelAnimationFrame(id); }
	  else if (window.webkitCancelAnimationFrame) { return window.webkitCancelAnimationFrame(id); }
	  return window.clearTimeout(id);
	}

	// Classes and attributes
	function addClass(className) {
	  var this$1 = this;

	  if (typeof className === 'undefined') {
	    return this;
	  }
	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.add(classes[i]); }
	    }
	  }
	  return this;
	}
	function removeClass(className) {
	  var this$1 = this;

	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.remove(classes[i]); }
	    }
	  }
	  return this;
	}
	function hasClass(className) {
	  if (!this[0]) { return false; }
	  return this[0].classList.contains(className);
	}
	function toggleClass(className) {
	  var this$1 = this;

	  var classes = className.split(' ');
	  for (var i = 0; i < classes.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      if (typeof this$1[j].classList !== 'undefined') { this$1[j].classList.toggle(classes[i]); }
	    }
	  }
	  return this;
	}
	function attr(attrs, value) {
	  var arguments$1 = arguments;
	  var this$1 = this;

	  if (arguments.length === 1 && typeof attrs === 'string') {
	    // Get attr
	    if (this[0]) { return this[0].getAttribute(attrs); }
	    return undefined;
	  }

	  // Set attrs
	  for (var i = 0; i < this.length; i += 1) {
	    if (arguments$1.length === 2) {
	      // String
	      this$1[i].setAttribute(attrs, value);
	    } else {
	      // Object
	      // eslint-disable-next-line
	      for (var attrName in attrs) {
	        this$1[i][attrName] = attrs[attrName];
	        this$1[i].setAttribute(attrName, attrs[attrName]);
	      }
	    }
	  }
	  return this;
	}
	// eslint-disable-next-line
	function removeAttr(attr) {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    this$1[i].removeAttribute(attr);
	  }
	  return this;
	}
	// eslint-disable-next-line
	function prop(props, value) {
	  var arguments$1 = arguments;
	  var this$1 = this;

	  if (arguments.length === 1 && typeof props === 'string') {
	    // Get prop
	    if (this[0]) { return this[0][props]; }
	  } else {
	    // Set props
	    for (var i = 0; i < this.length; i += 1) {
	      if (arguments$1.length === 2) {
	        // String
	        this$1[i][props] = value;
	      } else {
	        // Object
	        // eslint-disable-next-line
	        for (var propName in props) {
	          this$1[i][propName] = props[propName];
	        }
	      }
	    }
	    return this;
	  }
	}
	function data(key, value) {
	  var this$1 = this;

	  var el;
	  if (typeof value === 'undefined') {
	    el = this[0];
	    // Get value
	    if (el) {
	      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
	        return el.dom7ElementDataStorage[key];
	      }

	      var dataKey = el.getAttribute(("data-" + key));
	      if (dataKey) {
	        return dataKey;
	      }
	      return undefined;
	    }
	    return undefined;
	  }

	  // Set value
	  for (var i = 0; i < this.length; i += 1) {
	    el = this$1[i];
	    if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }
	    el.dom7ElementDataStorage[key] = value;
	  }
	  return this;
	}
	function removeData(key) {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    var el = this$1[i];
	    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
	      el.dom7ElementDataStorage[key] = null;
	      delete el.dom7ElementDataStorage[key];
	    }
	  }
	}
	function dataset() {
	  var el = this[0];
	  if (!el) { return undefined; }
	  var dataset = {}; // eslint-disable-line
	  if (el.dataset) {
	    // eslint-disable-next-line
	    for (var dataKey in el.dataset) {
	      dataset[dataKey] = el.dataset[dataKey];
	    }
	  } else {
	    for (var i = 0; i < el.attributes.length; i += 1) {
	      // eslint-disable-next-line
	      var attr = el.attributes[i];
	      if (attr.name.indexOf('data-') >= 0) {
	        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
	      }
	    }
	  }
	  // eslint-disable-next-line
	  for (var key in dataset) {
	    if (dataset[key] === 'false') { dataset[key] = false; }
	    else if (dataset[key] === 'true') { dataset[key] = true; }
	    else if (parseFloat(dataset[key]) === dataset[key] * 1) { dataset[key] *= 1; }
	  }
	  return dataset;
	}
	function val(value) {
	  var this$1 = this;

	  if (typeof value === 'undefined') {
	    if (this[0]) {
	      if (this[0].multiple && this[0].nodeName.toLowerCase() === 'select') {
	        var values = [];
	        for (var i = 0; i < this[0].selectedOptions.length; i += 1) {
	          values.push(this$1[0].selectedOptions[i].value);
	        }
	        return values;
	      }
	      return this[0].value;
	    }
	    return undefined;
	  }

	  for (var i$1 = 0; i$1 < this.length; i$1 += 1) {
	    this$1[i$1].value = value;
	  }
	  return this;
	}
	// Transforms
	// eslint-disable-next-line
	function transform(transform) {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    var elStyle = this$1[i].style;
	    elStyle.webkitTransform = transform;
	    elStyle.transform = transform;
	  }
	  return this;
	}
	function transition(duration) {
	  var this$1 = this;

	  if (typeof duration !== 'string') {
	    duration = duration + "ms"; // eslint-disable-line
	  }
	  for (var i = 0; i < this.length; i += 1) {
	    var elStyle = this$1[i].style;
	    elStyle.webkitTransitionDuration = duration;
	    elStyle.transitionDuration = duration;
	  }
	  return this;
	}
	// Events
	function on() {
	  var this$1 = this;
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var eventType = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    var assign;
	    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  if (!capture) { capture = false; }

	  function handleLiveEvent(e) {
	    var target = e.target;
	    if (!target) { return; }
	    var eventData = e.target.dom7EventData || [];
	    eventData.unshift(e);
	    if ($$1$1(target).is(targetSelector)) { listener.apply(target, eventData); }
	    else {
	      var parents = $$1$1(target).parents(); // eslint-disable-line
	      for (var k = 0; k < parents.length; k += 1) {
	        if ($$1$1(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }
	      }
	    }
	  }
	  function handleEvent(e) {
	    var eventData = e && e.target ? e.target.dom7EventData || [] : [];
	    eventData.unshift(e);
	    listener.apply(this, eventData);
	  }
	  var events = eventType.split(' ');
	  var j;
	  for (var i = 0; i < this.length; i += 1) {
	    var el = this$1[i];
	    if (!targetSelector) {
	      for (j = 0; j < events.length; j += 1) {
	        if (!el.dom7Listeners) { el.dom7Listeners = []; }
	        el.dom7Listeners.push({
	          type: eventType,
	          listener: listener,
	          proxyListener: handleEvent,
	        });
	        el.addEventListener(events[j], handleEvent, capture);
	      }
	    } else {
	      // Live events
	      for (j = 0; j < events.length; j += 1) {
	        if (!el.dom7LiveListeners) { el.dom7LiveListeners = []; }
	        el.dom7LiveListeners.push({
	          type: eventType,
	          listener: listener,
	          proxyListener: handleLiveEvent,
	        });
	        el.addEventListener(events[j], handleLiveEvent, capture);
	      }
	    }
	  }
	  return this;
	}
	function off() {
	  var this$1 = this;
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var eventType = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    var assign;
	    (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  if (!capture) { capture = false; }

	  var events = eventType.split(' ');
	  for (var i = 0; i < events.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      var el = this$1[j];
	      if (!targetSelector) {
	        if (el.dom7Listeners) {
	          for (var k = 0; k < el.dom7Listeners.length; k += 1) {
	            if (listener) {
	              if (el.dom7Listeners[k].listener === listener) {
	                el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);
	              }
	            } else if (el.dom7Listeners[k].type === events[i]) {
	              el.removeEventListener(events[i], el.dom7Listeners[k].proxyListener, capture);
	            }
	          }
	        }
	      } else if (el.dom7LiveListeners) {
	        for (var k$1 = 0; k$1 < el.dom7LiveListeners.length; k$1 += 1) {
	          if (listener) {
	            if (el.dom7LiveListeners[k$1].listener === listener) {
	              el.removeEventListener(events[i], el.dom7LiveListeners[k$1].proxyListener, capture);
	            }
	          } else if (el.dom7LiveListeners[k$1].type === events[i]) {
	            el.removeEventListener(events[i], el.dom7LiveListeners[k$1].proxyListener, capture);
	          }
	        }
	      }
	    }
	  }
	  return this;
	}
	function once() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var dom = this;
	  var eventName = args[0];
	  var targetSelector = args[1];
	  var listener = args[2];
	  var capture = args[3];
	  if (typeof args[1] === 'function') {
	    var assign;
	    (assign = args, eventName = assign[0], listener = assign[1], capture = assign[2]);
	    targetSelector = undefined;
	  }
	  function proxy(e) {
	    var eventData = e.target.dom7EventData || [];
	    listener.apply(this, eventData);
	    dom.off(eventName, targetSelector, proxy, capture);
	  }
	  return dom.on(eventName, targetSelector, proxy, capture);
	}
	function trigger() {
	  var this$1 = this;
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var events = args[0].split(' ');
	  var eventData = args[1];
	  for (var i = 0; i < events.length; i += 1) {
	    for (var j = 0; j < this.length; j += 1) {
	      var evt = (void 0);
	      try {
	        evt = new window.CustomEvent(events[i], {
	          detail: eventData,
	          bubbles: true,
	          cancelable: true,
	        });
	      } catch (e) {
	        evt = document.createEvent('Event');
	        evt.initEvent(events[i], true, true);
	        evt.detail = eventData;
	      }
	      // eslint-disable-next-line
	      this$1[j].dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });
	      this$1[j].dispatchEvent(evt);
	      this$1[j].dom7EventData = [];
	      delete this$1[j].dom7EventData;
	    }
	  }
	  return this;
	}
	function transitionEnd(callback) {
	  var events = ['webkitTransitionEnd', 'transitionend'];
	  var dom = this;
	  var i;
	  function fireCallBack(e) {
	    /* jshint validthis:true */
	    if (e.target !== this) { return; }
	    callback.call(this, e);
	    for (i = 0; i < events.length; i += 1) {
	      dom.off(events[i], fireCallBack);
	    }
	  }
	  if (callback) {
	    for (i = 0; i < events.length; i += 1) {
	      dom.on(events[i], fireCallBack);
	    }
	  }
	  return this;
	}
	function animationEnd(callback) {
	  var events = ['webkitAnimationEnd', 'animationend'];
	  var dom = this;
	  var i;
	  function fireCallBack(e) {
	    if (e.target !== this) { return; }
	    callback.call(this, e);
	    for (i = 0; i < events.length; i += 1) {
	      dom.off(events[i], fireCallBack);
	    }
	  }
	  if (callback) {
	    for (i = 0; i < events.length; i += 1) {
	      dom.on(events[i], fireCallBack);
	    }
	  }
	  return this;
	}
	// Sizing/Styles
	function width() {
	  if (this[0] === window) {
	    return window.innerWidth;
	  }

	  if (this.length > 0) {
	    return parseFloat(this.css('width'));
	  }

	  return null;
	}
	function outerWidth(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      var styles = this.styles();
	      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
	    }
	    return this[0].offsetWidth;
	  }
	  return null;
	}
	function height() {
	  if (this[0] === window) {
	    return window.innerHeight;
	  }

	  if (this.length > 0) {
	    return parseFloat(this.css('height'));
	  }

	  return null;
	}
	function outerHeight(includeMargins) {
	  if (this.length > 0) {
	    if (includeMargins) {
	      // eslint-disable-next-line
	      var styles = this.styles();
	      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
	    }
	    return this[0].offsetHeight;
	  }
	  return null;
	}
	function offset() {
	  if (this.length > 0) {
	    var el = this[0];
	    var box = el.getBoundingClientRect();
	    var body = document.body;
	    var clientTop = el.clientTop || body.clientTop || 0;
	    var clientLeft = el.clientLeft || body.clientLeft || 0;
	    var scrollTop = el === window ? window.scrollY : el.scrollTop;
	    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
	    return {
	      top: (box.top + scrollTop) - clientTop,
	      left: (box.left + scrollLeft) - clientLeft,
	    };
	  }

	  return null;
	}
	function hide() {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    this$1[i].style.display = 'none';
	  }
	  return this;
	}
	function show() {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    var el = this$1[i];
	    if (el.style.display === 'none') {
	      el.style.display = '';
	    }
	    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
	      // Still not visible
	      el.style.display = 'block';
	    }
	  }
	  return this;
	}
	function styles() {
	  if (this[0]) { return window.getComputedStyle(this[0], null); }
	  return {};
	}
	function css(props, value) {
	  var this$1 = this;

	  var i;
	  if (arguments.length === 1) {
	    if (typeof props === 'string') {
	      if (this[0]) { return window.getComputedStyle(this[0], null).getPropertyValue(props); }
	    } else {
	      for (i = 0; i < this.length; i += 1) {
	        // eslint-disable-next-line
	        for (var prop in props) {
	          this$1[i].style[prop] = props[prop];
	        }
	      }
	      return this;
	    }
	  }
	  if (arguments.length === 2 && typeof props === 'string') {
	    for (i = 0; i < this.length; i += 1) {
	      this$1[i].style[props] = value;
	    }
	    return this;
	  }
	  return this;
	}

	// Dom manipulation
	function toArray() {
	  var this$1 = this;

	  var arr = [];
	  for (var i = 0; i < this.length; i += 1) {
	    arr.push(this$1[i]);
	  }
	  return arr;
	}
	// Iterate over the collection passing elements to `callback`
	function each(callback) {
	  var this$1 = this;

	  // Don't bother continuing without a callback
	  if (!callback) { return this; }
	  // Iterate over the current collection
	  for (var i = 0; i < this.length; i += 1) {
	    // If the callback returns false
	    if (callback.call(this$1[i], i, this$1[i]) === false) {
	      // End the loop early
	      return this$1;
	    }
	  }
	  // Return `this` to allow chained DOM operations
	  return this;
	}
	function forEach(callback) {
	  var this$1 = this;

	  // Don't bother continuing without a callback
	  if (!callback) { return this; }
	  // Iterate over the current collection
	  for (var i = 0; i < this.length; i += 1) {
	    // If the callback returns false
	    if (callback.call(this$1[i], this$1[i], i) === false) {
	      // End the loop early
	      return this$1;
	    }
	  }
	  // Return `this` to allow chained DOM operations
	  return this;
	}
	function filter(callback) {
	  var matchedItems = [];
	  var dom = this;
	  for (var i = 0; i < dom.length; i += 1) {
	    if (callback.call(dom[i], i, dom[i])) { matchedItems.push(dom[i]); }
	  }
	  return new Dom7(matchedItems);
	}
	function map(callback) {
	  var modifiedItems = [];
	  var dom = this;
	  for (var i = 0; i < dom.length; i += 1) {
	    modifiedItems.push(callback.call(dom[i], i, dom[i]));
	  }
	  return new Dom7(modifiedItems);
	}
	// eslint-disable-next-line
	function html(html) {
	  var this$1 = this;

	  if (typeof html === 'undefined') {
	    return this[0] ? this[0].innerHTML : undefined;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this$1[i].innerHTML = html;
	  }
	  return this;
	}
	// eslint-disable-next-line
	function text(text) {
	  var this$1 = this;

	  if (typeof text === 'undefined') {
	    if (this[0]) {
	      return this[0].textContent.trim();
	    }
	    return null;
	  }

	  for (var i = 0; i < this.length; i += 1) {
	    this$1[i].textContent = text;
	  }
	  return this;
	}
	function is(selector) {
	  var el = this[0];
	  var compareWith;
	  var i;
	  if (!el || typeof selector === 'undefined') { return false; }
	  if (typeof selector === 'string') {
	    if (el.matches) { return el.matches(selector); }
	    else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }
	    else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }

	    compareWith = $$1$1(selector);
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) { return true; }
	    }
	    return false;
	  } else if (selector === document) { return el === document; }
	  else if (selector === window) { return el === window; }

	  if (selector.nodeType || selector instanceof Dom7) {
	    compareWith = selector.nodeType ? [selector] : selector;
	    for (i = 0; i < compareWith.length; i += 1) {
	      if (compareWith[i] === el) { return true; }
	    }
	    return false;
	  }
	  return false;
	}
	function indexOf(el) {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    if (this$1[i] === el) { return i; }
	  }
	  return -1;
	}
	function index() {
	  var child = this[0];
	  var i;
	  if (child) {
	    i = 0;
	    // eslint-disable-next-line
	    while ((child = child.previousSibling) !== null) {
	      if (child.nodeType === 1) { i += 1; }
	    }
	    return i;
	  }
	  return undefined;
	}
	// eslint-disable-next-line
	function eq(index) {
	  if (typeof index === 'undefined') { return this; }
	  var length = this.length;
	  var returnIndex;
	  if (index > length - 1) {
	    return new Dom7([]);
	  }
	  if (index < 0) {
	    returnIndex = length + index;
	    if (returnIndex < 0) { return new Dom7([]); }
	    return new Dom7([this[returnIndex]]);
	  }
	  return new Dom7([this[index]]);
	}
	function append() {
	  var this$1 = this;
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var newChild;

	  for (var k = 0; k < args.length; k += 1) {
	    newChild = args[k];
	    for (var i = 0; i < this.length; i += 1) {
	      if (typeof newChild === 'string') {
	        var tempDiv = document.createElement('div');
	        tempDiv.innerHTML = newChild;
	        while (tempDiv.firstChild) {
	          this$1[i].appendChild(tempDiv.firstChild);
	        }
	      } else if (newChild instanceof Dom7) {
	        for (var j = 0; j < newChild.length; j += 1) {
	          this$1[i].appendChild(newChild[j]);
	        }
	      } else {
	        this$1[i].appendChild(newChild);
	      }
	    }
	  }

	  return this;
	}
	 // eslint-disable-next-line
	function appendTo(parent) {
	  $$1$1(parent).append(this);
	  return this;
	}
	function prepend(newChild) {
	  var this$1 = this;

	  var i;
	  var j;
	  for (i = 0; i < this.length; i += 1) {
	    if (typeof newChild === 'string') {
	      var tempDiv = document.createElement('div');
	      tempDiv.innerHTML = newChild;
	      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
	        this$1[i].insertBefore(tempDiv.childNodes[j], this$1[i].childNodes[0]);
	      }
	    } else if (newChild instanceof Dom7) {
	      for (j = 0; j < newChild.length; j += 1) {
	        this$1[i].insertBefore(newChild[j], this$1[i].childNodes[0]);
	      }
	    } else {
	      this$1[i].insertBefore(newChild, this$1[i].childNodes[0]);
	    }
	  }
	  return this;
	}
	 // eslint-disable-next-line
	function prependTo(parent) {
	  $$1$1(parent).prepend(this);
	  return this;
	}
	function insertBefore(selector) {
	  var this$1 = this;

	  var before = $$1$1(selector);
	  for (var i = 0; i < this.length; i += 1) {
	    if (before.length === 1) {
	      before[0].parentNode.insertBefore(this$1[i], before[0]);
	    } else if (before.length > 1) {
	      for (var j = 0; j < before.length; j += 1) {
	        before[j].parentNode.insertBefore(this$1[i].cloneNode(true), before[j]);
	      }
	    }
	  }
	}
	function insertAfter(selector) {
	  var this$1 = this;

	  var after = $$1$1(selector);
	  for (var i = 0; i < this.length; i += 1) {
	    if (after.length === 1) {
	      after[0].parentNode.insertBefore(this$1[i], after[0].nextSibling);
	    } else if (after.length > 1) {
	      for (var j = 0; j < after.length; j += 1) {
	        after[j].parentNode.insertBefore(this$1[i].cloneNode(true), after[j].nextSibling);
	      }
	    }
	  }
	}
	function next(selector) {
	  if (this.length > 0) {
	    if (selector) {
	      if (this[0].nextElementSibling && $$1$1(this[0].nextElementSibling).is(selector)) {
	        return new Dom7([this[0].nextElementSibling]);
	      }
	      return new Dom7([]);
	    }

	    if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function nextAll(selector) {
	  var nextEls = [];
	  var el = this[0];
	  if (!el) { return new Dom7([]); }
	  while (el.nextElementSibling) {
	    var next = el.nextElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($$1$1(next).is(selector)) { nextEls.push(next); }
	    } else { nextEls.push(next); }
	    el = next;
	  }
	  return new Dom7(nextEls);
	}
	function prev(selector) {
	  if (this.length > 0) {
	    var el = this[0];
	    if (selector) {
	      if (el.previousElementSibling && $$1$1(el.previousElementSibling).is(selector)) {
	        return new Dom7([el.previousElementSibling]);
	      }
	      return new Dom7([]);
	    }

	    if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }
	    return new Dom7([]);
	  }
	  return new Dom7([]);
	}
	function prevAll(selector) {
	  var prevEls = [];
	  var el = this[0];
	  if (!el) { return new Dom7([]); }
	  while (el.previousElementSibling) {
	    var prev = el.previousElementSibling; // eslint-disable-line
	    if (selector) {
	      if ($$1$1(prev).is(selector)) { prevEls.push(prev); }
	    } else { prevEls.push(prev); }
	    el = prev;
	  }
	  return new Dom7(prevEls);
	}
	function siblings(selector) {
	  return this.nextAll(selector).add(this.prevAll(selector));
	}
	function parent(selector) {
	  var this$1 = this;

	  var parents = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    if (this$1[i].parentNode !== null) {
	      if (selector) {
	        if ($$1$1(this$1[i].parentNode).is(selector)) { parents.push(this$1[i].parentNode); }
	      } else {
	        parents.push(this$1[i].parentNode);
	      }
	    }
	  }
	  return $$1$1(unique(parents));
	}
	function parents(selector) {
	  var this$1 = this;

	  var parents = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    var parent = this$1[i].parentNode; // eslint-disable-line
	    while (parent) {
	      if (selector) {
	        if ($$1$1(parent).is(selector)) { parents.push(parent); }
	      } else {
	        parents.push(parent);
	      }
	      parent = parent.parentNode;
	    }
	  }
	  return $$1$1(unique(parents));
	}
	function closest(selector) {
	  var closest = this; // eslint-disable-line
	  if (typeof selector === 'undefined') {
	    return new Dom7([]);
	  }
	  if (!closest.is(selector)) {
	    closest = closest.parents(selector).eq(0);
	  }
	  return closest;
	}
	function find(selector) {
	  var this$1 = this;

	  var foundElements = [];
	  for (var i = 0; i < this.length; i += 1) {
	    var found = this$1[i].querySelectorAll(selector);
	    for (var j = 0; j < found.length; j += 1) {
	      foundElements.push(found[j]);
	    }
	  }
	  return new Dom7(foundElements);
	}
	function children(selector) {
	  var this$1 = this;

	  var children = []; // eslint-disable-line
	  for (var i = 0; i < this.length; i += 1) {
	    var childNodes = this$1[i].childNodes;

	    for (var j = 0; j < childNodes.length; j += 1) {
	      if (!selector) {
	        if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }
	      } else if (childNodes[j].nodeType === 1 && $$1$1(childNodes[j]).is(selector)) {
	        children.push(childNodes[j]);
	      }
	    }
	  }
	  return new Dom7(unique(children));
	}
	function remove() {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    if (this$1[i].parentNode) { this$1[i].parentNode.removeChild(this$1[i]); }
	  }
	  return this;
	}
	function detach() {
	  return this.remove();
	}
	function add() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var dom = this;
	  var i;
	  var j;
	  for (i = 0; i < args.length; i += 1) {
	    var toAdd = $$1$1(args[i]);
	    for (j = 0; j < toAdd.length; j += 1) {
	      dom[dom.length] = toAdd[j];
	      dom.length += 1;
	    }
	  }
	  return dom;
	}
	function empty() {
	  var this$1 = this;

	  for (var i = 0; i < this.length; i += 1) {
	    var el = this$1[i];
	    if (el.nodeType === 1) {
	      for (var j = 0; j < el.childNodes.length; j += 1) {
	        if (el.childNodes[j].parentNode) {
	          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
	        }
	      }
	      el.textContent = '';
	    }
	  }
	  return this;
	}




	var Methods = Object.freeze({
		addClass: addClass,
		removeClass: removeClass,
		hasClass: hasClass,
		toggleClass: toggleClass,
		attr: attr,
		removeAttr: removeAttr,
		prop: prop,
		data: data,
		removeData: removeData,
		dataset: dataset,
		val: val,
		transform: transform,
		transition: transition,
		on: on,
		off: off,
		once: once,
		trigger: trigger,
		transitionEnd: transitionEnd,
		animationEnd: animationEnd,
		width: width,
		outerWidth: outerWidth,
		height: height,
		outerHeight: outerHeight,
		offset: offset,
		hide: hide,
		show: show,
		styles: styles,
		css: css,
		toArray: toArray,
		each: each,
		forEach: forEach,
		filter: filter,
		map: map,
		html: html,
		text: text,
		is: is,
		indexOf: indexOf,
		index: index,
		eq: eq,
		append: append,
		appendTo: appendTo,
		prepend: prepend,
		prependTo: prependTo,
		insertBefore: insertBefore,
		insertAfter: insertAfter,
		next: next,
		nextAll: nextAll,
		prev: prev,
		prevAll: prevAll,
		siblings: siblings,
		parent: parent,
		parents: parents,
		closest: closest,
		find: find,
		children: children,
		remove: remove,
		detach: detach,
		add: add,
		empty: empty
	});

	function scrollTo() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var left = args[0];
	  var top = args[1];
	  var duration = args[2];
	  var easing = args[3];
	  var callback = args[4];
	  if (args.length === 4 && typeof easing === 'function') {
	    callback = easing;
	    var assign;
	    (assign = args, left = assign[0], top = assign[1], duration = assign[2], callback = assign[3], easing = assign[4]);
	  }
	  if (typeof easing === 'undefined') { easing = 'swing'; }

	  return this.each(function animate() {
	    var el = this;
	    var currentTop;
	    var currentLeft;
	    var maxTop;
	    var maxLeft;
	    var newTop;
	    var newLeft;
	    var scrollTop; // eslint-disable-line
	    var scrollLeft; // eslint-disable-line
	    var animateTop = top > 0 || top === 0;
	    var animateLeft = left > 0 || left === 0;
	    if (typeof easing === 'undefined') {
	      easing = 'swing';
	    }
	    if (animateTop) {
	      currentTop = el.scrollTop;
	      if (!duration) {
	        el.scrollTop = top;
	      }
	    }
	    if (animateLeft) {
	      currentLeft = el.scrollLeft;
	      if (!duration) {
	        el.scrollLeft = left;
	      }
	    }
	    if (!duration) { return; }
	    if (animateTop) {
	      maxTop = el.scrollHeight - el.offsetHeight;
	      newTop = Math.max(Math.min(top, maxTop), 0);
	    }
	    if (animateLeft) {
	      maxLeft = el.scrollWidth - el.offsetWidth;
	      newLeft = Math.max(Math.min(left, maxLeft), 0);
	    }
	    var startTime = null;
	    if (animateTop && newTop === currentTop) { animateTop = false; }
	    if (animateLeft && newLeft === currentLeft) { animateLeft = false; }
	    function render(time) {
	      if ( time === void 0 ) time = new Date().getTime();

	      if (startTime === null) {
	        startTime = time;
	      }
	      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
	      var easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
	      var done;
	      if (animateTop) { scrollTop = currentTop + (easeProgress * (newTop - currentTop)); }
	      if (animateLeft) { scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft)); }
	      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
	        el.scrollTop = newTop;
	        done = true;
	      }
	      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
	        el.scrollTop = newTop;
	        done = true;
	      }
	      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
	        el.scrollLeft = newLeft;
	        done = true;
	      }
	      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
	        el.scrollLeft = newLeft;
	        done = true;
	      }

	      if (done) {
	        if (callback) { callback(); }
	        return;
	      }
	      if (animateTop) { el.scrollTop = scrollTop; }
	      if (animateLeft) { el.scrollLeft = scrollLeft; }
	      requestAnimationFrame(render);
	    }
	    requestAnimationFrame(render);
	  });
	}
	// scrollTop(top, duration, easing, callback) {
	function scrollTop() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var top = args[0];
	  var duration = args[1];
	  var easing = args[2];
	  var callback = args[3];
	  if (args.length === 3 && typeof easing === 'function') {
	    var assign;
	    (assign = args, top = assign[0], duration = assign[1], callback = assign[2], easing = assign[3]);
	  }
	  var dom = this;
	  if (typeof top === 'undefined') {
	    if (dom.length > 0) { return dom[0].scrollTop; }
	    return null;
	  }
	  return dom.scrollTo(undefined, top, duration, easing, callback);
	}
	function scrollLeft() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  var left = args[0];
	  var duration = args[1];
	  var easing = args[2];
	  var callback = args[3];
	  if (args.length === 3 && typeof easing === 'function') {
	    var assign;
	    (assign = args, left = assign[0], duration = assign[1], callback = assign[2], easing = assign[3]);
	  }
	  var dom = this;
	  if (typeof left === 'undefined') {
	    if (dom.length > 0) { return dom[0].scrollLeft; }
	    return null;
	  }
	  return dom.scrollTo(left, undefined, duration, easing, callback);
	}




	var Scroll = Object.freeze({
		scrollTo: scrollTo,
		scrollTop: scrollTop,
		scrollLeft: scrollLeft
	});

	function animate(initialProps, initialParams) {
	  var els = this;
	  var a = {
	    props: $$1$1.extend({}, initialProps),
	    params: $$1$1.extend({
	      duration: 300,
	      easing: 'swing', // or 'linear'
	      /* Callbacks
	      begin(elements)
	      complete(elements)
	      progress(elements, complete, remaining, start, tweenValue)
	      */
	    }, initialParams),

	    elements: els,
	    animating: false,
	    que: [],

	    easingProgress: function easingProgress(easing, progress) {
	      if (easing === 'swing') {
	        return 0.5 - (Math.cos(progress * Math.PI) / 2);
	      }
	      if (typeof easing === 'function') {
	        return easing(progress);
	      }
	      return progress;
	    },
	    stop: function stop() {
	      if (a.frameId) {
	        cancelAnimationFrame(a.frameId);
	      }
	      a.animating = false;
	      a.elements.each(function (index, el) {
	        var element = el;
	        delete element.dom7AnimateInstance;
	      });
	      a.que = [];
	    },
	    done: function done(complete) {
	      a.animating = false;
	      a.elements.each(function (index, el) {
	        var element = el;
	        delete element.dom7AnimateInstance;
	      });
	      if (complete) { complete(els); }
	      if (a.que.length > 0) {
	        var que = a.que.shift();
	        a.animate(que[0], que[1]);
	      }
	    },
	    animate: function animate(props, params) {
	      if (a.animating) {
	        a.que.push([props, params]);
	        return a;
	      }
	      var elements = [];

	      // Define & Cache Initials & Units
	      a.elements.each(function (index, el) {
	        var initialFullValue;
	        var initialValue;
	        var unit;
	        var finalValue;
	        var finalFullValue;

	        if (!el.dom7AnimateInstance) { a.elements[index].dom7AnimateInstance = a; }

	        elements[index] = {
	          container: el,
	        };
	        Object.keys(props).forEach(function (prop) {
	          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
	          initialValue = parseFloat(initialFullValue);
	          unit = initialFullValue.replace(initialValue, '');
	          finalValue = parseFloat(props[prop]);
	          finalFullValue = props[prop] + unit;
	          elements[index][prop] = {
	            initialFullValue: initialFullValue,
	            initialValue: initialValue,
	            unit: unit,
	            finalValue: finalValue,
	            finalFullValue: finalFullValue,
	            currentValue: initialValue,
	          };
	        });
	      });

	      var startTime = null;
	      var time;
	      var elementsDone = 0;
	      var propsDone = 0;
	      var done;
	      var began = false;

	      a.animating = true;

	      function render() {
	        time = new Date().getTime();
	        var progress;
	        var easeProgress;
	        // let el;
	        if (!began) {
	          began = true;
	          if (params.begin) { params.begin(els); }
	        }
	        if (startTime === null) {
	          startTime = time;
	        }
	        if (params.progress) {
	          // eslint-disable-next-line
	          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
	        }

	        elements.forEach(function (element) {
	          var el = element;
	          if (done || el.done) { return; }
	          Object.keys(props).forEach(function (prop) {
	            if (done || el.done) { return; }
	            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
	            easeProgress = a.easingProgress(params.easing, progress);
	            var ref = el[prop];
	            var initialValue = ref.initialValue;
	            var finalValue = ref.finalValue;
	            var unit = ref.unit;
	            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
	            var currentValue = el[prop].currentValue;

	            if (
	              (finalValue > initialValue && currentValue >= finalValue) ||
	              (finalValue < initialValue && currentValue <= finalValue)) {
	              el.container.style[prop] = finalValue + unit;
	              propsDone += 1;
	              if (propsDone === Object.keys(props).length) {
	                el.done = true;
	                elementsDone += 1;
	              }
	              if (elementsDone === elements.length) {
	                done = true;
	              }
	            }
	            if (done) {
	              a.done(params.complete);
	              return;
	            }
	            el.container.style[prop] = currentValue + unit;
	          });
	        });
	        if (done) { return; }
	        // Then call
	        a.frameId = requestAnimationFrame(render);
	      }
	      a.frameId = requestAnimationFrame(render);
	      return a;
	    },
	  };

	  if (a.elements.length === 0) {
	    return els;
	  }

	  var animateInstance;
	  for (var i = 0; i < a.elements.length; i += 1) {
	    if (a.elements[i].dom7AnimateInstance) {
	      animateInstance = a.elements[i].dom7AnimateInstance;
	    } else { a.elements[i].dom7AnimateInstance = a; }
	  }
	  if (!animateInstance) {
	    animateInstance = a;
	  }

	  if (initialProps === 'stop') {
	    animateInstance.stop();
	  } else {
	    animateInstance.animate(a.props, a.params);
	  }

	  return els;
	}

	function stop() {
	  var els = this;
	  for (var i = 0; i < els.length; i += 1) {
	    if (els[i].dom7AnimateInstance) {
	      els[i].dom7AnimateInstance.stop();
	    }
	  }
	}




	var Animate = Object.freeze({
		animate: animate,
		stop: stop
	});

	var noTrigger = ('resize scroll').split(' ');
	function eventShortcut(name) {
	  var this$1 = this;
	  var args = [], len = arguments.length - 1;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  if (typeof args[0] === 'undefined') {
	    for (var i = 0; i < this.length; i += 1) {
	      if (noTrigger.indexOf(name) < 0) {
	        if (name in this$1[i]) { this$1[i][name](); }
	        else {
	          $$1$1(this$1[i]).trigger(name);
	        }
	      }
	    }
	    return this;
	  }
	  return (ref = this).on.apply(ref, [ name ].concat( args ));
	  var ref;
	}

	function click() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'click' ].concat( args ));
	}
	function blur() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'blur' ].concat( args ));
	}
	function focus() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focus' ].concat( args ));
	}
	function focusin() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focusin' ].concat( args ));
	}
	function focusout() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'focusout' ].concat( args ));
	}
	function keyup() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keyup' ].concat( args ));
	}
	function keydown() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keydown' ].concat( args ));
	}
	function keypress() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'keypress' ].concat( args ));
	}
	function submit() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'submit' ].concat( args ));
	}
	function change() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'change' ].concat( args ));
	}
	function mousedown() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mousedown' ].concat( args ));
	}
	function mousemove() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mousemove' ].concat( args ));
	}
	function mouseup() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseup' ].concat( args ));
	}
	function mouseenter() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseenter' ].concat( args ));
	}
	function mouseleave() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseleave' ].concat( args ));
	}
	function mouseout() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseout' ].concat( args ));
	}
	function mouseover() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'mouseover' ].concat( args ));
	}
	function touchstart() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchstart' ].concat( args ));
	}
	function touchend() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchend' ].concat( args ));
	}
	function touchmove() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'touchmove' ].concat( args ));
	}
	function resize() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'resize' ].concat( args ));
	}
	function scroll() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return eventShortcut.bind(this).apply(void 0, [ 'scroll' ].concat( args ));
	}




	var eventShortcuts = Object.freeze({
		click: click,
		blur: blur,
		focus: focus,
		focusin: focusin,
		focusout: focusout,
		keyup: keyup,
		keydown: keydown,
		keypress: keypress,
		submit: submit,
		change: change,
		mousedown: mousedown,
		mousemove: mousemove,
		mouseup: mouseup,
		mouseenter: mouseenter,
		mouseleave: mouseleave,
		mouseout: mouseout,
		mouseover: mouseover,
		touchstart: touchstart,
		touchend: touchend,
		touchmove: touchmove,
		resize: resize,
		scroll: scroll
	});

	[Methods, Scroll, Animate, eventShortcuts].forEach(function (group) {
	  Object.keys(group).forEach(function (methodName) {
	    $$1$1.fn[methodName] = group[methodName];
	  });
	});

	/**
	 * https://github.com/gre/bezier-easing
	 * BezierEasing - use bezier curve for transition easing function
	 * by Gatan Renaudeau 2014 - 2015  MIT License
	 */

	/* eslint-disable */

	// These values are established by empiricism with tests (tradeoff: performance VS precision)
	var NEWTON_ITERATIONS = 4;
	var NEWTON_MIN_SLOPE = 0.001;
	var SUBDIVISION_PRECISION = 0.0000001;
	var SUBDIVISION_MAX_ITERATIONS = 10;

	var kSplineTableSize = 11;
	var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

	var float32ArraySupported = typeof Float32Array === 'function';

	function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
	function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
	function C (aA1)      { return 3.0 * aA1; }

	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

	// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
	function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

	function binarySubdivide (aX, aA, aB, mX1, mX2) {
	  var currentX, currentT, i = 0;
	  do {
	    currentT = aA + (aB - aA) / 2.0;
	    currentX = calcBezier(currentT, mX1, mX2) - aX;
	    if (currentX > 0.0) {
	      aB = currentT;
	    } else {
	      aA = currentT;
	    }
	  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
	  return currentT;
	}

	function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
	 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
	   var currentSlope = getSlope(aGuessT, mX1, mX2);
	   if (currentSlope === 0.0) {
	     return aGuessT;
	   }
	   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
	   aGuessT -= currentX / currentSlope;
	 }
	 return aGuessT;
	}

	function bezier (mX1, mY1, mX2, mY2) {
	  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
	    throw new Error('bezier x values must be in [0, 1] range');
	  }

	  // Precompute samples table
	  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
	  if (mX1 !== mY1 || mX2 !== mY2) {
	    for (var i = 0; i < kSplineTableSize; ++i) {
	      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
	    }
	  }

	  function getTForX (aX) {
	    var intervalStart = 0.0;
	    var currentSample = 1;
	    var lastSample = kSplineTableSize - 1;

	    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
	      intervalStart += kSampleStepSize;
	    }
	    --currentSample;

	    // Interpolate to provide an initial guess for t
	    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
	    var guessForT = intervalStart + dist * kSampleStepSize;

	    var initialSlope = getSlope(guessForT, mX1, mX2);
	    if (initialSlope >= NEWTON_MIN_SLOPE) {
	      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
	    } else if (initialSlope === 0.0) {
	      return guessForT;
	    } else {
	      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
	    }
	  }

	  return function BezierEasing (x) {
	    if (mX1 === mY1 && mX2 === mY2) {
	      return x; // linear
	    }
	    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
	    if (x === 0) {
	      return 0;
	    }
	    if (x === 1) {
	      return 1;
	    }
	    return calcBezier(getTForX(x), mY1, mY2);
	  };
	}

	// Remove Diacritics
	var defaultDiacriticsRemovalap = [
	  { base: 'A', letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F' },
	  { base: 'AA', letters: '\uA732' },
	  { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
	  { base: 'AO', letters: '\uA734' },
	  { base: 'AU', letters: '\uA736' },
	  { base: 'AV', letters: '\uA738\uA73A' },
	  { base: 'AY', letters: '\uA73C' },
	  { base: 'B', letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181' },
	  { base: 'C', letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E' },
	  { base: 'D', letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779' },
	  { base: 'DZ', letters: '\u01F1\u01C4' },
	  { base: 'Dz', letters: '\u01F2\u01C5' },
	  { base: 'E', letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E' },
	  { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
	  { base: 'G', letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E' },
	  { base: 'H', letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D' },
	  { base: 'I', letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197' },
	  { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
	  { base: 'K', letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2' },
	  { base: 'L', letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780' },
	  { base: 'LJ', letters: '\u01C7' },
	  { base: 'Lj', letters: '\u01C8' },
	  { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
	  { base: 'N', letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4' },
	  { base: 'NJ', letters: '\u01CA' },
	  { base: 'Nj', letters: '\u01CB' },
	  { base: 'O', letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C' },
	  { base: 'OI', letters: '\u01A2' },
	  { base: 'OO', letters: '\uA74E' },
	  { base: 'OU', letters: '\u0222' },
	  { base: 'OE', letters: '\u008C\u0152' },
	  { base: 'oe', letters: '\u009C\u0153' },
	  { base: 'P', letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754' },
	  { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
	  { base: 'R', letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782' },
	  { base: 'S', letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784' },
	  { base: 'T', letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786' },
	  { base: 'TZ', letters: '\uA728' },
	  { base: 'U', letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244' },
	  { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
	  { base: 'VY', letters: '\uA760' },
	  { base: 'W', letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72' },
	  { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
	  { base: 'Y', letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE' },
	  { base: 'Z', letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762' },
	  { base: 'a', letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250' },
	  { base: 'aa', letters: '\uA733' },
	  { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
	  { base: 'ao', letters: '\uA735' },
	  { base: 'au', letters: '\uA737' },
	  { base: 'av', letters: '\uA739\uA73B' },
	  { base: 'ay', letters: '\uA73D' },
	  { base: 'b', letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253' },
	  { base: 'c', letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184' },
	  { base: 'd', letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A' },
	  { base: 'dz', letters: '\u01F3\u01C6' },
	  { base: 'e', letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD' },
	  { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
	  { base: 'g', letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F' },
	  { base: 'h', letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265' },
	  { base: 'hv', letters: '\u0195' },
	  { base: 'i', letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131' },
	  { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
	  { base: 'k', letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3' },
	  { base: 'l', letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747' },
	  { base: 'lj', letters: '\u01C9' },
	  { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
	  { base: 'n', letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5' },
	  { base: 'nj', letters: '\u01CC' },
	  { base: 'o', letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275' },
	  { base: 'oi', letters: '\u01A3' },
	  { base: 'ou', letters: '\u0223' },
	  { base: 'oo', letters: '\uA74F' },
	  { base: 'p', letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755' },
	  { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
	  { base: 'r', letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783' },
	  { base: 's', letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B' },
	  { base: 't', letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787' },
	  { base: 'tz', letters: '\uA729' },
	  { base: 'u', letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289' },
	  { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
	  { base: 'vy', letters: '\uA761' },
	  { base: 'w', letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73' },
	  { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
	  { base: 'y', letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF' },
	  { base: 'z', letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763' } ];

	var diacriticsMap = {};
	for (var i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
	  var letters = defaultDiacriticsRemovalap[i].letters;
	  for (var j = 0; j < letters.length; j += 1) {
	    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
	  }
	}

	var createPromise = function createPromise(handler) {
	  var resolved = false;
	  var rejected = false;
	  var resolveArgs;
	  var rejectArgs;
	  var promiseHandlers = {
	    then: undefined,
	    catch: undefined,
	  };
	  var promise = {
	    then: function then(thenHandler) {
	      if (resolved) {
	        thenHandler.apply(void 0, resolveArgs);
	      } else {
	        promiseHandlers.then = thenHandler;
	      }
	      return promise;
	    },
	    catch: function catch$1(catchHandler) {
	      if (rejected) {
	        catchHandler.apply(void 0, rejectArgs);
	      } else {
	        promiseHandlers.catch = catchHandler;
	      }
	      return promise;
	    },
	  };

	  function resolve() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    resolved = true;
	    if (promiseHandlers.then) { promiseHandlers.then.apply(promiseHandlers, args); }
	    else { resolveArgs = args; }
	  }
	  function reject() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    rejected = true;
	    if (promiseHandlers.catch) { promiseHandlers.catch.apply(promiseHandlers, args); }
	    else { rejectArgs = args; }
	  }
	  handler(resolve, reject);

	  return promise;
	};

	var Utils = {
	  mdPreloaderContent: "\n    <span class=\"preloader-inner\">\n      <span class=\"preloader-inner-gap\"></span>\n      <span class=\"preloader-inner-left\">\n          <span class=\"preloader-inner-half-circle\"></span>\n      </span>\n      <span class=\"preloader-inner-right\">\n          <span class=\"preloader-inner-half-circle\"></span>\n      </span>\n    </span>\n  ".trim(),
	  eventNameToColonCase: function eventNameToColonCase(eventName) {
	    var hasColon;
	    return eventName.split('').map(function (char, index) {
	      if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
	        hasColon = true;
	        return (":" + (char.toLowerCase()));
	      }
	      return char.toLowerCase();
	    }).join('');
	  },
	  deleteProps: function deleteProps(obj) {
	    var object = obj;
	    Object.keys(object).forEach(function (key) {
	      try {
	        object[key] = null;
	      } catch (e) {
	        // no getter for object
	      }
	      try {
	        delete object[key];
	      } catch (e) {
	        // something got wrong
	      }
	    });
	  },
	  bezier: function bezier$1() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    return bezier.apply(void 0, args);
	  },
	  nextTick: function nextTick(callback, delay) {
	    if ( delay === void 0 ) delay = 0;

	    return setTimeout(callback, delay);
	  },
	  nextFrame: function nextFrame(callback) {
	    return Utils.requestAnimationFrame(callback);
	  },
	  now: function now() {
	    return Date.now();
	  },
	  promise: function promise(handler) {
	    return window.Promise ? new Promise(handler) : createPromise(handler);
	  },
	  requestAnimationFrame: function requestAnimationFrame(callback) {
	    if (window.requestAnimationFrame) { return window.requestAnimationFrame(callback); }
	    else if (window.webkitRequestAnimationFrame) { return window.webkitRequestAnimationFrame(callback); }
	    return window.setTimeout(callback, 1000 / 60);
	  },
	  cancelAnimationFrame: function cancelAnimationFrame(id) {
	    if (window.cancelAnimationFrame) { return window.cancelAnimationFrame(id); }
	    else if (window.webkitCancelAnimationFrame) { return window.webkitCancelAnimationFrame(id); }
	    return window.clearTimeout(id);
	  },
	  removeDiacritics: function removeDiacritics(str) {
	    return str.replace(/[^\u0000-\u007E]/g, function (a) { return diacriticsMap[a] || a; });
	  },
	  parseUrlQuery: function parseUrlQuery(url) {
	    var query = {};
	    var urlToParse = url || window.location.href;
	    var i;
	    var params;
	    var param;
	    var length;
	    if (typeof urlToParse === 'string' && urlToParse.length) {
	      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
	      params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });
	      length = params.length;

	      for (i = 0; i < length; i += 1) {
	        param = params[i].replace(/#\S+/g, '').split('=');
	        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
	      }
	    }
	    return query;
	  },
	  getTranslate: function getTranslate(el, axis) {
	    if ( axis === void 0 ) axis = 'x';

	    var matrix;
	    var curTransform;
	    var transformMatrix;

	    var curStyle = window.getComputedStyle(el, null);

	    if (window.WebKitCSSMatrix) {
	      curTransform = curStyle.transform || curStyle.webkitTransform;
	      if (curTransform.split(',').length > 6) {
	        curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');
	      }
	      // Some old versions of Webkit choke when 'none' is passed; pass
	      // empty string instead in this case
	      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
	    } else {
	      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	      matrix = transformMatrix.toString().split(',');
	    }

	    if (axis === 'x') {
	      // Latest Chrome and webkits Fix
	      if (window.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }
	      // Normal Browsers
	      else { curTransform = parseFloat(matrix[4]); }
	    }
	    if (axis === 'y') {
	      // Latest Chrome and webkits Fix
	      if (window.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }
	      // Crazy IE10 Matrix
	      else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }
	      // Normal Browsers
	      else { curTransform = parseFloat(matrix[5]); }
	    }
	    return curTransform || 0;
	  },
	  serializeObject: function serializeObject(obj, parents) {
	    if ( parents === void 0 ) parents = [];

	    if (typeof obj === 'string') { return obj; }
	    var resultArray = [];
	    var separator = '&';
	    var newParents;
	    function varName(name) {
	      if (parents.length > 0) {
	        var parentParts = '';
	        for (var j = 0; j < parents.length; j += 1) {
	          if (j === 0) { parentParts += parents[j]; }
	          else { parentParts += "[" + (encodeURIComponent(parents[j])) + "]"; }
	        }
	        return (parentParts + "[" + (encodeURIComponent(name)) + "]");
	      }
	      return encodeURIComponent(name);
	    }
	    function varValue(value) {
	      return encodeURIComponent(value);
	    }
	    Object.keys(obj).forEach(function (prop) {
	      var toPush;
	      if (Array.isArray(obj[prop])) {
	        toPush = [];
	        for (var i = 0; i < obj[prop].length; i += 1) {
	          if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
	            newParents = parents.slice();
	            newParents.push(prop);
	            newParents.push(String(i));
	            toPush.push(Utils.serializeObject(obj[prop][i], newParents));
	          } else {
	            toPush.push(((varName(prop)) + "[]=" + (varValue(obj[prop][i]))));
	          }
	        }
	        if (toPush.length > 0) { resultArray.push(toPush.join(separator)); }
	      } else if (obj[prop] === null || obj[prop] === '') {
	        resultArray.push(((varName(prop)) + "="));
	      } else if (typeof obj[prop] === 'object') {
	        // Object, convert to named array
	        newParents = parents.slice();
	        newParents.push(prop);
	        toPush = Utils.serializeObject(obj[prop], newParents);
	        if (toPush !== '') { resultArray.push(toPush); }
	      } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
	        // Should be string or plain value
	        resultArray.push(((varName(prop)) + "=" + (varValue(obj[prop]))));
	      } else if (obj[prop] === '') { resultArray.push(varName(prop)); }
	    });
	    return resultArray.join(separator);
	  },
	  isObject: function isObject(o) {
	    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
	  },
	  extend: function extend() {
	    var args = [], len$1 = arguments.length;
	    while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];

	    var deep = true;
	    var to;
	    var from;
	    if (typeof args[0] === 'boolean') {
	      deep = args[0];
	      to = args[1];
	      args.splice(0, 2);
	      from = args;
	    } else {
	      to = args[0];
	      args.splice(0, 1);
	      from = args;
	    }
	    for (var i = 0; i < from.length; i += 1) {
	      var nextSource = args[i];
	      if (nextSource !== undefined && nextSource !== null) {
	        var keysArray = Object.keys(Object(nextSource));
	        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
	          var nextKey = keysArray[nextIndex];
	          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	          if (desc !== undefined && desc.enumerable) {
	            if (!deep) {
	              to[nextKey] = nextSource[nextKey];
	            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
	              to[nextKey] = {};
	              Utils.extend(to[nextKey], nextSource[nextKey]);
	            } else {
	              to[nextKey] = nextSource[nextKey];
	            }
	          }
	        }
	      }
	    }
	    return to;
	  },
	};

	var Device = (function Device() {
	  var ua = window.navigator.userAgent;

	  var device = {
	    ios: false,
	    android: false,
	    androidChrome: false,
	    desktop: false,
	    windows: false,
	    iphone: false,
	    iphoneX: false,
	    ipod: false,
	    ipad: false,
	    cordova: window.cordova || window.phonegap,
	    phonegap: window.cordova || window.phonegap,
	  };

	  var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
	  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
	  var iphoneX = iphone && window.screen.width === 375 && window.screen.height === 812;


	  // Windows
	  if (windows) {
	    device.os = 'windows';
	    device.osVersion = windows[2];
	    device.windows = true;
	  }
	  // Android
	  if (android && !windows) {
	    device.os = 'android';
	    device.osVersion = android[2];
	    device.android = true;
	    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
	  }
	  if (ipad || iphone || ipod) {
	    device.os = 'ios';
	    device.ios = true;
	  }
	  // iOS
	  if (iphone && !ipod) {
	    device.osVersion = iphone[2].replace(/_/g, '.');
	    device.iphone = true;
	    device.iphoneX = iphoneX;
	  }
	  if (ipad) {
	    device.osVersion = ipad[2].replace(/_/g, '.');
	    device.ipad = true;
	  }
	  if (ipod) {
	    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	    device.iphone = true;
	  }
	  // iOS 8+ changed UA
	  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
	    if (device.osVersion.split('.')[0] === '10') {
	      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
	    }
	  }

	  // Webview
	  device.webView = (iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window.navigator.standalone);
	  device.webview = device.webView;


	  // Desktop
	  device.desktop = !(device.os || device.android || device.webView);

	  // Minimal UI
	  if (device.os && device.os === 'ios') {
	    var osVersionArr = device.osVersion.split('.');
	    var metaViewport = document.querySelector('meta[name="viewport"]');
	    device.minimalUi =
	      !device.webView &&
	      (ipod || iphone) &&
	      (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) &&
	      metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
	  }

	  // Check for status bar and fullscreen app mode
	  device.needsStatusbarOverlay = function needsStatusbarOverlay() {
	    if (device.webView && (window.innerWidth * window.innerHeight === window.screen.width * window.screen.height)) {
	      if (device.iphoneX && (window.orientation === 90 || window.orientation === -90)) {
	        return false;
	      }
	      return true;
	    }
	    return false;
	  };
	  device.statusbar = device.needsStatusbarOverlay();

	  // Pixel Ratio
	  device.pixelRatio = window.devicePixelRatio || 1;

	  // Export object
	  return device;
	}());

	var Framework7Class = function Framework7Class(params, parents) {
	  if ( params === void 0 ) params = {};
	  if ( parents === void 0 ) parents = [];

	  var self = this;
	  self.params = params;

	  // Events
	  self.eventsParents = parents;
	  self.eventsListeners = {};

	  if (self.params && self.params.on) {
	    Object.keys(self.params.on).forEach(function (eventName) {
	      self.on(eventName, self.params.on[eventName]);
	    });
	  }
	};

	var staticAccessors$1 = { components: { configurable: true } };
	Framework7Class.prototype.on = function on (events, handler) {
	  var self = this;
	  if (typeof handler !== 'function') { return self; }
	  events.split(' ').forEach(function (event) {
	    if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }
	    self.eventsListeners[event].push(handler);
	  });
	  return self;
	};
	Framework7Class.prototype.once = function once (events, handler) {
	  var self = this;
	  if (typeof handler !== 'function') { return self; }
	  function onceHandler() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	    handler.apply(self, args);
	    self.off(events, onceHandler);
	  }
	  return self.on(events, onceHandler);
	};
	Framework7Class.prototype.off = function off (events, handler) {
	  var self = this;
	  if (!self.eventsListeners) { return self; }
	  events.split(' ').forEach(function (event) {
	    if (typeof handler === 'undefined') {
	      self.eventsListeners[event] = [];
	    } else {
	      self.eventsListeners[event].forEach(function (eventHandler, index) {
	        if (eventHandler === handler) {
	          self.eventsListeners[event].splice(index, 1);
	        }
	      });
	    }
	  });
	  return self;
	};
	Framework7Class.prototype.emit = function emit () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	  var self = this;
	  if (!self.eventsListeners) { return self; }
	  var events;
	  var data;
	  var context;
	  var eventsParents;
	  if (typeof args[0] === 'string' || Array.isArray(args[0])) {
	    events = args[0];
	    data = args.slice(1, args.length);
	    context = self;
	    eventsParents = self.eventsParents;
	  } else {
	    events = args[0].events;
	    data = args[0].data;
	    context = args[0].context || self;
	    eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
	  }
	  var eventsArray = Array.isArray(events) ? events : events.split(' ');
	  var localEvents = eventsArray.map(function (eventName) { return eventName.replace('local::', ''); });
	  var parentEvents = eventsArray.filter(function (eventName) { return eventName.indexOf('local::') < 0; });

	  localEvents.forEach(function (event) {
	    if (self.eventsListeners && self.eventsListeners[event]) {
	      var handlers = [];
	      self.eventsListeners[event].forEach(function (eventHandler) {
	        handlers.push(eventHandler);
	      });
	      handlers.forEach(function (eventHandler) {
	        eventHandler.apply(context, data);
	      });
	    }
	  });
	  if (eventsParents && eventsParents.length > 0) {
	    eventsParents.forEach(function (eventsParent) {
	      eventsParent.emit.apply(eventsParent, [ parentEvents ].concat( data ));
	    });
	  }
	  return self;
	};
	Framework7Class.prototype.useModulesParams = function useModulesParams (instanceParams) {
	  var instance = this;
	  if (!instance.modules) { return; }
	  Object.keys(instance.modules).forEach(function (moduleName) {
	    var module = instance.modules[moduleName];
	    // Extend params
	    if (module.params) {
	      Utils.extend(instanceParams, module.params);
	    }
	  });
	};
	Framework7Class.prototype.useModules = function useModules (modulesParams) {
	    if ( modulesParams === void 0 ) modulesParams = {};

	  var instance = this;
	  if (!instance.modules) { return; }
	  Object.keys(instance.modules).forEach(function (moduleName) {
	    var module = instance.modules[moduleName];
	    var moduleParams = modulesParams[moduleName] || {};
	    // Extend instance methods and props
	    if (module.instance) {
	      Object.keys(module.instance).forEach(function (modulePropName) {
	        var moduleProp = module.instance[modulePropName];
	        if (typeof moduleProp === 'function') {
	          instance[modulePropName] = moduleProp.bind(instance);
	        } else {
	          instance[modulePropName] = moduleProp;
	        }
	      });
	    }
	    // Add event listeners
	    if (module.on && instance.on) {
	      Object.keys(module.on).forEach(function (moduleEventName) {
	        instance.on(moduleEventName, module.on[moduleEventName]);
	      });
	    }

	    // Module create callback
	    if (module.create) {
	      module.create.bind(instance)(moduleParams);
	    }
	  });
	};
	staticAccessors$1.components.set = function (components) {
	  var Class = this;
	  if (!Class.use) { return; }
	  Class.use(components);
	};
	Framework7Class.installModule = function installModule (module) {
	    var params = [], len = arguments.length - 1;
	    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

	  var Class = this;
	  if (!Class.prototype.modules) { Class.prototype.modules = {}; }
	  var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));
	  Class.prototype.modules[name] = module;
	  // Prototype
	  if (module.proto) {
	    Object.keys(module.proto).forEach(function (key) {
	      Class.prototype[key] = module.proto[key];
	    });
	  }
	  // Class
	  if (module.static) {
	    Object.keys(module.static).forEach(function (key) {
	      Class[key] = module.static[key];
	    });
	  }
	  // Callback
	  if (module.install) {
	    module.install.apply(Class, params);
	  }
	  return Class;
	};
	Framework7Class.use = function use (module) {
	    var params = [], len = arguments.length - 1;
	    while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];

	  var Class = this;
	  if (Array.isArray(module)) {
	    module.forEach(function (m) { return Class.installModule(m); });
	    return Class;
	  }
	  return Class.installModule.apply(Class, [ module ].concat( params ));
	};

	Object.defineProperties( Framework7Class, staticAccessors$1 );

	var Framework7$1 = (function (Framework7Class$$1) {
	  function Framework7(params) {
	    Framework7Class$$1.call(this, params);

	    var passedParams = Utils.extend({}, params);

	    // App Instance
	    var app = this;

	    // Default
	    var defaults = {
	      version: '1.0.0',
	      id: 'io.framework7.testapp',
	      root: 'body',
	      theme: 'auto',
	      language: window.navigator.language,
	      routes: [],
	      name: 'Framework7',
	      initOnDeviceReady: true,
	      init: true,
	    };

	    // Extend defaults with modules params
	    app.useModulesParams(defaults);


	    // Extend defaults with passed params
	    app.params = Utils.extend(defaults, params);

	    var $rootEl = $$1$1(app.params.root);

	    Utils.extend(app, {
	      // App Id
	      id: app.params.id,
	      // App Name
	      name: app.params.name,
	      // App version
	      version: app.params.version,
	      // Routes
	      routes: app.params.routes,
	      // Lang
	      language: app.params.language,
	      // Root
	      root: $rootEl,
	      // Local Storage
	      ls: window.localStorage,
	      // RTL
	      rtl: $rootEl.css('direction') === 'rtl',
	      // Theme
	      theme: (function getTheme() {
	        if (app.params.theme === 'auto') {
	          return Device.ios ? 'ios' : 'md';
	        }
	        return app.params.theme;
	      }()),
	      // Initially passed parameters
	      passedParams: passedParams,
	    });

	    // Save Root
	    app.root[0].f7 = app;

	    // Install Modules
	    app.useModules();

	    // Init
	    if (app.params.init) {
	      if (Device.cordova && app.params.initOnDeviceReady) {
	        $$1$1(document).on('deviceready', function () {
	          app.init();
	        });
	      } else {
	        app.init();
	      }
	    }

	    // Return app instance
	    return app;
	  }

	  if ( Framework7Class$$1 ) Framework7.__proto__ = Framework7Class$$1;
	  Framework7.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Framework7.prototype.constructor = Framework7;

	  var prototypeAccessors = { $: { configurable: true },t7: { configurable: true } };
	  var staticAccessors = { Dom7: { configurable: true },$: { configurable: true },Template7: { configurable: true },Class: { configurable: true } };
	  Framework7.prototype.init = function init () {
	    var app = this;
	    if (app.initialized) { return; }

	    app.root.addClass('framework7-initializing');

	    // RTL attr
	    if (app.rtl) {
	      $$1$1('html').attr('dir', 'rtl');
	    }

	    // Root class
	    app.root.addClass('framework7-root');

	    // Theme class
	    $$1$1('html').removeClass('ios md').addClass(app.theme);

	    // Data
	    app.data = {};
	    if (app.params.data && typeof app.params.data === 'function') {
	      Utils.extend(app.data, app.params.data.bind(app)());
	    } else if (app.params.data) {
	      Utils.extend(app.data, app.params.data);
	    }
	    // Methods
	    app.methods = {};
	    if (app.params.methods) {
	      Utils.extend(app.methods, app.params.methods);
	    }
	    // Init class
	    Utils.nextFrame(function () {
	      app.root.removeClass('framework7-initializing');
	    });
	    // Emit, init other modules
	    app.initialized = true;
	    app.emit('init');
	  };
	  // eslint-disable-next-line
	  prototypeAccessors.$.get = function () {
	    return $$1$1;
	  };
	  // eslint-disable-next-line
	  prototypeAccessors.t7.get = function () {
	    return Template7;
	  };
	  staticAccessors.Dom7.get = function () {
	    return $$1$1;
	  };
	  staticAccessors.$.get = function () {
	    return $$1$1;
	  };
	  staticAccessors.Template7.get = function () {
	    return Template7;
	  };
	  staticAccessors.Class.get = function () {
	    return Framework7Class$$1;
	  };

	  Object.defineProperties( Framework7.prototype, prototypeAccessors );
	  Object.defineProperties( Framework7, staticAccessors );

	  return Framework7;
	}(Framework7Class));

	var DeviceModule = {
	  name: 'device',
	  proto: {
	    device: Device,
	  },
	  static: {
	    device: Device,
	  },
	  on: {
	    init: function init() {
	      var classNames = [];
	      var html = document.querySelector('html');
	      // Pixel Ratio
	      classNames.push(("device-pixel-ratio-" + (Math.floor(Device.pixelRatio))));
	      if (Device.pixelRatio >= 2) {
	        classNames.push('device-retina');
	      }
	      // OS classes
	      if (Device.os) {
	        classNames.push(
	          ("device-" + (Device.os)),
	          ("device-" + (Device.os) + "-" + (Device.osVersion.split('.')[0])),
	          ("device-" + (Device.os) + "-" + (Device.osVersion.replace(/\./g, '-')))
	        );
	        if (Device.os === 'ios') {
	          var major = parseInt(Device.osVersion.split('.')[0], 10);
	          for (var i = major - 1; i >= 6; i -= 1) {
	            classNames.push(("device-ios-gt-" + i));
	          }
	          if (Device.iphoneX) {
	            classNames.push('device-iphone-x');
	          }
	        }
	      } else if (Device.desktop) {
	        classNames.push('device-desktop');
	      }
	      // Status bar classes
	      if (Device.statusbar) {
	        classNames.push('with-statusbar');
	      } else {
	        html.classList.remove('with-statusbar');
	      }

	      // Add html classes
	      classNames.forEach(function (className) {
	        html.classList.add(className);
	      });
	    },
	  },
	};

	var Support = (function Support() {
	  var positionSticky = (function supportPositionSticky() {
	    var support = false;
	    var div = document.createElement('div');
	    ('sticky -webkit-sticky -moz-sticky').split(' ').forEach(function (prop) {
	      if (support) { return; }
	      div.style.position = prop;
	      if (div.style.position === prop) {
	        support = true;
	      }
	    });
	    return support;
	  }());

	  return {
	    positionSticky: positionSticky,
	    touch: (function checkTouch() {
	      return !!(('ontouchstart' in window) || (window.DocumentTouch && document instanceof window.DocumentTouch));
	    }()),

	    transforms3d: (function checkTransforms3d() {
	      var div = document.createElement('div').style;
	      return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
	    }()),

	    flexbox: (function checkFlexbox() {
	      var div = document.createElement('div').style;
	      var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
	      for (var i = 0; i < styles.length; i += 1) {
	        if (styles[i] in div) { return true; }
	      }
	      return false;
	    }()),

	    observer: (function checkObserver() {
	      return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
	    }()),

	    passiveListener: (function checkPassiveListener() {
	      var supportsPassive = false;
	      try {
	        var opts = Object.defineProperty({}, 'passive', {
	          // eslint-disable-next-line
	          get: function get() {
	            supportsPassive = true;
	          },
	        });
	        window.addEventListener('testPassiveListener', null, opts);
	      } catch (e) {
	        // No support
	      }
	      return supportsPassive;
	    }()),

	    gestures: (function checkGestures() {
	      return 'ongesturestart' in window;
	    }()),
	  };
	}());

	var SupportModule = {
	  name: 'support',
	  proto: {
	    support: Support,
	  },
	  static: {
	    support: Support,
	  },
	  on: {
	    init: function init() {
	      var html = document.querySelector('html');
	      var classNames = [];
	      if (Support.positionSticky) {
	        classNames.push('support-position-sticky');
	      }
	      // Add html classes
	      classNames.forEach(function (className) {
	        html.classList.add(className);
	      });
	    },
	  },
	};

	var UtilsModule = {
	  name: 'utils',
	  proto: {
	    utils: Utils,
	  },
	  static: {
	    utils: Utils,
	  },
	};

	var ResizeModule = {
	  name: 'resize',
	  instance: {
	    getSize: function getSize() {
	      var app = this;
	      var offset = app.root.offset();
	      var ref = [app.root[0].offsetWidth, app.root[0].offsetHeight, offset.left, offset.top];
	      var width = ref[0];
	      var height = ref[1];
	      var left = ref[2];
	      var top = ref[3];
	      app.width = width;
	      app.height = height;
	      app.left = left;
	      app.top = top;
	      return { width: width, height: height, left: left, top: top };
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;

	      // Get Size
	      app.getSize();

	      // Emit resize
	      window.addEventListener('resize', function () {
	        app.emit('resize');
	      }, false);

	      // Emit orientationchange
	      window.addEventListener('orientationchange', function () {
	        app.emit('orientationchange');
	      });
	    },
	    orientationchange: function orientationchange() {
	      var app = this;
	      if (app.device && app.device.minimalUi) {
	        if (window.orientation === 90 || window.orientation === -90) {
	          document.body.scrollTop = 0;
	        }
	      }
	      // Fix iPad weird body scroll
	      if (app.device.ipad) {
	        document.body.scrollLeft = 0;
	        setTimeout(function () {
	          document.body.scrollLeft = 0;
	        }, 0);
	      }
	    },
	    resize: function resize() {
	      var app = this;
	      app.getSize();
	    },
	  },
	};

	var globals = {};
	var jsonpRequests = 0;

	function Request(requestOptions) {
	  var globalsNoCallbacks = Utils.extend({}, globals);
	  ('beforeCreate beforeOpen beforeSend error complete success statusCode').split(' ').forEach(function (callbackName) {
	    delete globalsNoCallbacks[callbackName];
	  });
	  var defaults = Utils.extend({
	    url: window.location.toString(),
	    method: 'GET',
	    data: false,
	    async: true,
	    cache: true,
	    user: '',
	    password: '',
	    headers: {},
	    xhrFields: {},
	    statusCode: {},
	    processData: true,
	    dataType: 'text',
	    contentType: 'application/x-www-form-urlencoded',
	    timeout: 0,
	  }, globalsNoCallbacks);

	  var options = Utils.extend({}, defaults, requestOptions);

	  // Function to run XHR callbacks and events
	  function fireCallback(callbackName) {
	    var data = [], len = arguments.length - 1;
	    while ( len-- > 0 ) data[ len ] = arguments[ len + 1 ];

	    /*
	      Callbacks:
	      beforeCreate (options),
	      beforeOpen (xhr, options),
	      beforeSend (xhr, options),
	      error (xhr, status),
	      complete (xhr, stautus),
	      success (response, status, xhr),
	      statusCode ()
	    */
	    if (globals[callbackName]) { globals[callbackName].apply(globals, data); }
	    if (options[callbackName]) { options[callbackName].apply(options, data); }
	  }

	  // Before create callback
	  fireCallback('beforeCreate', options);

	  // For jQuery guys
	  if (options.type) { options.method = options.type; }

	  // Parameters Prefix
	  var paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?';

	  // UC method
	  var method = options.method.toUpperCase();

	  // Data to modify GET URL
	  if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
	    var stringData;
	    if (typeof options.data === 'string') {
	      // Should be key=value string
	      if (options.data.indexOf('?') >= 0) { stringData = options.data.split('?')[1]; }
	      else { stringData = options.data; }
	    } else {
	      // Should be key=value object
	      stringData = Utils.serializeObject(options.data);
	    }
	    if (stringData.length) {
	      options.url += paramsPrefix + stringData;
	      if (paramsPrefix === '?') { paramsPrefix = '&'; }
	    }
	  }

	  // JSONP
	  if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
	    var callbackName = "f7jsonp_" + (Date.now() + ((jsonpRequests += 1)));
	    var abortTimeout;
	    var callbackSplit = options.url.split('callback=');
	    var requestUrl = (callbackSplit[0]) + "callback=" + callbackName;
	    if (callbackSplit[1].indexOf('&') >= 0) {
	      var addVars = callbackSplit[1].split('&').filter(function (el) { return el.indexOf('=') > 0; }).join('&');
	      if (addVars.length > 0) { requestUrl += "&" + addVars; }
	    }

	    // Create script
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.onerror = function onerror() {
	      clearTimeout(abortTimeout);
	      fireCallback('error', null, 'scripterror');
	      fireCallback('complete', null, 'scripterror');
	    };
	    script.src = requestUrl;

	    // Handler
	    window[callbackName] = function jsonpCallback(data) {
	      clearTimeout(abortTimeout);
	      fireCallback('success', data);
	      script.parentNode.removeChild(script);
	      script = null;
	      delete window[callbackName];
	    };
	    document.querySelector('head').appendChild(script);

	    if (options.timeout > 0) {
	      abortTimeout = setTimeout(function () {
	        script.parentNode.removeChild(script);
	        script = null;
	        fireCallback('error', null, 'timeout');
	      }, options.timeout);
	    }

	    return undefined;
	  }

	  // Cache for GET/HEAD requests
	  if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
	    if (options.cache === false) {
	      options.url += paramsPrefix + "_nocache" + (Date.now());
	    }
	  }

	  // Create XHR
	  var xhr = new XMLHttpRequest();

	  // Save Request URL
	  xhr.requestUrl = options.url;
	  xhr.requestParameters = options;

	  // Before open callback
	  fireCallback('beforeOpen', xhr, options);

	  // Open XHR
	  xhr.open(method, options.url, options.async, options.user, options.password);

	  // Create POST Data
	  var postData = null;

	  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
	    if (options.processData) {
	      var postDataInstances = [ArrayBuffer, Blob, Document, FormData];
	      // Post Data
	      if (postDataInstances.indexOf(options.data.constructor) >= 0) {
	        postData = options.data;
	      } else {
	        // POST Headers
	        var boundary = "---------------------------" + (Date.now().toString(16));

	        if (options.contentType === 'multipart/form-data') {
	          xhr.setRequestHeader('Content-Type', ("multipart/form-data; boundary=" + boundary));
	        } else {
	          xhr.setRequestHeader('Content-Type', options.contentType);
	        }
	        postData = '';
	        var data$1 = Utils.serializeObject(options.data);
	        if (options.contentType === 'multipart/form-data') {
	          data$1 = data$1.split('&');
	          var newData = [];
	          for (var i = 0; i < data$1.length; i += 1) {
	            newData.push(("Content-Disposition: form-data; name=\"" + (data$1[i].split('=')[0]) + "\"\r\n\r\n" + (data$1[i].split('=')[1]) + "\r\n"));
	          }
	          postData = "--" + boundary + "\r\n" + (newData.join(("--" + boundary + "\r\n"))) + "--" + boundary + "--\r\n";
	        } else {
	          postData = data$1;
	        }
	      }
	    } else {
	      postData = options.data;
	      xhr.setRequestHeader('Content-Type', options.contentType);
	    }
	  }

	  // Additional headers
	  if (options.headers) {
	    Object.keys(options.headers).forEach(function (headerName) {
	      xhr.setRequestHeader(headerName, options.headers[headerName]);
	    });
	  }

	  // Check for crossDomain
	  if (typeof options.crossDomain === 'undefined') {
	    // eslint-disable-next-line
	    options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== window.location.host;
	  }

	  if (!options.crossDomain) {
	    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	  }

	  if (options.xhrFields) {
	    Utils.extend(xhr, options.xhrFields);
	  }

	  var xhrTimeout;

	  // Handle XHR
	  xhr.onload = function onload() {
	    if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
	      var responseData;
	      if (options.dataType === 'json') {
	        try {
	          responseData = JSON.parse(xhr.responseText);
	          fireCallback('success', responseData, xhr.status, xhr);
	        } catch (err) {
	          fireCallback('error', xhr, 'parseerror');
	        }
	      } else {
	        responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
	        fireCallback('success', responseData, xhr.status, xhr);
	      }
	    } else {
	      fireCallback('error', xhr, xhr.status);
	    }
	    if (options.statusCode) {
	      if (globals.statusCode && globals.statusCode[xhr.status]) { globals.statusCode[xhr.status](xhr); }
	      if (options.statusCode[xhr.status]) { options.statusCode[xhr.status](xhr); }
	    }
	    fireCallback('complete', xhr, xhr.status);
	  };

	  xhr.onerror = function onerror() {
	    if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    fireCallback('error', xhr, xhr.status);
	    fireCallback('complete', xhr, 'error');
	  };

	  // Timeout
	  if (options.timeout > 0) {
	    xhr.onabort = function onabort() {
	      if (xhrTimeout) { clearTimeout(xhrTimeout); }
	    };
	    xhrTimeout = setTimeout(function () {
	      xhr.abort();
	      fireCallback('error', xhr, 'timeout');
	      fireCallback('complete', xhr, 'timeout');
	    }, options.timeout);
	  }

	  // Ajax start callback
	  fireCallback('beforeSend', xhr, options);

	  // Send XHR
	  xhr.send(postData);

	  // Return XHR object
	  return xhr;
	}
	function RequestShortcut(method) {
	  var args = [], len = arguments.length - 1;
	  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	  var ref = [];
	  var url = ref[0];
	  var data = ref[1];
	  var success = ref[2];
	  var error = ref[3];
	  var dataType = ref[4];
	  if (typeof args[1] === 'function') {
	    var assign;
	    (assign = args, url = assign[0], success = assign[1], error = assign[2], dataType = assign[3]);
	  } else {
	    var assign$1;
	    (assign$1 = args, url = assign$1[0], data = assign$1[1], success = assign$1[2], error = assign$1[3], dataType = assign$1[4]);
	  }
	  [success, error].forEach(function (callback) {
	    if (typeof callback === 'string') {
	      dataType = callback;
	      if (callback === success) { success = undefined; }
	      else { error = undefined; }
	    }
	  });
	  dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
	  var requestOptions = {
	    url: url,
	    method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
	    data: data,
	    success: success,
	    error: error,
	    dataType: dataType,
	  };
	  if (method === 'postJSON') {
	    Utils.extend(requestOptions, {
	      contentType: 'application/json',
	      processData: false,
	      crossDomain: true,
	      data: typeof data === 'string' ? data : JSON.stringify(data),
	    });
	  }
	  return Request(requestOptions);
	}
	Request.get = function get() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return RequestShortcut.apply(void 0, [ 'get' ].concat( args ));
	};
	Request.post = function post() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return RequestShortcut.apply(void 0, [ 'post' ].concat( args ));
	};
	Request.json = function json() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return RequestShortcut.apply(void 0, [ 'json' ].concat( args ));
	};
	Request.getJSON = Request.json;
	Request.postJSON = function postJSON() {
	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];

	  return RequestShortcut.apply(void 0, [ 'postJSON' ].concat( args ));
	};
	Request.setup = function setup(options) {
	  if (options.type && !options.method) {
	    Utils.extend(options, { method: options.type });
	  }
	  Utils.extend(globals, options);
	};

	/* eslint no-param-reassign: "off" */
	var RequestModule = {
	  name: 'request',
	  proto: {
	    request: Request,
	  },
	  static: {
	    request: Request,
	  },
	};

	function initTouch() {
	  var app = this;
	  var params = app.params.touch;
	  var useRipple = app.theme === 'md' && params.materialRipple;

	  if (Device.ios && Device.webView) {
	    // Strange hack required for iOS 8 webview to work on inputs
	    window.addEventListener('touchstart', function () {});
	  }

	  var touchStartX;
	  var touchStartY;
	  var touchStartTime;
	  var targetElement;
	  var trackClick;
	  var activeSelection;
	  var scrollParent;
	  var lastClickTime;
	  var isMoved;
	  var tapHoldFired;
	  var tapHoldTimeout;

	  var activableElement;
	  var activeTimeout;

	  var needsFastClick;
	  var needsFastClickTimeOut;

	  var rippleWave;
	  var rippleTarget;
	  var rippleTimeout;

	  function findActivableElement(el) {
	    var target = $$1$1(el);
	    var parents = target.parents(params.activeStateElements);
	    var activable;
	    if (target.is(params.activeStateElements)) {
	      activable = target;
	    }
	    if (parents.length > 0) {
	      activable = activable ? activable.add(parents) : parents;
	    }
	    return activable || target;
	  }

	  function isInsideScrollableView(el) {
	    var pageContent = el.parents('.page-content, .panel');

	    if (pageContent.length === 0) {
	      return false;
	    }

	    // This event handler covers the "tap to stop scrolling".
	    if (pageContent.prop('scrollHandlerSet') !== 'yes') {
	      pageContent.on('scroll', function () {
	        clearTimeout(activeTimeout);
	        clearTimeout(rippleTimeout);
	      });
	      pageContent.prop('scrollHandlerSet', 'yes');
	    }

	    return true;
	  }
	  function addActive() {
	    if (!activableElement) { return; }
	    activableElement.addClass('active-state');
	  }
	  function removeActive() {
	    if (!activableElement) { return; }
	    activableElement.removeClass('active-state');
	    activableElement = null;
	  }
	  function isFormElement(el) {
	    var nodes = ('input select textarea label').split(' ');
	    if (el.nodeName && nodes.indexOf(el.nodeName.toLowerCase()) >= 0) { return true; }
	    return false;
	  }
	  function androidNeedsBlur(el) {
	    var noBlur = ('button input textarea select').split(' ');
	    if (document.activeElement && el !== document.activeElement && document.activeElement !== document.body) {
	      if (noBlur.indexOf(el.nodeName.toLowerCase()) >= 0) {
	        return false;
	      }
	      return true;
	    }
	    return false;
	  }
	  function targetNeedsFastClick(el) {
	    /*
	    if (
	      Device.ios
	      &&
	      (
	        Device.osVersion.split('.')[0] > 9
	        ||
	        (Device.osVersion.split('.')[0] * 1 === 9 && Device.osVersion.split('.')[1] >= 1)
	      )
	    ) {
	      return false;
	    }
	    */
	    var $el = $$1$1(el);
	    if (el.nodeName.toLowerCase() === 'input' && (el.type === 'file' || el.type === 'range')) { return false; }
	    if (el.nodeName.toLowerCase() === 'select' && Device.android) { return false; }
	    if ($el.hasClass('no-fastclick') || $el.parents('.no-fastclick').length > 0) { return false; }
	    if (params.fastClicksExclude && $el.is(params.fastClicksExclude)) { return false; }
	    return true;
	  }
	  function targetNeedsFocus(el) {
	    if (document.activeElement === el) {
	      return false;
	    }
	    var tag = el.nodeName.toLowerCase();
	    var skipInputs = ('button checkbox file image radio submit').split(' ');
	    if (el.disabled || el.readOnly) { return false; }
	    if (tag === 'textarea') { return true; }
	    if (tag === 'select') {
	      if (Device.android) { return false; }
	      return true;
	    }
	    if (tag === 'input' && skipInputs.indexOf(el.type) < 0) { return true; }
	    return false;
	  }
	  function targetNeedsPrevent(el) {
	    var $el = $$1$1(el);
	    var prevent = true;
	    if ($el.is('label') || $el.parents('label').length > 0) {
	      if (Device.android) {
	        prevent = false;
	      } else if (Device.ios && $el.is('input')) {
	        prevent = true;
	      } else { prevent = false; }
	    }
	    return prevent;
	  }

	  // Ripple handlers
	  function findRippleElement(el) {
	    var rippleElements = params.materialRippleElements;
	    var $el = $$1$1(el);
	    if ($el.is(rippleElements)) {
	      if ($el.hasClass('no-ripple')) {
	        return false;
	      }
	      return $el;
	    } else if ($el.parents(rippleElements).length > 0) {
	      var rippleParent = $el.parents(rippleElements).eq(0);
	      if (rippleParent.hasClass('no-ripple')) {
	        return false;
	      }
	      return rippleParent;
	    }
	    return false;
	  }
	  function createRipple($el, x, y) {
	    if (!$el) { return; }
	    rippleWave = app.touchRipple.create($el, x, y);
	  }

	  function removeRipple() {
	    if (!rippleWave) { return; }
	    rippleWave.remove();
	    rippleWave = undefined;
	    rippleTarget = undefined;
	  }
	  function rippleTouchStart(el) {
	    rippleTarget = findRippleElement(el);
	    if (!rippleTarget || rippleTarget.length === 0) {
	      rippleTarget = undefined;
	      return;
	    }
	    if (!isInsideScrollableView(rippleTarget)) {
	      createRipple(rippleTarget, touchStartX, touchStartY);
	    } else {
	      rippleTimeout = setTimeout(function () {
	        createRipple(rippleTarget, touchStartX, touchStartY);
	      }, 80);
	    }
	  }
	  function rippleTouchMove() {
	    clearTimeout(rippleTimeout);
	    removeRipple();
	  }
	  function rippleTouchEnd() {
	    if (rippleWave) {
	      removeRipple();
	    } else if (rippleTarget && !isMoved) {
	      clearTimeout(rippleTimeout);
	      createRipple(rippleTarget, touchStartX, touchStartY);
	      setTimeout(removeRipple, 0);
	    } else {
	      removeRipple();
	    }
	  }

	  // Mouse Handlers
	  function handleMouseDown(e) {
	    findActivableElement(e.target).addClass('active-state');
	    if ('which' in e && e.which === 3) {
	      setTimeout(function () {
	        $$1$1('.active-state').removeClass('active-state');
	      }, 0);
	    }
	    if (useRipple) {
	      touchStartX = e.pageX;
	      touchStartY = e.pageY;
	      rippleTouchStart(e.target, e.pageX, e.pageY);
	    }
	  }
	  function handleMouseMove() {
	    $$1$1('.active-state').removeClass('active-state');
	    if (useRipple) {
	      rippleTouchMove();
	    }
	  }
	  function handleMouseUp() {
	    $$1$1('.active-state').removeClass('active-state');
	    if (useRipple) {
	      rippleTouchEnd();
	    }
	  }

	  // Send Click
	  function sendClick(e) {
	    var touch = e.changedTouches[0];
	    var evt = document.createEvent('MouseEvents');
	    var eventType = 'click';
	    if (Device.android && targetElement.nodeName.toLowerCase() === 'select') {
	      eventType = 'mousedown';
	    }
	    evt.initMouseEvent(eventType, true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
	    evt.forwardedTouchEvent = true;

	    if (app.device.ios && window.navigator.standalone) {
	      // Fix the issue happens in iOS home screen apps where the wrong element is selected during a momentum scroll.
	      // Upon tapping, we give the scrolling time to stop, then we grab the element based where the user tapped.
	      setTimeout(function () {
	        targetElement = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
	        targetElement.dispatchEvent(evt);
	      }, 10);
	    } else {
	      targetElement.dispatchEvent(evt);
	    }
	  }

	  // Touch Handlers
	  function handleTouchStart(e) {
	    var this$1 = this;

	    isMoved = false;
	    tapHoldFired = false;
	    if (e.targetTouches.length > 1) {
	      if (activableElement) { removeActive(); }
	      return true;
	    }
	    if (e.touches.length > 1 && activableElement) {
	      removeActive();
	    }
	    if (params.tapHold) {
	      if (tapHoldTimeout) { clearTimeout(tapHoldTimeout); }
	      tapHoldTimeout = setTimeout(function () {
	        if (e && e.touches && e.touches.length > 1) { return; }
	        tapHoldFired = true;
	        e.preventDefault();
	        $$1$1(e.target).trigger('taphold');
	      }, params.tapHoldDelay);
	    }
	    if (needsFastClickTimeOut) { clearTimeout(needsFastClickTimeOut); }
	    needsFastClick = targetNeedsFastClick(e.target);

	    if (!needsFastClick) {
	      trackClick = false;
	      return true;
	    }
	    if (Device.ios || (Device.android && 'getSelection' in window)) {
	      var selection = window.getSelection();
	      if (
	        selection.rangeCount &&
	        selection.focusNode !== document.body &&
	        (!selection.isCollapsed || document.activeElement === selection.focusNode)
	      ) {
	        activeSelection = true;
	        return true;
	      }

	      activeSelection = false;
	    }
	    if (Device.android) {
	      if (androidNeedsBlur(e.target)) {
	        document.activeElement.blur();
	      }
	    }

	    trackClick = true;
	    targetElement = e.target;
	    touchStartTime = (new Date()).getTime();
	    touchStartX = e.targetTouches[0].pageX;
	    touchStartY = e.targetTouches[0].pageY;

	    // Detect scroll parent
	    if (Device.ios) {
	      scrollParent = undefined;
	      $$1$1(targetElement).parents().each(function () {
	        var parent = this$1;
	        if (parent.scrollHeight > parent.offsetHeight && !scrollParent) {
	          scrollParent = parent;
	          scrollParent.f7ScrollTop = scrollParent.scrollTop;
	        }
	      });
	    }
	    if ((e.timeStamp - lastClickTime) < params.fastClicksDelayBetweenClicks) {
	      e.preventDefault();
	    }

	    if (params.activeState) {
	      activableElement = findActivableElement(targetElement);
	      // If it's inside a scrollable view, we don't trigger active-state yet,
	      // because it can be a scroll instead. Based on the link:
	      // http://labnote.beedesk.com/click-scroll-and-pseudo-active-on-mobile-webk
	      if (!isInsideScrollableView(activableElement)) {
	        addActive();
	      } else {
	        activeTimeout = setTimeout(addActive, 80);
	      }
	    }
	    if (useRipple) {
	      rippleTouchStart(targetElement, touchStartX, touchStartY);
	    }
	    return true;
	  }
	  function handleTouchMove(e) {
	    if (!trackClick) { return; }
	    var distance = params.fastClicksDistanceThreshold;
	    if (distance) {
	      var pageX = e.targetTouches[0].pageX;
	      var pageY = e.targetTouches[0].pageY;
	      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
	        isMoved = true;
	      }
	    } else {
	      isMoved = true;
	    }
	    if (isMoved) {
	      trackClick = false;
	      targetElement = null;
	      isMoved = true;
	      if (params.tapHold) {
	        clearTimeout(tapHoldTimeout);
	      }
	      if (params.activeState) {
	        clearTimeout(activeTimeout);
	        removeActive();
	      }
	      if (useRipple) {
	        rippleTouchMove();
	      }
	    }
	  }
	  function handleTouchEnd(e) {
	    clearTimeout(activeTimeout);
	    clearTimeout(tapHoldTimeout);

	    if (!trackClick) {
	      if (!activeSelection && needsFastClick) {
	        if (!(Device.android && !e.cancelable) && e.cancelable) {
	          e.preventDefault();
	        }
	      }
	      return true;
	    }

	    if (document.activeElement === e.target) {
	      if (params.activeState) { removeActive(); }
	      if (useRipple) {
	        rippleTouchEnd();
	      }
	      return true;
	    }

	    if (!activeSelection) {
	      e.preventDefault();
	    }

	    if ((e.timeStamp - lastClickTime) < params.fastClicksDelayBetweenClicks) {
	      setTimeout(removeActive, 0);
	      return true;
	    }

	    lastClickTime = e.timeStamp;

	    trackClick = false;

	    if (Device.ios && scrollParent) {
	      if (scrollParent.scrollTop !== scrollParent.f7ScrollTop) {
	        return false;
	      }
	    }

	    // Add active-state here because, in a very fast tap, the timeout didn't
	    // have the chance to execute. Removing active-state in a timeout gives
	    // the chance to the animation execute.
	    if (params.activeState) {
	      addActive();
	      setTimeout(removeActive, 0);
	    }
	    // Remove Ripple
	    if (useRipple) {
	      rippleTouchEnd();
	    }

	    // Trigger focus when required
	    if (targetNeedsFocus(targetElement)) {
	      if (Device.ios && Device.webView) {
	        if ((e.timeStamp - touchStartTime) > 159) {
	          targetElement = null;
	          return false;
	        }
	        targetElement.focus();
	        return false;
	      }

	      targetElement.focus();
	    }

	    // Blur active elements
	    if (document.activeElement && targetElement !== document.activeElement && document.activeElement !== document.body && targetElement.nodeName.toLowerCase() !== 'label') {
	      document.activeElement.blur();
	    }

	    // Send click
	    e.preventDefault();
	    sendClick(e);
	    return false;
	  }
	  function handleTouchCancel() {
	    trackClick = false;
	    targetElement = null;

	    // Remove Active State
	    clearTimeout(activeTimeout);
	    clearTimeout(tapHoldTimeout);
	    if (params.activeState) {
	      removeActive();
	    }

	    // Remove Ripple
	    if (useRipple) {
	      rippleTouchEnd();
	    }
	  }

	  function handleClick(e) {
	    var allowClick = false;

	    if (trackClick) {
	      targetElement = null;
	      trackClick = false;
	      return true;
	    }
	    if ((e.target.type === 'submit' && e.detail === 0) || e.target.type === 'file') {
	      return true;
	    }
	    if (!targetElement) {
	      if (!isFormElement(e.target)) {
	        allowClick = true;
	      }
	    }
	    if (!needsFastClick) {
	      allowClick = true;
	    }
	    if (document.activeElement === targetElement) {
	      allowClick = true;
	    }
	    if (e.forwardedTouchEvent) {
	      allowClick = true;
	    }
	    if (!e.cancelable) {
	      allowClick = true;
	    }
	    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
	      allowClick = false;
	    }
	    if (!allowClick) {
	      e.stopImmediatePropagation();
	      e.stopPropagation();
	      if (targetElement) {
	        if (targetNeedsPrevent(targetElement) || isMoved) {
	          e.preventDefault();
	        }
	      } else {
	        e.preventDefault();
	      }
	      targetElement = null;
	    }
	    needsFastClickTimeOut = setTimeout(function () {
	      needsFastClick = false;
	    }, (Device.ios || Device.androidChrome ? 100 : 400));

	    if (params.tapHold) {
	      tapHoldTimeout = setTimeout(function () {
	        tapHoldFired = false;
	      }, (Device.ios || Device.androidChrome ? 100 : 400));
	    }

	    return allowClick;
	  }

	  function emitAppTouchEvent(name, e) {
	    app.emit({
	      events: name,
	      data: [e],
	    });
	  }
	  function appClick(e) {
	    emitAppTouchEvent('click', e);
	  }
	  function appTouchStartActive(e) {
	    emitAppTouchEvent('touchstart touchstart:active', e);
	  }
	  function appTouchMoveActive(e) {
	    emitAppTouchEvent('touchmove touchmove:active', e);
	  }
	  function appTouchEndActive(e) {
	    emitAppTouchEvent('touchend touchend:active', e);
	  }
	  function appTouchStartPassive(e) {
	    emitAppTouchEvent('touchstart:passive', e);
	  }
	  function appTouchMovePassive(e) {
	    emitAppTouchEvent('touchmove:passive', e);
	  }
	  function appTouchEndPassive(e) {
	    emitAppTouchEvent('touchend:passive', e);
	  }

	  var passiveListener = Support.passiveListener ? { passive: true } : false;
	  var activeListener = Support.passiveListener ? { passive: false } : false;

	  document.addEventListener('click', appClick, true);

	  if (Support.passiveListener) {
	    document.addEventListener(app.touchEvents.start, appTouchStartActive, activeListener);
	    document.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
	    document.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);

	    document.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListener);
	    document.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
	    document.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
	  } else {
	    document.addEventListener(app.touchEvents.start, function (e) {
	      appTouchStartActive(e);
	      appTouchStartPassive(e);
	    }, false);
	    document.addEventListener(app.touchEvents.move, function (e) {
	      appTouchMoveActive(e);
	      appTouchMovePassive(e);
	    }, false);
	    document.addEventListener(app.touchEvents.end, function (e) {
	      appTouchEndActive(e);
	      appTouchEndPassive(e);
	    }, false);
	  }

	  if (Support.touch) {
	    app.on('click', handleClick);
	    app.on('touchstart', handleTouchStart);
	    app.on('touchmove', handleTouchMove);
	    app.on('touchend', handleTouchEnd);
	    document.addEventListener('touchcancel', handleTouchCancel, { passive: true });
	  } else if (params.activeState) {
	    app.on('touchstart', handleMouseDown);
	    app.on('touchmove', handleMouseMove);
	    app.on('touchend', handleMouseUp);
	  }
	  document.addEventListener('contextmenu', function (e) {
	    if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {
	      e.preventDefault();
	    }
	    if (useRipple) {
	      if (activableElement) { removeActive(); }
	      rippleTouchEnd();
	    }
	  });
	}

	var TouchModule = {
	  name: 'touch',
	  params: {
	    touch: {
	      // Fast clicks
	      fastClicks: true,
	      fastClicksDistanceThreshold: 10,
	      fastClicksDelayBetweenClicks: 50,
	      fastClicksExclude: '', // CSS selector
	      // ContextMenu
	      disableContextMenu: true,
	      // Tap Hold
	      tapHold: false,
	      tapHoldDelay: 750,
	      tapHoldPreventClicks: true,
	      // Active State
	      activeState: true,
	      activeStateElements: 'a, button, label, span, .actions-button',
	      materialRipple: true,
	      materialRippleElements: '.ripple, .link, .item-link, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell, .notification-close-button',
	    },
	  },
	  instance: {
	    touchEvents: {
	      start: Support.touch ? 'touchstart' : 'mousedown',
	      move: Support.touch ? 'touchmove' : 'mousemove',
	      end: Support.touch ? 'touchend' : 'mouseup',
	    },
	  },
	  on: {
	    init: initTouch,
	  },
	};

	/**
	 * Expose `pathToRegexp`.
	 */
	var pathToRegexp_1 = pathToRegexp;
	var parse_1 = parse;
	var compile_1 = compile;
	var tokensToFunction_1 = tokensToFunction;
	var tokensToRegExp_1 = tokensToRegExp;

	/**
	 * Default configs.
	 */
	var DEFAULT_DELIMITER = '/';
	var DEFAULT_DELIMITERS = './';

	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined]
	  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
	].join('|'), 'g');

	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
	function parse (str, options) {
	  var tokens = [];
	  var key = 0;
	  var index = 0;
	  var path = '';
	  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
	  var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;
	  var pathEscaped = false;
	  var res;

	  while ((res = PATH_REGEXP.exec(str)) !== null) {
	    var m = res[0];
	    var escaped = res[1];
	    var offset = res.index;
	    path += str.slice(index, offset);
	    index = offset + m.length;

	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1];
	      pathEscaped = true;
	      continue
	    }

	    var prev = '';
	    var next = str[index];
	    var name = res[2];
	    var capture = res[3];
	    var group = res[4];
	    var modifier = res[5];

	    if (!pathEscaped && path.length) {
	      var k = path.length - 1;

	      if (delimiters.indexOf(path[k]) > -1) {
	        prev = path[k];
	        path = path.slice(0, k);
	      }
	    }

	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path);
	      path = '';
	      pathEscaped = false;
	    }

	    var partial = prev !== '' && next !== undefined && next !== prev;
	    var repeat = modifier === '+' || modifier === '*';
	    var optional = modifier === '?' || modifier === '*';
	    var delimiter = prev || defaultDelimiter;
	    var pattern = capture || group;

	    tokens.push({
	      name: name || key++,
	      prefix: prev,
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      partial: partial,
	      pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'
	    });
	  }

	  // Push any remaining characters.
	  if (path || index < str.length) {
	    tokens.push(path + str.substr(index));
	  }

	  return tokens
	}

	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
	function compile (str, options) {
	  return tokensToFunction(parse(str, options))
	}

	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length);

	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
	    }
	  }

	  return function (data, options) {
	    var path = '';
	    var encode = (options && options.encode) || encodeURIComponent;

	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i];

	      if (typeof token === 'string') {
	        path += token;
	        continue
	      }

	      var value = data ? data[token.name] : undefined;
	      var segment;

	      if (Array.isArray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
	        }

	        if (value.length === 0) {
	          if (token.optional) { continue }

	          throw new TypeError('Expected "' + token.name + '" to not be empty')
	        }

	        for (var j = 0; j < value.length; j++) {
	          segment = encode(value[j]);

	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
	          }

	          path += (j === 0 ? token.prefix : token.delimiter) + segment;
	        }

	        continue
	      }

	      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
	        segment = encode(String(value));

	        if (!matches[i].test(segment)) {
	          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
	        }

	        path += token.prefix + segment;
	        continue
	      }

	      if (token.optional) {
	        // Prepend partial segment prefixes.
	        if (token.partial) { path += token.prefix; }

	        continue
	      }

	      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
	    }

	    return path
	  }
	}

	/**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
	}

	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$/()])/g, '\\$1')
	}

	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
	function flags (options) {
	  return options && options.sensitive ? '' : 'i'
	}

	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {Array=}  keys
	 * @return {!RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  if (!keys) { return path }

	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g);

	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        partial: false,
	        pattern: null
	      });
	    }
	  }

	  return path
	}

	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = [];

	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source);
	  }

	  return new RegExp('(?:' + parts.join('|') + ')', flags(options))
	}

	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  return tokensToRegExp(parse(path, options), keys, options)
	}

	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}  tokens
	 * @param  {Array=}  keys
	 * @param  {Object=} options
	 * @return {!RegExp}
	 */
	function tokensToRegExp (tokens, keys, options) {
	  options = options || {};

	  var strict = options.strict;
	  var end = options.end !== false;
	  var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);
	  var delimiters = options.delimiters || DEFAULT_DELIMITERS;
	  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
	  var route = '';
	  var isEndDelimited = false;

	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (typeof token === 'string') {
	      route += escapeString(token);
	      isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;
	    } else {
	      var prefix = escapeString(token.prefix);
	      var capture = token.repeat
	        ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'
	        : token.pattern;

	      if (keys) { keys.push(token); }

	      if (token.optional) {
	        if (token.partial) {
	          route += prefix + '(' + capture + ')?';
	        } else {
	          route += '(?:' + prefix + '(' + capture + '))?';
	        }
	      } else {
	        route += prefix + '(' + capture + ')';
	      }
	    }
	  }

	  if (end) {
	    if (!strict) { route += '(?:' + delimiter + ')?'; }

	    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
	  } else {
	    if (!strict) { route += '(?:' + delimiter + '(?=' + endsWith + '))?'; }
	    if (!isEndDelimited) { route += '(?=' + delimiter + '|' + endsWith + ')'; }
	  }

	  return new RegExp('^' + route, flags(options))
	}

	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {Array=}                keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, keys)
	  }

	  if (Array.isArray(path)) {
	    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
	  }

	  return stringToRegexp(/** @type {string} */ (path), keys, options)
	}

	pathToRegexp_1.parse = parse_1;
	pathToRegexp_1.compile = compile_1;
	pathToRegexp_1.tokensToFunction = tokensToFunction_1;
	pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

	var tempDom = document.createElement('div');

	var Framework7Component = function Framework7Component(opts, extendContext) {
	  if ( extendContext === void 0 ) extendContext = {};

	  var context = Utils.extend({}, extendContext);
	  var component = Utils.extend(this, context, { $options: opts });
	  var options = component.$options;

	  // Apply context
	  ('beforeCreate created beforeMount mounted beforeDestroy destroyed').split(' ').forEach(function (cycleKey) {
	    if (options[cycleKey]) { options[cycleKey] = options[cycleKey].bind(component); }
	  });

	  if (options.data) {
	    options.data = options.data.bind(component);
	    // Data
	    Utils.extend(component, options.data());
	  }
	  if (options.render) { options.render = options.render.bind(component); }
	  if (options.methods) {
	    Object.keys(options.methods).forEach(function (methodName) {
	      component[methodName] = options.methods[methodName].bind(component);
	    });
	  }

	  // Bind Events
	  if (options.on) {
	    Object.keys(options.on).forEach(function (eventName) {
	      options.on[eventName] = options.on[eventName].bind(component);
	    });
	  }
	  if (options.once) {
	    Object.keys(options.once).forEach(function (eventName) {
	      options.once[eventName] = options.once[eventName].bind(component);
	    });
	  }

	  if (options.beforeCreate) { options.beforeCreate(); }

	  // Watchers
	  if (options.watch) {
	    Object.keys(options.watch).forEach(function (watchKey) {
	      var dataKeyValue = component[watchKey];
	      Object.defineProperty(component, watchKey, {
	        enumerable: true,
	        configurable: true,
	        set: function set(newValue) {
	          var previousValue = dataKeyValue;
	          dataKeyValue = newValue;
	          if (previousValue === newValue) { return; }
	          options.watch[watchKey].call(component, newValue, previousValue);
	        },
	        get: function get() {
	          return dataKeyValue;
	        },
	      });
	    });
	  }

	  // Render template

	  function render() {
	    var html = '';
	    if (options.render) {
	      html = options.render();
	    } else if (options.template) {
	      if (typeof options.template === 'string') {
	        try {
	          html = Template7.compile(options.template)(component);
	        } catch (err) {
	          throw err;
	        }
	      } else {
	        // Supposed to be function
	        html = options.template(component);
	      }
	    }
	    return html;
	  }

	  var html = render();

	  // Make Dom
	  if (html && typeof html === 'string') {
	    html = html.trim();
	    tempDom.innerHTML = html;
	  } else if (html) {
	    tempDom.innerHTML = '';
	    tempDom.appendChild(html);
	  }

	  // Extend component with $el
	  var el = tempDom.children[0];
	  var $el = $$1$1(el);
	  component.$el = $el;
	  component.el = el;
	  component.el = el;

	  // Find Events
	  var events = [];
	  $$1$1(tempDom).find('*').each(function (index, element) {
	    var attrs = [];
	    for (var i = 0; i < element.attributes.length; i += 1) {
	      var attr = element.attributes[i];
	      if (attr.name.indexOf('@') === 0) {
	        attrs.push({
	          name: attr.name,
	          value: attr.value,
	        });
	      }
	    }
	    attrs.forEach(function (attr) {
	      element.removeAttribute(attr.name);
	      var event = attr.name.replace('@', '');
	      var name = event;
	      var stop = false;
	      var prevent = false;
	      var once = false;
	      if (event.indexOf('.') >= 0) {
	        event.split('.').forEach(function (eventNamePart, eventNameIndex) {
	          if (eventNameIndex === 0) { name = eventNamePart; }
	          else {
	            if (eventNamePart === 'stop') { stop = true; }
	            if (eventNamePart === 'prevent') { prevent = true; }
	            if (eventNamePart === 'once') { once = true; }
	          }
	        });
	      }
	      var value = attr.value.toString();
	      events.push({
	        el: element,
	        name: name,
	        once: once,
	        handler: function handler() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var e = args[0];
	          if (stop) { e.stopPropagation(); }
	          if (prevent) { e.preventDefault(); }
	          var methodName;
	          var method;
	          var customArgs = [];
	          if (value.indexOf('(') < 0) {
	            customArgs = args;
	            methodName = value;
	          } else {
	            methodName = value.split('(')[0];
	            value.split('(')[1].split(')')[0].split(',').forEach(function (argument) {
	              var arg = argument.trim();
	              // eslint-disable-next-line
	              if (!isNaN(arg)) { arg = parseFloat(arg); }
	              else if (arg === 'true') { arg = true; }
	              else if (arg === 'false') { arg = false; }
	              else if (arg === 'null') { arg = null; }
	              else if (arg === 'undefined') { arg = undefined; }
	              else if (arg[0] === '"') { arg = arg.replace(/"/g, ''); }
	              else if (arg[0] === '\'') { arg = arg.replace(/'/g, ''); }
	              else if (arg.indexOf('.') > 0) {
	                var deepArg;
	                arg.split('.').forEach(function (path) {
	                  if (!deepArg) { deepArg = component; }
	                  deepArg = deepArg[path];
	                });
	                arg = deepArg;
	              } else {
	                arg = component[arg];
	              }
	              customArgs.push(arg);
	            });
	          }
	          if (methodName.indexOf('.') >= 0) {
	            methodName.split('.').forEach(function (path, pathIndex) {
	              if (!method) { method = component; }
	              if (method[path]) { method = method[path]; }
	              else {
	                throw new Error(("Component doesn't have method \"" + (methodName.split('.').slice(0, pathIndex + 1).join('.')) + "\""));
	              }
	            });
	          } else {
	            if (!component[methodName]) {
	              throw new Error(("Component doesn't have method \"" + methodName + "\""));
	            }
	            method = component[methodName];
	          }
	          method.apply(void 0, customArgs);
	        },
	      });
	    });
	  });

	  // Set styles scope ID
	  var styleEl;
	  if (options.style) {
	    styleEl = document.createElement('style');
	    styleEl.innerHTML = options.style;
	  }
	  if (options.styleScopeId) {
	    el.setAttribute('data-scope', options.styleScopeId);
	  }

	  // Attach events
	  function attachEvents() {
	    if (options.on) {
	      Object.keys(options.on).forEach(function (eventName) {
	        $el.on(Utils.eventNameToColonCase(eventName), options.on[eventName]);
	      });
	    }
	    if (options.once) {
	      Object.keys(options.once).forEach(function (eventName) {
	        $el.once(Utils.eventNameToColonCase(eventName), options.once[eventName]);
	      });
	    }
	    events.forEach(function (event) {
	      $$1$1(event.el)[event.once ? 'once' : 'on'](event.name, event.handler);
	    });
	  }

	  function detachEvents() {
	    if (options.on) {
	      Object.keys(options.on).forEach(function (eventName) {
	        $el.off(Utils.eventNameToColonCase(eventName), options.on[eventName]);
	      });
	    }
	    if (options.once) {
	      Object.keys(options.once).forEach(function (eventName) {
	        $el.off(Utils.eventNameToColonCase(eventName), options.once[eventName]);
	      });
	    }
	    events.forEach(function (event) {
	      $$1$1(event.el).off(event.name, event.handler);
	    });
	  }

	  attachEvents();

	  // Created callback
	  if (options.created) { options.created(); }

	  // Mount
	  component.$mount = function mount(mountMethod) {
	    if (options.beforeMount) { options.beforeMount(); }
	    if (styleEl) { $$1$1('head').append(styleEl); }
	    if (mountMethod) { mountMethod(el); }
	    if (options.mounted) { options.mounted(); }
	  };

	  // Destroy
	  component.$destroy = function destroy() {
	    if (options.beforeDestroy) { options.beforeDestroy(); }
	    if (styleEl) { $$1$1(styleEl).remove(); }
	    detachEvents();
	    if (options.destroyed) { options.destroyed(); }
	    // Delete component instance
	    if (el && el.f7Component) {
	      el.f7Component = null;
	      delete el.f7Component;
	    }
	    Utils.deleteProps(component);
	    component = null;
	  };

	  // Store component instance
	  for (var i = 0; i < tempDom.children.length; i += 1) {
	    tempDom.children[i].f7Component = component;
	  }

	  return component;
	};


	var Component = {
	  parse: function parse(componentString) {
	    var callbackName = "f7_component_callback_" + (new Date().getTime());

	    // Template
	    var template;
	    if (componentString.indexOf('<template>') >= 0) {
	      template = componentString
	        .split('<template>')
	        .filter(function (item, index) { return index > 0; })
	        .join('<template>')
	        .split('</template>')
	        .filter(function (item, index, arr) { return index < arr.length - 1; })
	        .join('</template>')
	        .replace(/{{#raw}}([ \n]*)<template/g, '{{#raw}}<template')
	        .replace(/\/template>([ \n]*){{\/raw}}/g, '/template>{{/raw}}')
	        .replace(/([ \n])<template/g, '$1{{#raw}}<template')
	        .replace(/\/template>([ \n])/g, '/template>{{/raw}}$1');
	    }

	    // Styles
	    var style;
	    var styleScopeId = Utils.now();
	    if (componentString.indexOf('<style>') >= 0) {
	      style = componentString.split('<style>')[1].split('</style>')[0];
	    } else if (componentString.indexOf('<style scoped>') >= 0) {
	      style = componentString.split('<style scoped>')[1].split('</style>')[0];
	      style = style.split('\n').map(function (line) {
	        if (line.indexOf('{') >= 0) {
	          if (line.indexOf('{{this}}') >= 0) {
	            return line.replace('{{this}}', ("[data-scope=\"" + styleScopeId + "\"]"));
	          }
	          return ("[data-scope=\"" + styleScopeId + "\"] " + (line.trim()));
	        }
	        return line;
	      }).join('\n');
	    }

	    var scriptContent;
	    if (componentString.indexOf('<script>') >= 0) {
	      var scripts = componentString.split('<script>');
	      scriptContent = scripts[scripts.length - 1].split('</script>')[0].trim();
	    } else {
	      scriptContent = 'return {}';
	    }
	    scriptContent = "window." + callbackName + " = function () {" + scriptContent + "}";

	    // Insert Script El
	    var scriptEl = document.createElement('script');
	    scriptEl.innerHTML = scriptContent;
	    $$1$1('head').append(scriptEl);

	    var component = window[callbackName]();

	    // Remove Script El
	    $$1$1(scriptEl).remove();

	    if (!component.template && !component.render) {
	      component.template = template;
	    }
	    if (style) {
	      component.style = style;
	      component.styleScopeId = styleScopeId;
	    }
	    return component;
	  },
	  create: function create(c, extendContext) {
	    if ( extendContext === void 0 ) extendContext = {};

	    return new Framework7Component(c, extendContext);
	  },
	};

	var History = {
	  queue: [],
	  clearQueue: function clearQueue() {
	    if (History.queue.length === 0) { return; }
	    var currentQueue = History.queue.shift();
	    currentQueue();
	  },
	  routerQueue: [],
	  clearRouterQueue: function clearRouterQueue() {
	    if (History.routerQueue.length === 0) { return; }
	    var currentQueue = History.routerQueue.pop();
	    var router = currentQueue.router;
	    var stateUrl = currentQueue.stateUrl;
	    var action = currentQueue.action;

	    var animate = router.params.animate;
	    if (router.params.pushStateAnimate === false) { animate = false; }

	    if (action === 'back') {
	      router.back({ animate: animate, pushState: false });
	    }
	    if (action === 'load') {
	      router.navigate(stateUrl, { animate: animate, pushState: false });
	    }
	  },
	  handle: function handle(e) {
	    if (History.blockPopstate) { return; }
	    var app = this;
	    // const mainView = app.views.main;
	    var state = e.state;
	    History.previousState = History.state;
	    History.state = state;

	    History.allowChange = true;
	    History.clearQueue();

	    state = History.state;
	    if (!state) { state = {}; }

	    app.views.forEach(function (view) {
	      var router = view.router;
	      var viewState = state[view.id];
	      if (!viewState && view.params.pushState) {
	        viewState = {
	          url: view.router.history[0],
	        };
	      }
	      if (!viewState) { return; }
	      var stateUrl = viewState.url || undefined;

	      var animate = router.params.animate;
	      if (router.params.pushStateAnimate === false) { animate = false; }

	      if (stateUrl !== router.url) {
	        if (router.history.indexOf(stateUrl) >= 0) {
	          // Go Back
	          if (router.allowPageChange) {
	            router.back({ animate: animate, pushState: false });
	          } else {
	            History.routerQueue.push({
	              action: 'back',
	              router: router,
	            });
	          }
	        } else if (router.allowPageChange) {
	          // Load page
	          router.navigate(stateUrl, { animate: animate, pushState: false });
	        } else {
	          History.routerQueue.unshift({
	            action: 'load',
	            stateUrl: stateUrl,
	            router: router,
	          });
	        }
	      }
	    });
	  },
	  push: function push(viewId, viewState, url) {
	    var obj;

	    if (!History.allowChange) {
	      History.queue.push(function () {
	        History.push(viewId, viewState, url);
	      });
	      return;
	    }
	    History.previousState = History.state;
	    var newState = Utils.extend({}, (History.previousState || {}), ( obj = {}, obj[viewId] = viewState, obj ));
	    History.state = newState;
	    window.history.pushState(newState, '', url);
	  },
	  replace: function replace(viewId, viewState, url) {
	    var obj;

	    if (!History.allowChange) {
	      History.queue.push(function () {
	        History.replace(viewId, viewState, url);
	      });
	      return;
	    }
	    History.previousState = History.state;
	    var newState = Utils.extend({}, (History.previousState || {}), ( obj = {}, obj[viewId] = viewState, obj ));
	    History.state = newState;
	    window.history.replaceState(newState, '', url);
	  },
	  go: function go(index) {
	    History.allowChange = false;
	    window.history.go(index);
	  },
	  back: function back() {
	    History.allowChange = false;
	    window.history.back();
	  },
	  allowChange: true,
	  previousState: {},
	  state: window.history.state,
	  blockPopstate: true,
	  init: function init(app) {
	    $$1$1(window).on('load', function () {
	      setTimeout(function () {
	        History.blockPopstate = false;
	      }, 0);
	    });

	    if (document.readyState && document.readyState === 'complete') {
	      History.blockPopstate = false;
	    }

	    $$1$1(window).on('popstate', History.handle.bind(app));
	  },
	};

	function SwipeBack(r) {
	  var router = r;
	  var $el = router.$el;
	  var $navbarEl = router.$navbarEl;
	  var app = router.app;
	  var isTouched = false;
	  var isMoved = false;
	  var touchesStart = {};
	  var isScrolling;
	  var currentPage = [];
	  var previousPage = [];
	  var viewContainerWidth;
	  var touchesDiff;
	  var allowViewTouchMove = true;
	  var touchStartTime;
	  var currentNavbar = [];
	  var previousNavbar = [];
	  var currentNavElements;
	  var previousNavElements;
	  var activeNavBackIcon;
	  var activeNavBackIconText;
	  var previousNavBackIcon;
	  // let previousNavBackIconText;
	  var dynamicNavbar;
	  var separateNavbar;
	  var pageShadow;
	  var pageOpacity;
	  var navbarWidth;

	  function handleTouchStart(e) {
	    if (!allowViewTouchMove || !router.params.iosSwipeBack || isTouched || (app.swipeout && app.swipeout.el) || !router.allowPageChange) { return; }
	    if ($$1$1(e.target).closest('.range-slider, .calendar-months').length > 0) { return; }
	    isMoved = false;
	    isTouched = true;
	    isScrolling = undefined;
	    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    touchStartTime = Utils.now();
	    dynamicNavbar = router.dynamicNavbar;
	    separateNavbar = router.separateNavbar;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (typeof isScrolling === 'undefined') {
	      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x;
	    }
	    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
	      isTouched = false;
	      return;
	    }
	    if (!isMoved) {
	      // Calc values during first move fired
	      var cancel = false;
	      var target = $$1$1(e.target);

	      var swipeout = target.closest('.swipeout');
	      if (swipeout.length > 0) {
	        if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) { cancel = true; }
	        if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) { cancel = true; }
	      }

	      currentPage = target.closest('.page');
	      if (currentPage.hasClass('no-swipeback') || target.closest('.no-swipeback').length > 0) { cancel = true; }
	      previousPage = $el.find('.page-previous:not(.stacked)');

	      var notFromBorder = touchesStart.x - $el.offset().left > router.params.iosSwipeBackActiveArea;
	      viewContainerWidth = $el.width();
	      if (app.rtl) {
	        notFromBorder = touchesStart.x < ($el.offset().left - $el[0].scrollLeft) + (viewContainerWidth - router.params.iosSwipeBackActiveArea);
	      } else {
	        notFromBorder = touchesStart.x - $el.offset().left > router.params.iosSwipeBackActiveArea;
	      }
	      if (notFromBorder) { cancel = true; }
	      if (previousPage.length === 0 || currentPage.length === 0) { cancel = true; }
	      if (cancel) {
	        isTouched = false;
	        return;
	      }

	      if (router.params.iosSwipeBackAnimateShadow) {
	        pageShadow = currentPage.find('.page-shadow-effect');
	        if (pageShadow.length === 0) {
	          pageShadow = $$1$1('<div class="page-shadow-effect"></div>');
	          currentPage.append(pageShadow);
	        }
	      }
	      if (router.params.iosSwipeBackAnimateOpacity) {
	        pageOpacity = previousPage.find('.page-opacity-effect');
	        if (pageOpacity.length === 0) {
	          pageOpacity = $$1$1('<div class="page-opacity-effect"></div>');
	          previousPage.append(pageOpacity);
	        }
	      }

	      if (dynamicNavbar) {
	        if (separateNavbar) {
	          currentNavbar = $navbarEl.find('.navbar-current:not(.stacked)');
	          previousNavbar = $navbarEl.find('.navbar-previous:not(.stacked)');
	        } else {
	          currentNavbar = currentPage.children('.navbar').children('.navbar-inner');
	          previousNavbar = previousPage.children('.navbar').children('.navbar-inner');
	        }
	        navbarWidth = $navbarEl[0].offsetWidth;
	        currentNavElements = currentNavbar.children('.left, .title, .right, .subnavbar, .fading');
	        previousNavElements = previousNavbar.children('.left, .title, .right, .subnavbar, .fading');
	        if (router.params.iosAnimateNavbarBackIcon) {
	          if (currentNavbar.hasClass('sliding')) {
	            activeNavBackIcon = currentNavbar.children('.left').find('.back .icon');
	            activeNavBackIconText = currentNavbar.children('.left').find('.back span').eq(0);
	          } else {
	            activeNavBackIcon = currentNavbar.children('.left.sliding').find('.back .icon');
	            activeNavBackIconText = currentNavbar.children('.left.sliding').find('.back span').eq(0);
	          }
	          if (previousNavbar.hasClass('sliding')) {
	            previousNavBackIcon = previousNavbar.children('.left').find('.back .icon');
	            // previousNavBackIconText = previousNavbar.children('left').find('.back span').eq(0);
	          } else {
	            previousNavBackIcon = previousNavbar.children('.left.sliding').find('.back .icon');
	            // previousNavBackIconText = previousNavbar.children('.left.sliding').find('.back span').eq(0);
	          }
	        }
	      }

	      // Close/Hide Any Picker
	      if ($$1$1('.sheet.modal-in').length > 0 && app.sheet) {
	        app.sheet.close($$1$1('.sheet.modal-in'));
	      }
	    }
	    e.f7PreventPanelSwipe = true;
	    isMoved = true;
	    app.preventSwipePanelBySwipeBack = true;
	    e.preventDefault();

	    // RTL inverter
	    var inverter = app.rtl ? -1 : 1;

	    // Touches diff
	    touchesDiff = (pageX - touchesStart.x - router.params.iosSwipeBackThreshold) * inverter;
	    if (touchesDiff < 0) { touchesDiff = 0; }
	    var percentage = touchesDiff / viewContainerWidth;

	    // Swipe Back Callback
	    var callbackData = {
	      percentage: percentage,
	      currentPageEl: currentPage[0],
	      previousPageEl: previousPage[0],
	      currentNavbarEl: currentNavbar[0],
	      previousNavbarEl: previousNavbar[0],
	    };
	    $el.trigger('swipeback:move', callbackData);
	    router.emit('swipebackMove', callbackData);

	    // Transform pages
	    var currentPageTranslate = touchesDiff * inverter;
	    var previousPageTranslate = ((touchesDiff / 5) - (viewContainerWidth / 5)) * inverter;
	    if (Device.pixelRatio === 1) {
	      currentPageTranslate = Math.round(currentPageTranslate);
	      previousPageTranslate = Math.round(previousPageTranslate);
	    }

	    currentPage.transform(("translate3d(" + currentPageTranslate + "px,0,0)"));
	    if (router.params.iosSwipeBackAnimateShadow) { pageShadow[0].style.opacity = 1 - (1 * percentage); }

	    previousPage.transform(("translate3d(" + previousPageTranslate + "px,0,0)"));
	    if (router.params.iosSwipeBackAnimateOpacity) { pageOpacity[0].style.opacity = 1 - (1 * percentage); }

	    // Dynamic Navbars Animation
	    if (dynamicNavbar) {
	      currentNavElements.each(function (index, navEl) {
	        var $navEl = $$1$1(navEl);
	        if (!$navEl.is('.subnavbar')) { $navEl[0].style.opacity = (1 - (Math.pow( percentage, 0.33 ))); }
	        if ($navEl[0].className.indexOf('sliding') >= 0 || currentNavbar.hasClass('sliding')) {
	          var activeNavTranslate = percentage * $navEl[0].f7NavbarRightOffset;
	          if (Device.pixelRatio === 1) { activeNavTranslate = Math.round(activeNavTranslate); }
	          $navEl.transform(("translate3d(" + activeNavTranslate + "px,0,0)"));
	          if (router.params.iosAnimateNavbarBackIcon) {
	            if ($navEl[0].className.indexOf('left') >= 0 && activeNavBackIcon.length > 0) {
	              var iconTranslate = -activeNavTranslate;
	              if (!separateNavbar) {
	                iconTranslate -= navbarWidth * percentage;
	              }
	              activeNavBackIcon.transform(("translate3d(" + iconTranslate + "px,0,0)"));
	            }
	          }
	        }
	      });
	      previousNavElements.each(function (index, navEl) {
	        var $navEl = $$1$1(navEl);
	        if (!$navEl.is('.subnavbar')) { $navEl[0].style.opacity = (Math.pow( percentage, 3 )); }
	        if ($navEl[0].className.indexOf('sliding') >= 0 || previousNavbar.hasClass('sliding')) {
	          var previousNavTranslate = $navEl[0].f7NavbarLeftOffset * (1 - percentage);
	          if ($navEl[0].className.indexOf('title') >= 0 && activeNavBackIcon && activeNavBackIcon.length && activeNavBackIconText.length) {
	            previousNavTranslate = ($navEl[0].f7NavbarLeftOffset + activeNavBackIconText[0].offsetLeft) * (1 - percentage);
	          } else {
	            previousNavTranslate = $navEl[0].f7NavbarLeftOffset * (1 - percentage);
	          }
	          if (Device.pixelRatio === 1) { previousNavTranslate = Math.round(previousNavTranslate); }
	          $navEl.transform(("translate3d(" + previousNavTranslate + "px,0,0)"));
	          if (router.params.iosAnimateNavbarBackIcon) {
	            if ($navEl[0].className.indexOf('left') >= 0 && previousNavBackIcon.length > 0) {
	              var iconTranslate = -previousNavTranslate;
	              if (!separateNavbar) {
	                iconTranslate += (navbarWidth / 5) * (1 - percentage);
	              }
	              previousNavBackIcon.transform(("translate3d(" + iconTranslate + "px,0,0)"));
	            }
	          }
	        }
	      });
	    }
	  }
	  function handleTouchEnd() {
	    app.preventSwipePanelBySwipeBack = false;
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    if (touchesDiff === 0) {
	      $$1$1([currentPage[0], previousPage[0]]).transform('');
	      if (dynamicNavbar) {
	        currentNavElements.transform('').css({ opacity: '' });
	        previousNavElements.transform('').css({ opacity: '' });
	        if (activeNavBackIcon && activeNavBackIcon.length > 0) { activeNavBackIcon.transform(''); }
	        if (previousNavBackIcon && activeNavBackIcon.length > 0) { previousNavBackIcon.transform(''); }
	      }
	      return;
	    }
	    var timeDiff = Utils.now() - touchStartTime;
	    var pageChanged = false;
	    // Swipe back to previous page
	    if (
	      (timeDiff < 300 && touchesDiff > 10) ||
	      (timeDiff >= 300 && touchesDiff > viewContainerWidth / 2)
	    ) {
	      currentPage.removeClass('page-current').addClass('page-next');
	      previousPage.removeClass('page-previous').addClass('page-current');
	      if (pageShadow) { pageShadow[0].style.opacity = ''; }
	      if (pageOpacity) { pageOpacity[0].style.opacity = ''; }
	      if (dynamicNavbar) {
	        currentNavbar.removeClass('navbar-current').addClass('navbar-next');
	        previousNavbar.removeClass('navbar-previous').addClass('navbar-current');
	      }
	      pageChanged = true;
	    }
	    // Reset custom styles
	    // Add transitioning class for transition-duration
	    $$1$1([currentPage[0], previousPage[0]]).addClass('page-transitioning').transform('');
	    if (dynamicNavbar) {
	      currentNavElements.css({ opacity: '' })
	        .each(function (navElIndex, navEl) {
	          var translate = pageChanged ? navEl.f7NavbarRightOffset : 0;
	          var sliding = $$1$1(navEl);
	          var iconTranslate = pageChanged ? -translate : 0;
	          if (!separateNavbar && pageChanged) { iconTranslate -= navbarWidth; }
	          sliding.transform(("translate3d(" + translate + "px,0,0)"));
	          if (router.params.iosAnimateNavbarBackIcon) {
	            if (sliding.hasClass('left') && activeNavBackIcon.length > 0) {
	              activeNavBackIcon.addClass('navbar-transitioning').transform(("translate3d(" + iconTranslate + "px,0,0)"));
	            }
	          }
	        }).addClass('navbar-transitioning');

	      previousNavElements.transform('').css({ opacity: '' }).each(function (navElIndex, navEl) {
	        var translate = pageChanged ? 0 : navEl.f7NavbarLeftOffset;
	        var sliding = $$1$1(navEl);
	        var iconTranslate = pageChanged ? 0 : -translate;
	        if (!separateNavbar && !pageChanged) { iconTranslate += navbarWidth / 5; }
	        sliding.transform(("translate3d(" + translate + "px,0,0)"));
	        if (router.params.iosAnimateNavbarBackIcon) {
	          if (sliding.hasClass('left') && previousNavBackIcon.length > 0) {
	            previousNavBackIcon.addClass('navbar-transitioning').transform(("translate3d(" + iconTranslate + "px,0,0)"));
	          }
	        }
	      }).addClass('navbar-transitioning');
	    }
	    allowViewTouchMove = false;
	    router.allowPageChange = false;

	    // Swipe Back Callback
	    var callbackData = {
	      currentPage: currentPage[0],
	      previousPage: previousPage[0],
	      currentNavbar: currentNavbar[0],
	      previousNavbar: previousNavbar[0],
	    };

	    if (pageChanged) {
	      // Update Route
	      router.currentRoute = previousPage[0].f7Page.route;
	      router.currentPage = previousPage[0];

	      // Page before animation callback
	      router.pageCallback('beforeOut', currentPage, currentNavbar, 'current', 'next', { route: currentPage[0].f7Page.route });
	      router.pageCallback('beforeIn', previousPage, previousNavbar, 'previous', 'current', { route: previousPage[0].f7Page.route });

	      $el.trigger('swipeback:beforechange', callbackData);
	      router.emit('swipebackBeforeChange', callbackData);
	    } else {
	      $el.trigger('swipeback:beforereset', callbackData);
	      router.emit('swipebackBeforeReset', callbackData);
	    }

	    currentPage.transitionEnd(function () {
	      $$1$1([currentPage[0], previousPage[0]]).removeClass('page-transitioning');
	      if (dynamicNavbar) {
	        currentNavElements.removeClass('navbar-transitioning').css({ opacity: '' }).transform('');
	        previousNavElements.removeClass('navbar-transitioning').css({ opacity: '' }).transform('');
	        if (activeNavBackIcon && activeNavBackIcon.length > 0) { activeNavBackIcon.removeClass('navbar-transitioning'); }
	        if (previousNavBackIcon && previousNavBackIcon.length > 0) { previousNavBackIcon.removeClass('navbar-transitioning'); }
	      }
	      allowViewTouchMove = true;
	      router.allowPageChange = true;
	      if (pageChanged) {
	        // Update History
	        if (router.history.length === 1) {
	          router.history.unshift(router.url);
	        }
	        router.history.pop();
	        router.saveHistory();

	        // Update push state
	        if (router.params.pushState) {
	          History.back();
	        }

	        // Page after animation callback
	        router.pageCallback('afterOut', currentPage, currentNavbar, 'current', 'next', { route: currentPage[0].f7Page.route });
	        router.pageCallback('afterIn', previousPage, previousNavbar, 'previous', 'current', { route: previousPage[0].f7Page.route });

	        // Remove Old Page
	        if (router.params.stackPages && router.initialPages.indexOf(currentPage[0]) >= 0) {
	          currentPage.addClass('stacked');
	          if (separateNavbar) {
	            currentNavbar.addClass('stacked');
	          }
	        } else {
	          router.pageCallback('beforeRemove', currentPage, currentNavbar, 'next');
	          router.removePage(currentPage);
	          if (separateNavbar) {
	            router.removeNavbar(currentNavbar);
	          }
	        }

	        $el.trigger('swipeback:afterchange', callbackData);
	        router.emit('swipebackAfterChange', callbackData);

	        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	        if (router.params.preloadPreviousPage) {
	          router.back(router.history[router.history.length - 2], { preload: true });
	        }
	      } else {
	        $el.trigger('swipeback:afterreset', callbackData);
	        router.emit('swipebackAfterReset', callbackData);
	      }
	      if (pageShadow && pageShadow.length > 0) { pageShadow.remove(); }
	      if (pageOpacity && pageOpacity.length > 0) { pageOpacity.remove(); }
	    });
	  }

	  function attachEvents() {
	    var passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
	    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  }
	  function detachEvents() {
	    var passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
	    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	  }

	  attachEvents();

	  router.on('routerDestroy', detachEvents);
	}

	var redirect = function (direction, route, options) {
	  var router = this;
	  var redirect = route.route.redirect;
	  function redirectResolve(redirectUrl, redirectOptions) {
	    if ( redirectOptions === void 0 ) redirectOptions = {};

	    router.allowPageChange = true;
	    router[direction](redirectUrl, Utils.extend({}, options, redirectOptions));
	  }
	  function redirectReject() {
	    router.allowPageChange = true;
	  }
	  if (typeof redirect === 'function') {
	    router.allowPageChange = false;
	    var redirectUrl = redirect.call(router, route, redirectResolve, redirectReject);
	    if (redirectUrl && typeof redirectUrl === 'string') {
	      router.allowPageChange = true;
	      return router[direction](redirectUrl, options);
	    }
	    return router;
	  }
	  return router[direction](redirect, options);
	};

	function refreshPage() {
	  var router = this;
	  return router.navigate(router.currentRoute.url, {
	    ignoreCache: true,
	    reloadCurrent: true,
	  });
	}

	function forward(el, forwardOptions) {
	  if ( forwardOptions === void 0 ) forwardOptions = {};

	  var router = this;
	  var app = router.app;
	  var view = router.view;

	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	    history: true,
	    reloadCurrent: router.params.reloadPages,
	    reloadPrevious: false,
	    reloadAll: false,
	    on: {},
	  }, forwardOptions);

	  var dynamicNavbar = router.dynamicNavbar;
	  var separateNavbar = router.separateNavbar;

	  var $viewEl = router.$el;
	  var $newPage = $$1$1(el);
	  var reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
	  var $oldPage;

	  var $navbarEl;
	  var $newNavbarInner;
	  var $oldNavbarInner;

	  if ($newPage.length) {
	    // Remove theme elements
	    router.removeThemeElements($newPage);
	  }

	  if (dynamicNavbar) {
	    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
	    if (separateNavbar) {
	      $navbarEl = router.$navbarEl;
	      if ($newNavbarInner.length > 0) {
	        $newPage.children('.navbar').remove();
	      }
	      if ($newNavbarInner.length === 0 && $newPage[0].f7Page) {
	        // Try from pageData
	        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
	      }
	    }
	  }

	  router.allowPageChange = false;
	  if ($newPage.length === 0) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // Pages In View
	  var $pagesInView = $viewEl
	    .children('.page:not(.stacked)')
	    .filter(function (index, pageInView) { return pageInView !== $newPage[0]; });

	  // Navbars In View
	  var $navbarsInView;
	  if (separateNavbar) {
	    $navbarsInView = $navbarEl
	      .children('.navbar-inner:not(.stacked)')
	      .filter(function (index, navbarInView) { return navbarInView !== $newNavbarInner[0]; });
	  }

	  // Exit when reload previous and only 1 page in view so nothing ro reload
	  if (options.reloadPrevious && $pagesInView.length < 2) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // New Page
	  var newPagePosition = 'next';
	  if (options.reloadCurrent || options.reloadAll) {
	    newPagePosition = 'current';
	  } else if (options.reloadPrevious) {
	    newPagePosition = 'previous';
	  }
	  $newPage
	    .addClass(("page-" + newPagePosition))
	    .removeClass('stacked');

	  if (dynamicNavbar && $newNavbarInner.length) {
	    $newNavbarInner
	      .addClass(("navbar-" + newPagePosition))
	      .removeClass('stacked');
	  }

	  // Find Old Page
	  if (options.reloadCurrent) {
	    $oldPage = $pagesInView.eq($pagesInView.length - 1);
	    if (separateNavbar) {
	      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 1);
	      $oldNavbarInner = $$1$1(app.navbar.getElByPage($oldPage));
	    }
	  } else if (options.reloadPrevious) {
	    $oldPage = $pagesInView.eq($pagesInView.length - 2);
	    if (separateNavbar) {
	      // $oldNavbarInner = $navbarsInView.eq($pagesInView.length - 2);
	      $oldNavbarInner = $$1$1(app.navbar.getElByPage($oldPage));
	    }
	  } else if (options.reloadAll) {
	    $oldPage = $pagesInView.filter(function (index, pageEl) { return pageEl !== $newPage[0]; });
	    if (separateNavbar) {
	      $oldNavbarInner = $navbarsInView.filter(function (index, navbarEl) { return navbarEl !== $newNavbarInner[0]; });
	    }
	  } else {
	    if ($pagesInView.length > 1) {
	      var i = 0;
	      for (i = 0; i < $pagesInView.length - 1; i += 1) {
	        var oldNavbarInnerEl = app.navbar.getElByPage($pagesInView.eq(i));
	        if (router.params.stackPages) {
	          $pagesInView.eq(i).addClass('stacked');
	          if (separateNavbar) {
	            // $navbarsInView.eq(i).addClass('stacked');
	            $$1$1(oldNavbarInnerEl).addClass('stacked');
	          }
	        } else {
	          // Page remove event
	          router.pageCallback('beforeRemove', $pagesInView[i], $navbarsInView && $navbarsInView[i], 'previous', undefined, options);
	          router.removePage($pagesInView[i]);
	          if (separateNavbar && oldNavbarInnerEl) {
	            router.removeNavbar(oldNavbarInnerEl);
	          }
	        }
	      }
	    }
	    $oldPage = $viewEl
	      .children('.page:not(.stacked)')
	      .filter(function (index, page) { return page !== $newPage[0]; });
	    if (separateNavbar) {
	      $oldNavbarInner = $navbarEl
	        .children('.navbar-inner:not(.stacked)')
	        .filter(function (index, navbarInner) { return navbarInner !== $newNavbarInner[0]; });
	    }
	  }
	  if (dynamicNavbar && !separateNavbar) {
	    $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
	  }

	  // Push State
	  if (router.params.pushState && options.pushState && !options.reloadPrevious) {
	    var pushStateRoot = router.params.pushStateRoot || '';
	    History[options.reloadCurrent || options.reloadAll ? 'replace' : 'push'](
	      view.id,
	      {
	        url: options.route.url,
	      },
	      pushStateRoot + router.params.pushStateSeparator + options.route.url
	    );
	  }

	  // Current Page & Navbar
	  router.currentPageEl = $newPage[0];
	  if (dynamicNavbar && $newNavbarInner.length) {
	    router.currentNavbarEl = $newNavbarInner[0];
	  } else {
	    delete router.currentNavbarEl;
	  }

	  // Current Route
	  router.currentRoute = options.route;

	  // Update router history
	  var url = options.route.url;
	  if (options.history) {
	    if (options.reloadCurrent && router.history.length > 0) {
	      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
	    } else if (options.reloadAll) {
	      router.history = [url];
	    } else {
	      router.history.push(url);
	    }
	  }
	  router.saveHistory();

	  // Insert new page and navbar
	  var newPageInDom = $newPage.parents(document).length > 0;
	  var f7Component = $newPage[0].f7Component;
	  if (options.reloadPrevious) {
	    if (f7Component && !newPageInDom) {
	      f7Component.$mount(function (componentEl) {
	        $$1$1(componentEl).insertBefore($oldPage);
	      });
	    } else {
	      $newPage.insertBefore($oldPage);
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      if ($oldNavbarInner.length) {
	        $newNavbarInner.insertBefore($oldNavbarInner);
	      } else {
	        if (!router.$navbarEl.parents(document).length) {
	          router.$el.prepend(router.$navbarEl);
	        }
	        $navbarEl.append($newNavbarInner);
	      }
	    }
	  } else {
	    if ($oldPage.next('.page')[0] !== $newPage[0]) {
	      if (f7Component && !newPageInDom) {
	        f7Component.$mount(function (componentEl) {
	          $viewEl.append(componentEl);
	        });
	      } else {
	        $viewEl.append($newPage[0]);
	      }
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      if (!router.$navbarEl.parents(document).length) {
	        router.$el.prepend(router.$navbarEl);
	      }
	      $navbarEl.append($newNavbarInner[0]);
	    }
	  }
	  if (!newPageInDom) {
	    router.pageCallback('mounted', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);
	  }

	  // Remove old page
	  if (options.reloadCurrent && $oldPage.length > 0) {
	    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
	      $oldPage.addClass('stacked');
	      if (separateNavbar) {
	        $oldNavbarInner.addClass('stacked');
	      }
	    } else {
	      // Page remove event
	      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
	      router.removePage($oldPage);
	      if (separateNavbar && $oldNavbarInner && $oldNavbarInner.length) {
	        router.removeNavbar($oldNavbarInner);
	      }
	    }
	  } else if (options.reloadAll) {
	    $oldPage.each(function (index, pageEl) {
	      var $oldPageEl = $$1$1(pageEl);
	      var $oldNavbarInnerEl = $$1$1(app.navbar.getElByPage($oldPageEl));
	      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
	        $oldPageEl.addClass('stacked');
	        if (separateNavbar) {
	          $oldNavbarInnerEl.addClass('stacked');
	        }
	      } else {
	        // Page remove event
	        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarInner && $oldNavbarInner.eq(index), 'previous', undefined, options);
	        router.removePage($oldPageEl);
	        if (separateNavbar && $oldNavbarInnerEl.length) {
	          router.removeNavbar($oldNavbarInnerEl);
	        }
	      }
	    });
	  }

	  // Load Tab
	  if (options.route.route.tab) {
	    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
	      history: false,
	      pushState: false,
	    }));
	  }

	  // Page init and before init events
	  router.pageCallback('init', $newPage, $newNavbarInner, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

	  if (options.reloadCurrent || options.reloadAll) {
	    router.allowPageChange = true;
	    router.pageCallback('beforeIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, newPagePosition, 'current', options);
	    return router;
	  }

	  // Before animation event
	  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'next', 'current', options);
	  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);

	  // Animation
	  function afterAnimation() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
	    $oldPage.removeClass(pageClasses).addClass('page-previous').attr('aria-hidden', 'true');
	    if (dynamicNavbar) {
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-previous').attr('aria-hidden', 'true');
	    }
	    // After animation event
	    router.allowPageChange = true;
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'next', 'current', options);
	    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'previous', options);

	    var keepOldPage = app.theme === 'ios' ? (router.params.preloadPreviousPage || router.params.iosSwipeBack) : router.params.preloadPreviousPage;
	    if (!keepOldPage) {
	      if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page')) {
	        keepOldPage = true;
	      }
	    }
	    if (!keepOldPage) {
	      if (router.params.stackPages) {
	        $oldPage.addClass('stacked');
	        if (separateNavbar) {
	          $oldNavbarInner.addClass('stacked');
	        }
	      } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
	        // Remove event
	        router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'previous', undefined, options);
	        router.removePage($oldPage);
	        if (separateNavbar && $oldNavbarInner.length) {
	          router.removeNavbar($oldNavbarInner);
	        }
	      }
	    }
	    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	    if (router.params.pushState) {
	      History.clearRouterQueue();
	    }
	  }
	  function setPositionClasses() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $oldPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
	    $newPage.removeClass(pageClasses).addClass('page-next').removeAttr('aria-hidden');
	    if (dynamicNavbar) {
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-next').removeAttr('aria-hidden');
	    }
	  }
	  if (options.animate) {
	    var delay = router.app.theme === 'md' ? router.params.materialPageLoadDelay : router.params.iosPageLoadDelay;
	    if (delay) {
	      setTimeout(function () {
	        setPositionClasses();
	        router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', function () {
	          afterAnimation();
	        });
	      }, delay);
	    } else {
	      setPositionClasses();
	      router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'forward', function () {
	        afterAnimation();
	      });
	    }
	  } else {
	    afterAnimation();
	  }
	  return router;
	}
	function load(loadParams, loadOptions, ignorePageChange) {
	  if ( loadParams === void 0 ) loadParams = {};
	  if ( loadOptions === void 0 ) loadOptions = {};

	  var router = this;
	  if (!router.allowPageChange && !ignorePageChange) { return router; }
	  var params = loadParams;
	  var options = loadOptions;
	  var url = params.url;
	  var content = params.content;
	  var el = params.el;
	  var pageName = params.pageName;
	  var template = params.template;
	  var templateUrl = params.templateUrl;
	  var component = params.component;
	  var componentUrl = params.componentUrl;

	  if (!options.reloadCurrent &&
	    options.route &&
	    options.route.route &&
	    options.route.route.parentPath &&
	    router.currentRoute.route &&
	    router.currentRoute.route.parentPath === options.route.route.parentPath) {
	    // Do something nested
	    if (options.route.url === router.url) {
	      return false;
	    }
	    // Check for same params
	    var sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
	    if (sameParams) {
	      // Check for equal params name
	      Object.keys(options.route.params).forEach(function (paramName) {
	        if (
	          !(paramName in router.currentRoute.params) ||
	          (router.currentRoute.params[paramName] !== options.route.params[paramName])
	        ) {
	          sameParams = false;
	        }
	      });
	    }
	    if (sameParams) {
	      if (options.route.route.tab) {
	        return router.tabLoad(options.route.route.tab, options);
	      }
	      return false;
	    }
	  }

	  if (
	    options.route &&
	    options.route.url &&
	    router.url === options.route.url &&
	    !(options.reloadCurrent || options.reloadPrevious) &&
	    !router.params.allowDuplicateUrls
	  ) {
	    return false;
	  }

	  if (!options.route && url) {
	    options.route = router.parseRouteUrl(url);
	    Utils.extend(options.route, { route: { url: url, path: url } });
	  }

	  // Component Callbacks
	  function resolve(pageEl, newOptions) {
	    return router.forward(pageEl, Utils.extend(options, newOptions));
	  }
	  function reject() {
	    router.allowPageChange = true;
	    return router;
	  }

	  if (url || templateUrl || componentUrl) {
	    router.allowPageChange = false;
	  }

	  // Proceed
	  if (content) {
	    router.forward(router.getPageEl(content), options);
	  } else if (template || templateUrl) {
	    // Parse template and send page element
	    try {
	      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (el) {
	    // Load page from specified HTMLElement or by page name in pages container
	    router.forward(router.getPageEl(el), options);
	  } else if (pageName) {
	    // Load page by page name in pages container
	    router.forward(router.$el.children((".page[data-name=\"" + pageName + "\"]")).eq(0), options);
	  } else if (component || componentUrl) {
	    // Load from component (F7/Vue/React/...)
	    try {
	      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (url) {
	    // Load using XHR
	    if (router.xhr) {
	      router.xhr.abort();
	      router.xhr = false;
	    }
	    router.xhrRequest(url, options)
	      .then(function (pageContent) {
	        router.forward(router.getPageEl(pageContent), options);
	      })
	      .catch(function () {
	        router.allowPageChange = true;
	      });
	  }
	  return router;
	}
	function navigate(navigateParams, navigateOptions) {
	  var obj;

	  if ( navigateOptions === void 0 ) navigateOptions = {};
	  var router = this;
	  var url;
	  var createRoute;
	  if (typeof navigateParams === 'string') {
	    url = navigateParams;
	  } else {
	    url = navigateParams.url;
	    createRoute = navigateParams.route;
	  }
	  var app = router.app;
	  if (!router.view) {
	    if (app.views.main) {
	      app.views.main.router.navigate(url, navigateOptions);
	    }
	    return router;
	  }
	  if (url === '#' || url === '') {
	    return router;
	  }

	  var navigateUrl = url.replace('./', '');
	  if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
	    var currentPath = router.currentRoute.parentPath || router.currentRoute.path;
	    navigateUrl = ((currentPath ? (currentPath + "/") : '/') + navigateUrl)
	      .replace('///', '/')
	      .replace('//', '/');
	  }
	  var route;
	  if (createRoute) {
	    route = Utils.extend(router.parseRouteUrl(navigateUrl), {
	      route: Utils.extend({}, createRoute),
	    });
	  } else {
	    route = router.findMatchingRoute(navigateUrl);
	  }

	  if (!route) {
	    return router;
	  }

	  if (route.route.redirect) {
	    return redirect.call(router, 'navigate', route, navigateOptions);
	  }

	  var options = {};
	  if (route.route.options) {
	    Utils.extend(options, route.route.options, navigateOptions, { route: route });
	  } else {
	    Utils.extend(options, navigateOptions, { route: route });
	  }
	  ('popup popover sheet loginScreen actions customModal').split(' ').forEach(function (modalLoadProp) {
	    if (route.route[modalLoadProp]) {
	      router.modalLoad(modalLoadProp, route, options);
	    }
	  });
	  ('url content component pageName el componentUrl template templateUrl').split(' ').forEach(function (pageLoadProp) {
	    if (route.route[pageLoadProp]) {
	      router.load(( obj = {}, obj[pageLoadProp] = route.route[pageLoadProp], obj ), options);
	    }
	  });
	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    router.allowPageChange = false;
	    var resolvedAsModal = false;
	    ('popup popover sheet loginScreen actions customModal').split(' ').forEach(function (modalLoadProp) {
	      if (resolveParams[modalLoadProp]) {
	        resolvedAsModal = true;
	        var modalRoute = Utils.extend({}, route, { route: resolveParams });
	        router.allowPageChange = true;
	        router.modalLoad(modalLoadProp, modalRoute, Utils.extend(options, resolveOptions));
	      }
	    });
	    if (resolvedAsModal) { return; }
	    router.load(resolveParams, Utils.extend(options, resolveOptions), true);
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (route.route.async) {
	    router.allowPageChange = false;

	    route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
	  }
	  // Retur Router
	  return router;
	}

	function tabLoad(tabRoute, loadOptions) {
	  var obj;

	  if ( loadOptions === void 0 ) loadOptions = {};
	  var router = this;
	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	    history: true,
	    on: {},
	  }, loadOptions);

	  if (options.route) {
	    // Set Route
	    if (options.route !== router.currentRoute) {
	      router.currentRoute = options.route;
	    }

	    // Update Browser History
	    if (router.params.pushState && options.pushState && !options.reloadPrevious) {
	      History.replace(
	        router.view.id,
	        {
	          url: options.route.url,
	        },
	        (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
	      );
	    }

	    // Update Router History
	    if (options.history) {
	      router.history[router.history.length - 1] = options.route.url;
	      router.saveHistory();
	    }
	  }

	  // Show Tab
	  var $currentPageEl = $$1$1(router.currentPageEl);
	  var tabEl;
	  if ($currentPageEl.length && $currentPageEl.find(("#" + (tabRoute.id))).length) {
	    tabEl = $currentPageEl.find(("#" + (tabRoute.id))).eq(0);
	  } else if (router.view.selector) {
	    tabEl = (router.view.selector) + " #" + (tabRoute.id);
	  } else {
	    tabEl = "#" + (tabRoute.id);
	  }
	  var tabShowResult = router.app.tab.show({
	    tabEl: tabEl,
	    animate: options.animate,
	    tabRoute: options.route,
	  });

	  var $newTabEl = tabShowResult.$newTabEl;
	  var $oldTabEl = tabShowResult.$oldTabEl;
	  var animated = tabShowResult.animated;
	  var onTabsChanged = tabShowResult.onTabsChanged;

	  if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
	    var tabParentPageData = $newTabEl.parents('.page')[0].f7Page;
	    if (tabParentPageData && options.route) {
	      tabParentPageData.route = options.route;
	    }
	  }

	  // Tab Content Loaded
	  function onTabLoaded(contentEl) {
	    // Remove theme elements
	    router.removeThemeElements($newTabEl);

	    var tabEventTarget = $newTabEl;
	    if (typeof contentEl !== 'string') { tabEventTarget = $$1$1(contentEl); }

	    tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
	    router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

	    if ($oldTabEl && router.params.unloadTabContent) {
	      if (animated) {
	        onTabsChanged(function () {
	          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
	        });
	      } else {
	        router.tabRemove($oldTabEl, $newTabEl, tabRoute);
	      }
	    }
	  }
	  if (!router.params.unloadTabContent) {
	    if ($newTabEl[0].f7RouterTabLoaded) { return router; }
	  }

	  // Load Tab Content
	  function loadTab(loadTabParams, loadTabOptions) {
	    // Load Tab Props
	    var url = loadTabParams.url;
	    var content = loadTabParams.content;
	    var el = loadTabParams.el;
	    var template = loadTabParams.template;
	    var templateUrl = loadTabParams.templateUrl;
	    var component = loadTabParams.component;
	    var componentUrl = loadTabParams.componentUrl;
	    // Component/Template Callbacks
	    function resolve(contentEl) {
	      router.allowPageChange = true;
	      if (!contentEl) { return; }
	      if (typeof contentEl === 'string') {
	        $newTabEl.html(contentEl);
	      } else {
	        $newTabEl.html('');
	        if (contentEl.f7Component) {
	          contentEl.f7Component.$mount(function (componentEl) {
	            $newTabEl.append(componentEl);
	          });
	        } else {
	          $newTabEl.append(contentEl);
	        }
	      }
	      if (!router.params.unloadTabContent) {
	        $newTabEl[0].f7RouterTabLoaded = true;
	      }
	      onTabLoaded(contentEl);
	    }
	    function reject() {
	      router.allowPageChange = true;
	      return router;
	    }

	    if (content) {
	      resolve(content);
	    } else if (template || templateUrl) {
	      try {
	        router.tabTemplateLoader(template, templateUrl, loadTabOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (el) {
	      resolve(el);
	    } else if (component || componentUrl) {
	      // Load from component (F7/Vue/React/...)
	      try {
	        router.tabComponentLoader($newTabEl[0], component, componentUrl, loadTabOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (url) {
	      // Load using XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router.xhrRequest(url, loadTabOptions)
	        .then(function (tabContent) {
	          resolve(tabContent);
	        })
	        .catch(function () {
	          router.allowPageChange = true;
	        });
	    }
	  }

	  ('url content component el componentUrl template templateUrl').split(' ').forEach(function (tabLoadProp) {
	    if (tabRoute[tabLoadProp]) {
	      loadTab(( obj = {}, obj[tabLoadProp] = tabRoute[tabLoadProp], obj ), options);
	    }
	  });

	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    loadTab(resolveParams, Utils.extend(options, resolveOptions));
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (tabRoute.async) {
	    tabRoute.async.call(router, router.currentRoute, router.previousRoute, asyncResolve, asyncReject);
	  }
	  return router;
	}
	function tabRemove($oldTabEl, $newTabEl, tabRoute) {
	  var router = this;
	  $oldTabEl.trigger('tab:beforeremove', tabRoute);
	  router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
	  $oldTabEl.children().each(function (index, tabChild) {
	    if (tabChild.f7Component) {
	      tabChild.f7Component.$destroy();
	    }
	  });
	  router.removeTabContent($oldTabEl[0], tabRoute);
	}

	function modalLoad(modalType, route, loadOptions) {
	  var obj;

	  if ( loadOptions === void 0 ) loadOptions = {};
	  var router = this;
	  var app = router.app;
	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	    history: true,
	    on: {},
	  }, loadOptions);

	  var modalParams = route.route[modalType];
	  var modalRoute = route.route;

	  function onModalLoaded() {
	    // Create Modal
	    var modal = app[modalType].create(modalParams);
	    modalRoute.modalInstance = modal;

	    function closeOnSwipeBack() {
	      modal.close();
	    }
	    modal.on('modalOpen', function () {
	      router.once('swipeBackMove', closeOnSwipeBack);
	    });
	    modal.on('modalClose', function () {
	      router.off('swipeBackMove', closeOnSwipeBack);
	      if (!modal.closeByRouter) {
	        router.back();
	      }
	    });

	    modal.on('modalClosed', function () {
	      modal.$el.trigger(((modalType.toLowerCase()) + ":beforeremove"), route, modal);
	      modal.emit(("modalBeforeRemove " + modalType + "BeforeRemove"), modal.el, route, modal);
	      var modalComponent = modal.el.f7Component;
	      if (modalComponent) {
	        modalComponent.$destroy();
	      }
	      Utils.nextTick(function () {
	        if (modalComponent) {
	          router.removeModal(modal.el);
	        }
	        modal.destroy();
	        delete modalRoute.modalInstance;
	      });
	    });

	    if (options.route) {
	      // Update Browser History
	      if (router.params.pushState && options.pushState) {
	        History.push(
	          router.view.id,
	          {
	            url: options.route.url,
	            modal: modalType,
	          },
	          (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
	        );
	      }

	      // Set Route
	      if (options.route !== router.currentRoute) {
	        router.currentRoute = Utils.extend(options.route, { modal: modal });
	      }

	      // Update Router History
	      if (options.history) {
	        router.history.push(options.route.url);
	        router.saveHistory();
	      }
	    }

	    // Remove theme elements
	    router.removeThemeElements(modal.el);

	    // Emit events
	    modal.$el.trigger(((modalType.toLowerCase()) + ":init " + (modalType.toLowerCase()) + ":mounted"), route, modal);
	    router.emit(("modalInit " + modalType + "Init " + modalType + "Mounted"), modal.el, route, modal);
	    // Open
	    modal.open();
	  }

	  // Load Modal Content
	  function loadModal(loadModalParams, loadModalOptions) {
	    // Load Modal Props
	    var url = loadModalParams.url;
	    var content = loadModalParams.content;
	    var template = loadModalParams.template;
	    var templateUrl = loadModalParams.templateUrl;
	    var component = loadModalParams.component;
	    var componentUrl = loadModalParams.componentUrl;

	    // Component/Template Callbacks
	    function resolve(contentEl) {
	      if (contentEl) {
	        if (typeof contentEl === 'string') {
	          modalParams.content = contentEl;
	        } else if (contentEl.f7Component) {
	          contentEl.f7Component.$mount(function (componentEl) {
	            modalParams.el = componentEl;
	            app.root.append(componentEl);
	          });
	        } else {
	          modalParams.el = contentEl;
	        }
	        onModalLoaded();
	      }
	    }
	    function reject() {
	      router.allowPageChange = true;
	      return router;
	    }

	    if (content) {
	      resolve(content);
	    } else if (template || templateUrl) {
	      try {
	        router.modalTemplateLoader(template, templateUrl, loadModalOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (component || componentUrl) {
	      // Load from component (F7/Vue/React/...)
	      try {
	        router.modalComponentLoader(app.root[0], component, componentUrl, loadModalOptions, resolve, reject);
	      } catch (err) {
	        router.allowPageChange = true;
	        throw err;
	      }
	    } else if (url) {
	      // Load using XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router.xhrRequest(url, loadModalOptions)
	        .then(function (modalContent) {
	          modalParams.content = modalContent;
	          onModalLoaded();
	        })
	        .catch(function () {
	          router.allowPageChange = true;
	        });
	    } else {
	      onModalLoaded();
	    }
	  }

	  ('url content component el componentUrl template templateUrl').split(' ').forEach(function (modalLoadProp) {
	    if (modalParams[modalLoadProp]) {
	      loadModal(( obj = {}, obj[modalLoadProp] = modalParams[modalLoadProp], obj ), options);
	    }
	  });

	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    loadModal(resolveParams, Utils.extend(options, resolveOptions));
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (modalParams.async) {
	    modalParams.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
	  }
	  return router;
	}
	function modalRemove(modal) {
	  Utils.extend(modal, { closeByRouter: true });
	  modal.close();
	}

	function backward(el, backwardOptions) {
	  var router = this;
	  var app = router.app;
	  var view = router.view;

	  var options = Utils.extend({
	    animate: router.params.animate,
	    pushState: true,
	  }, backwardOptions);

	  var dynamicNavbar = router.dynamicNavbar;
	  var separateNavbar = router.separateNavbar;

	  var $newPage = $$1$1(el);
	  var $oldPage = router.$el.children('.page-current');

	  if ($newPage.length) {
	    // Remove theme elements
	    router.removeThemeElements($newPage);
	  }

	  var $navbarEl;
	  var $newNavbarInner;
	  var $oldNavbarInner;

	  if (dynamicNavbar) {
	    $newNavbarInner = $newPage.children('.navbar').children('.navbar-inner');
	    if (separateNavbar) {
	      $navbarEl = router.$navbarEl;
	      if ($newNavbarInner.length > 0) {
	        $newPage.children('.navbar').remove();
	      }
	      if ($newNavbarInner.length === 0 && $newPage[0].f7Page) {
	        // Try from pageData
	        $newNavbarInner = $newPage[0].f7Page.$navbarEl;
	      }
	      $oldNavbarInner = $navbarEl.find('.navbar-current');
	    } else {
	      $oldNavbarInner = $oldPage.children('.navbar').children('.navbar-inner');
	    }
	  }

	  router.allowPageChange = false;
	  if ($newPage.length === 0 || $oldPage.length === 0) {
	    router.allowPageChange = true;
	    return router;
	  }

	  // Remove theme elements
	  router.removeThemeElements($newPage);

	  // New Page
	  $newPage
	    .addClass('page-previous')
	    .removeClass('stacked')
	    .removeAttr('aria-hidden');

	  if (dynamicNavbar && $newNavbarInner.length > 0) {
	    $newNavbarInner
	      .addClass('navbar-previous')
	      .removeClass('stacked')
	      .removeAttr('aria-hidden');
	  }


	  // Remove previous page in case of "forced"
	  var backIndex;
	  if (options.force) {
	    if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
	      if (router.history.indexOf(options.route.url) >= 0) {
	        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
	        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
	        view.history = router.history;
	      } else if (router.history[[router.history.length - 2]]) {
	        router.history[router.history.length - 2] = options.route.url;
	      } else {
	        router.history.unshift(router.url);
	      }

	      if (backIndex && router.params.stackPages) {
	        $oldPage.prevAll('.page-previous').each(function (index, pageToRemove) {
	          var $pageToRemove = $$1$1(pageToRemove);
	          var $navbarToRemove;
	          if (separateNavbar) {
	            // $navbarToRemove = $oldNavbarInner.prevAll('.navbar-previous').eq(index);
	            $navbarToRemove = $$1$1(app.navbar.getElByPage($pageToRemove));
	          }
	          if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
	            if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
	              $pageToRemove.addClass('stacked');
	              if (separateNavbar) {
	                $navbarToRemove.addClass('stacked');
	              }
	            } else {
	              router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
	              router.removePage($pageToRemove);
	              if (separateNavbar && $navbarToRemove.length > 0) {
	                router.removeNavbar($navbarToRemove);
	              }
	            }
	          }
	        });
	      } else {
	        var $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
	        var $navbarToRemove;
	        if (separateNavbar) {
	          // $navbarToRemove = $oldNavbarInner.prev('.navbar-inner:not(.stacked)');
	          $navbarToRemove = $$1$1(app.navbar.getElByPage($pageToRemove));
	        }
	        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
	          $pageToRemove.addClass('stacked');
	          $navbarToRemove.addClass('stacked');
	        } else if ($pageToRemove.length > 0) {
	          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
	          router.removePage($pageToRemove);
	          if (separateNavbar && $navbarToRemove.length) {
	            router.removeNavbar($navbarToRemove);
	          }
	        }
	      }
	    }
	  }

	  // Insert new page
	  var newPageInDom = $newPage.parents(document).length > 0;
	  var f7Component = $newPage[0].f7Component;

	  function insertPage() {
	    if ($newPage.next($oldPage).length === 0) {
	      if (!newPageInDom && f7Component) {
	        f7Component.$mount(function (componentEl) {
	          $$1$1(componentEl).insertBefore($oldPage);
	        });
	      } else {
	        $newPage.insertBefore($oldPage);
	      }
	    }
	    if (separateNavbar && $newNavbarInner.length) {
	      $newNavbarInner.insertBefore($oldNavbarInner);
	      if ($oldNavbarInner.length > 0) {
	        $newNavbarInner.insertBefore($oldNavbarInner);
	      } else {
	        if (!router.$navbarEl.parents(document).length) {
	          router.$el.prepend(router.$navbarEl);
	        }
	        $navbarEl.append($newNavbarInner);
	      }
	    }
	    if (!newPageInDom) {
	      router.pageCallback('mounted', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
	    }
	  }

	  if (options.preload) {
	    // Insert Page
	    insertPage();
	    // Page init and before init events
	    router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);
	    if ($newPage.prevAll('.page-previous:not(.stacked)').length > 0) {
	      $newPage.prevAll('.page-previous:not(.stacked)').each(function (index, pageToRemove) {
	        var $pageToRemove = $$1$1(pageToRemove);
	        var $navbarToRemove;
	        if (separateNavbar) {
	          // $navbarToRemove = $newNavbarInner.prevAll('.navbar-previous:not(.stacked)').eq(index);
	          $navbarToRemove = $$1$1(app.navbar.getElByPage($pageToRemove));
	        }
	        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
	          $pageToRemove.addClass('stacked');
	          if (separateNavbar) {
	            $navbarToRemove.addClass('stacked');
	          }
	        } else {
	          router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
	          router.removePage($pageToRemove);
	          if (separateNavbar && $navbarToRemove.length) {
	            router.removeNavbar($navbarToRemove);
	          }
	        }
	      });
	    }
	    router.allowPageChange = true;
	    return router;
	  }

	  // History State
	  if (router.params.pushState && options.pushState) {
	    if (backIndex) { History.go(-backIndex); }
	    else { History.back(); }
	  }

	  // Update History
	  if (router.history.length === 1) {
	    router.history.unshift(router.url);
	  }
	  router.history.pop();
	  router.saveHistory();

	  // Current Page & Navbar
	  router.currentPageEl = $newPage[0];
	  if (dynamicNavbar && $newNavbarInner.length) {
	    router.currentNavbarEl = $newNavbarInner[0];
	  } else {
	    delete router.currentNavbarEl;
	  }

	  // Current Route
	  router.currentRoute = options.route;

	  // Insert Page
	  insertPage();

	  // Load Tab
	  if (options.route.route.tab) {
	    router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
	      history: false,
	      pushState: false,
	    }));
	  }

	  // Page init and before init events
	  router.pageCallback('init', $newPage, $newNavbarInner, 'previous', 'current', options, $oldPage);

	  // Before animation callback
	  router.pageCallback('beforeIn', $newPage, $newNavbarInner, 'previous', 'current', options);
	  router.pageCallback('beforeOut', $oldPage, $oldNavbarInner, 'current', 'next', options);

	  // Animation
	  function afterAnimation() {
	    // Set classes
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $newPage.removeClass(pageClasses).addClass('page-current').removeAttr('aria-hidden');
	    $oldPage.removeClass(pageClasses).addClass('page-next').attr('aria-hidden', 'true');
	    if (dynamicNavbar) {
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-current').removeAttr('aria-hidden');
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-next').attr('aria-hidden', 'true');
	    }

	    // After animation event
	    router.pageCallback('afterIn', $newPage, $newNavbarInner, 'previous', 'current', options);
	    router.pageCallback('afterOut', $oldPage, $oldNavbarInner, 'current', 'next', options);

	    // Remove Old Page
	    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
	      $oldPage.addClass('stacked');
	      if (separateNavbar) {
	        $oldNavbarInner.addClass('stacked');
	      }
	    } else {
	      router.pageCallback('beforeRemove', $oldPage, $oldNavbarInner, 'next', undefined, options);
	      router.removePage($oldPage);
	      if (separateNavbar && $oldNavbarInner.length) {
	        router.removeNavbar($oldNavbarInner);
	      }
	    }

	    router.allowPageChange = true;
	    router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

	    // Preload previous page
	    var preloadPreviousPage = app.theme === 'ios' ? (router.params.preloadPreviousPage || router.params.iosSwipeBack) : router.params.preloadPreviousPage;
	    if (preloadPreviousPage) {
	      router.back(router.history[router.history.length - 2], { preload: true });
	    }
	    if (router.params.pushState) {
	      History.clearRouterQueue();
	    }
	  }

	  function setPositionClasses() {
	    var pageClasses = 'page-previous page-current page-next';
	    var navbarClasses = 'navbar-previous navbar-current navbar-next';
	    $oldPage.removeClass(pageClasses).addClass('page-current');
	    $newPage.removeClass(pageClasses).addClass('page-previous').removeAttr('aria-hidden');
	    if (dynamicNavbar) {
	      $oldNavbarInner.removeClass(navbarClasses).addClass('navbar-current');
	      $newNavbarInner.removeClass(navbarClasses).addClass('navbar-previous').removeAttr('aria-hidden');
	    }
	  }

	  if (options.animate) {
	    setPositionClasses();
	    router.animate($oldPage, $newPage, $oldNavbarInner, $newNavbarInner, 'backward', function () {
	      afterAnimation();
	    });
	  } else {
	    afterAnimation();
	  }

	  return router;
	}
	function loadBack(backParams, backOptions, ignorePageChange) {
	  var router = this;

	  if (!router.allowPageChange && !ignorePageChange) { return router; }
	  var params = backParams;
	  var options = backOptions;
	  var url = params.url;
	  var content = params.content;
	  var el = params.el;
	  var pageName = params.pageName;
	  var template = params.template;
	  var templateUrl = params.templateUrl;
	  var component = params.component;
	  var componentUrl = params.componentUrl;

	  if (
	    options.route.url &&
	    router.url === options.route.url &&
	    !(options.reloadCurrent || options.reloadPrevious) &&
	    !router.params.allowDuplicateUrls
	  ) {
	    return false;
	  }

	  if (!options.route && url) {
	    options.route = router.parseRouteUrl(url);
	  }

	  // Component Callbacks
	  function resolve(pageEl, newOptions) {
	    return router.backward(pageEl, Utils.extend(options, newOptions));
	  }
	  function reject() {
	    router.allowPageChange = true;
	    return router;
	  }

	  if (url || templateUrl || componentUrl) {
	    router.allowPageChange = false;
	  }

	  // Proceed
	  if (content) {
	    router.backward(router.getPageEl(content), options);
	  } else if (template || templateUrl) {
	    // Parse template and send page element
	    try {
	      router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (el) {
	    // Load page from specified HTMLElement or by page name in pages container
	    router.backward(router.getPageEl(el), options);
	  } else if (pageName) {
	    // Load page by page name in pages container
	    router.backward(router.$el.children((".page[data-name=\"" + pageName + "\"]")).eq(0), options);
	  } else if (component || componentUrl) {
	    // Load from component (F7/Vue/React/...)
	    try {
	      router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
	    } catch (err) {
	      router.allowPageChange = true;
	      throw err;
	    }
	  } else if (url) {
	    // Load using XHR
	    if (router.xhr) {
	      router.xhr.abort();
	      router.xhr = false;
	    }
	    router.xhrRequest(url, options)
	      .then(function (pageContent) {
	        router.backward(router.getPageEl(pageContent), options);
	      })
	      .catch(function () {
	        router.allowPageChange = true;
	      });
	  }
	  return router;
	}
	function back() {
	  var obj;

	  var args = [], len = arguments.length;
	  while ( len-- ) args[ len ] = arguments[ len ];
	  var navigateUrl;
	  var navigateOptions;
	  if (typeof args[0] === 'object') {
	    navigateOptions = args[0] || {};
	  } else {
	    navigateUrl = args[0];
	    navigateOptions = args[1] || {};
	  }

	  var router = this;
	  var app = router.app;
	  if (!router.view) {
	    app.views.main.router.back(navigateUrl, navigateOptions);
	    return router;
	  }

	  var currentRouteIsModal = router.currentRoute.modal;
	  var modalType;
	  if (!currentRouteIsModal) {
	    ('popup popover sheet loginScreen actions customModal').split(' ').forEach(function (modalLoadProp) {
	      if (router.currentRoute.route[modalLoadProp]) {
	        currentRouteIsModal = true;
	        modalType = modalLoadProp;
	      }
	    });
	  }
	  if (currentRouteIsModal) {
	    var modalToClose = router.currentRoute.modal ||
	                         router.currentRoute.route.modalInstance ||
	                         app[modalType].get();
	    var previousUrl = router.history[router.history.length - 2];
	    var previousRoute = router.findMatchingRoute(previousUrl);
	    if (!previousRoute && previousUrl) {
	      previousRoute = {
	        url: previousUrl,
	        path: previousUrl.split('?')[0],
	        query: Utils.parseUrlQuery(previousUrl),
	        route: {
	          path: previousUrl.split('?')[0],
	          url: previousUrl,
	        },
	      };
	    }
	    if (!previousRoute || !modalToClose) {
	      return router;
	    }
	    if (router.params.pushState && navigateOptions.pushState !== false) {
	      History.back();
	    }
	    router.currentRoute = previousRoute;
	    router.history.pop();
	    router.saveHistory();
	    router.modalRemove(modalToClose);
	    return router;
	  }
	  var $previousPage = router.$el.children('.page-current').prevAll('.page-previous').eq(0);
	  if (!navigateOptions.force && $previousPage.length > 0) {
	    if (router.params.pushState && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
	      router.back(router.history[router.history.length - 2], Utils.extend(navigateOptions, { force: true }));
	      return router;
	    }
	    router.loadBack({ el: $previousPage }, Utils.extend(navigateOptions, {
	      route: $previousPage[0].f7Page.route,
	    }));
	    return router;
	  }

	  // Navigate URL
	  if (navigateUrl === '#') {
	    navigateUrl = undefined;
	  }
	  if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
	    navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
	  }
	  if (!navigateUrl && router.history.length > 1) {
	    navigateUrl = router.history[router.history.length - 2];
	  }

	  // Find route to load
	  var route = router.findMatchingRoute(navigateUrl);
	  if (!route) {
	    if (navigateUrl) {
	      route = {
	        url: navigateUrl,
	        path: navigateUrl.split('?')[0],
	        query: Utils.parseUrlQuery(navigateUrl),
	        route: {
	          path: navigateUrl.split('?')[0],
	          url: navigateUrl,
	        },
	      };
	    }
	  }
	  if (!route) {
	    return router;
	  }

	  if (route.route.redirect) {
	    return redirect.call(router, 'back', route, navigateOptions);
	  }

	  var options = {};
	  if (route.route.options) {
	    Utils.extend(options, route.route.options, navigateOptions, { route: route });
	  } else {
	    Utils.extend(options, navigateOptions, { route: route });
	  }

	  if (options.force && router.params.stackPages) {
	    router.$el.children('.page-previous.stacked').each(function (index, pageEl) {
	      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
	        router.loadBack({ el: pageEl }, options);
	      }
	    });
	  }

	  ('url content component pageName el componentUrl template templateUrl').split(' ').forEach(function (pageLoadProp) {
	    if (route.route[pageLoadProp]) {
	      router.loadBack(( obj = {}, obj[pageLoadProp] = route.route[pageLoadProp], obj ), options);
	    }
	  });
	  // Async
	  function asyncResolve(resolveParams, resolveOptions) {
	    router.allowPageChange = false;
	    router.loadBack(resolveParams, Utils.extend(options, resolveOptions), true);
	  }
	  function asyncReject() {
	    router.allowPageChange = true;
	  }
	  if (route.route.async) {
	    router.allowPageChange = false;

	    route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
	  }
	  // Return Router
	  return router;
	}

	var Router$1 = (function (Framework7Class$$1) {
	  function Router(app, view) {
	    Framework7Class$$1.call(this, {}, [typeof view === 'undefined' ? app : view]);
	    var router = this;

	    // Is App Router
	    router.isAppRouter = typeof view === 'undefined';

	    if (router.isAppRouter) {
	      // App Router
	      Utils.extend(false, router, {
	        app: app,
	        params: app.params.view,
	        routes: app.routes || [],
	        cache: app.cache,
	      });
	    } else {
	      // View Router
	      Utils.extend(false, router, {
	        app: app,
	        view: view,
	        viewId: view.id,
	        params: view.params,
	        routes: view.routes,
	        $el: view.$el,
	        el: view.el,
	        $navbarEl: view.$navbarEl,
	        navbarEl: view.navbarEl,
	        history: view.history,
	        scrollHistory: view.scrollHistory,
	        cache: app.cache,
	        dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
	        separateNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar,
	        initialPages: [],
	        initialNavbars: [],
	      });
	    }

	    // Install Modules
	    router.useModules();

	    // Temporary Dom
	    router.tempDom = document.createElement('div');

	    // AllowPageChage
	    router.allowPageChange = true;

	    // Current Route
	    var currentRoute = {};
	    var previousRoute = {};
	    Object.defineProperty(router, 'currentRoute', {
	      enumerable: true,
	      configurable: true,
	      set: function set(newRoute) {
	        if ( newRoute === void 0 ) newRoute = {};

	        previousRoute = Utils.extend({}, currentRoute);
	        currentRoute = newRoute;
	        if (!currentRoute) { return; }
	        router.url = currentRoute.url;
	        router.emit('routeChange', newRoute, previousRoute, router);
	      },
	      get: function get() {
	        return currentRoute;
	      },
	    });
	    Object.defineProperty(router, 'previousRoute', {
	      enumerable: true,
	      configurable: true,
	      get: function get() {
	        return previousRoute;
	      },
	      set: function set(newRoute) {
	        previousRoute = newRoute;
	      },
	    });

	    Utils.extend(router, {
	      // Load
	      forward: forward,
	      load: load,
	      navigate: navigate,
	      refreshPage: refreshPage,
	      // Tab
	      tabLoad: tabLoad,
	      tabRemove: tabRemove,
	      // Modal
	      modalLoad: modalLoad,
	      modalRemove: modalRemove,
	      // Back
	      backward: backward,
	      loadBack: loadBack,
	      back: back,
	    });

	    return router;
	  }

	  if ( Framework7Class$$1 ) Router.__proto__ = Framework7Class$$1;
	  Router.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Router.prototype.constructor = Router;
	  Router.prototype.animatableNavElements = function animatableNavElements (newNavbarInner, oldNavbarInner) {
	    var router = this;
	    var dynamicNavbar = router.dynamicNavbar;
	    var animateIcon = router.params.iosAnimateNavbarBackIcon;

	    var newNavEls;
	    var oldNavEls;
	    function animatableNavEl(el, navbarInner) {
	      var $el = $$1$1(el);
	      var isSliding = $el.hasClass('sliding') || navbarInner.hasClass('sliding');
	      var isSubnavbar = $el.hasClass('subnavbar');
	      var needsOpacityTransition = isSliding ? !isSubnavbar : true;
	      var hasIcon = isSliding && animateIcon && $el.hasClass('left') && $el.find('.back .icon').length > 0;
	      var $iconEl;
	      if (hasIcon) { $iconEl = $el.find('.back .icon'); }
	      return {
	        $el: $el,
	        $iconEl: $iconEl,
	        hasIcon: hasIcon,
	        leftOffset: $el[0].f7NavbarLeftOffset,
	        rightOffset: $el[0].f7NavbarRightOffset,
	        isSliding: isSliding,
	        isSubnavbar: isSubnavbar,
	        needsOpacityTransition: needsOpacityTransition,
	      };
	    }
	    if (dynamicNavbar) {
	      newNavEls = [];
	      oldNavEls = [];
	      newNavbarInner.children('.left, .right, .title, .subnavbar').each(function (index, navEl) {
	        newNavEls.push(animatableNavEl(navEl, newNavbarInner));
	      });
	      oldNavbarInner.children('.left, .right, .title, .subnavbar').each(function (index, navEl) {
	        oldNavEls.push(animatableNavEl(navEl, oldNavbarInner));
	      });
	      [oldNavEls, newNavEls].forEach(function (navEls) {
	        navEls.forEach(function (navEl) {
	          var n = navEl;
	          var isSliding = navEl.isSliding;
	          var $el = navEl.$el;
	          var otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
	          if (!(isSliding && $el.hasClass('title') && otherEls)) { return; }
	          otherEls.forEach(function (otherNavEl) {
	            if (otherNavEl.$el.hasClass('left') && otherNavEl.hasIcon) {
	              var iconTextEl = otherNavEl.$el.find('.back span')[0];
	              n.leftOffset += iconTextEl ? iconTextEl.offsetLeft : 0;
	            }
	          });
	        });
	      });
	    }

	    return { newNavEls: newNavEls, oldNavEls: oldNavEls };
	  };
	  Router.prototype.animateWithCSS = function animateWithCSS (oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback) {
	    var router = this;
	    var dynamicNavbar = router.dynamicNavbar;
	    var separateNavbar = router.separateNavbar;
	    var ios = router.app.theme === 'ios';
	    // Router Animation class
	    var routerTransitionClass = "router-transition-" + direction + " router-transition-css-" + direction;

	    var newNavEls;
	    var oldNavEls;
	    var navbarWidth = 0;

	    if (ios && dynamicNavbar) {
	      if (!separateNavbar) {
	        navbarWidth = newNavbarInner[0].offsetWidth;
	      }
	      var navEls = router.animatableNavElements(newNavbarInner, oldNavbarInner);
	      newNavEls = navEls.newNavEls;
	      oldNavEls = navEls.oldNavEls;
	    }

	    function animateNavbars(progress) {
	      if (ios && dynamicNavbar) {
	        newNavEls.forEach(function (navEl) {
	          var $el = navEl.$el;
	          var offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
	          if (navEl.isSliding) {
	            $el.transform(("translate3d(" + (offset * (1 - progress)) + "px,0,0)"));
	          }
	          if (navEl.hasIcon) {
	            if (direction === 'forward') {
	              navEl.$iconEl.transform(("translate3d(" + ((-offset - navbarWidth) * (1 - progress)) + "px,0,0)"));
	            } else {
	              navEl.$iconEl.transform(("translate3d(" + ((-offset + (navbarWidth / 5)) * (1 - progress)) + "px,0,0)"));
	            }
	          }
	        });
	        oldNavEls.forEach(function (navEl) {
	          var $el = navEl.$el;
	          var offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
	          if (navEl.isSliding) {
	            $el.transform(("translate3d(" + (offset * (progress)) + "px,0,0)"));
	          }
	          if (navEl.hasIcon) {
	            if (direction === 'forward') {
	              navEl.$iconEl.transform(("translate3d(" + ((-offset + (navbarWidth / 5)) * (progress)) + "px,0,0)"));
	            } else {
	              navEl.$iconEl.transform(("translate3d(" + ((-offset - navbarWidth) * (progress)) + "px,0,0)"));
	            }
	          }
	        });
	      }
	    }

	    // AnimationEnd Callback
	    function onDone() {
	      if (router.dynamicNavbar) {
	        if (newNavbarInner.hasClass('sliding')) {
	          newNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
	        } else {
	          newNavbarInner.find('.sliding').transform('');
	        }
	        if (oldNavbarInner.hasClass('sliding')) {
	          oldNavbarInner.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
	        } else {
	          oldNavbarInner.find('.sliding').transform('');
	        }
	      }
	      router.$el.removeClass(routerTransitionClass);
	      if (callback) { callback(); }
	    }

	    (direction === 'forward' ? newPage : oldPage).animationEnd(function () {
	      onDone();
	    });

	    // Animate
	    if (dynamicNavbar) {
	      // Prepare Navbars
	      animateNavbars(0);
	      Utils.nextTick(function () {
	        // Add class, start animation
	        animateNavbars(1);
	        router.$el.addClass(routerTransitionClass);
	      });
	    } else {
	      // Add class, start animation
	      router.$el.addClass(routerTransitionClass);
	    }
	  };
	  Router.prototype.animateWithJS = function animateWithJS (oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback) {
	    var router = this;
	    var dynamicNavbar = router.dynamicNavbar;
	    var separateNavbar = router.separateNavbar;
	    var ios = router.app.theme === 'ios';
	    var duration = ios ? 400 : 250;
	    var routerTransitionClass = "router-transition-" + direction + " router-transition-js-" + direction;

	    var startTime = null;
	    var done = false;

	    var newNavEls;
	    var oldNavEls;
	    var navbarWidth = 0;

	    if (ios && dynamicNavbar) {
	      if (!separateNavbar) {
	        navbarWidth = newNavbarInner[0].offsetWidth;
	      }
	      var navEls = router.animatableNavElements(newNavbarInner, oldNavbarInner);
	      newNavEls = navEls.newNavEls;
	      oldNavEls = navEls.oldNavEls;
	    }

	    var $shadowEl;
	    var $opacityEl;

	    if (ios) {
	      $shadowEl = $$1$1('<div class="page-shadow-effect"></div>');
	      $opacityEl = $$1$1('<div class="page-opacity-effect"></div>');

	      if (direction === 'forward') {
	        newPage.append($shadowEl);
	        oldPage.append($opacityEl);
	      } else {
	        newPage.append($opacityEl);
	        oldPage.append($shadowEl);
	      }
	    }
	    var easing = Utils.bezier(0.25, 0.1, 0.25, 1);

	    function onDone() {
	      newPage.transform('').css('opacity', '');
	      oldPage.transform('').css('opacity', '');
	      if (ios) {
	        $shadowEl.remove();
	        $opacityEl.remove();
	        if (dynamicNavbar) {
	          newNavEls.forEach(function (navEl) {
	            navEl.$el.transform('');
	            navEl.$el.css('opacity', '');
	          });
	          oldNavEls.forEach(function (navEl) {
	            navEl.$el.transform('');
	            navEl.$el.css('opacity', '');
	          });
	          newNavEls = [];
	          oldNavEls = [];
	        }
	      }

	      router.$el.removeClass(routerTransitionClass);

	      if (callback) { callback(); }
	    }

	    function render() {
	      var time = Utils.now();
	      if (!startTime) { startTime = time; }
	      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
	      var easeProgress = easing(progress);

	      if (progress >= 1) {
	        done = true;
	      }
	      var inverter = router.app.rtl ? -1 : 1;
	      if (ios) {
	        if (direction === 'forward') {
	          newPage.transform(("translate3d(" + ((1 - easeProgress) * 100 * inverter) + "%,0,0)"));
	          oldPage.transform(("translate3d(" + (-easeProgress * 20 * inverter) + "%,0,0)"));
	          $shadowEl[0].style.opacity = easeProgress;
	          $opacityEl[0].style.opacity = easeProgress;
	        } else {
	          newPage.transform(("translate3d(" + (-(1 - easeProgress) * 20 * inverter) + "%,0,0)"));
	          oldPage.transform(("translate3d(" + (easeProgress * 100 * inverter) + "%,0,0)"));
	          $shadowEl[0].style.opacity = 1 - easeProgress;
	          $opacityEl[0].style.opacity = 1 - easeProgress;
	        }
	        if (dynamicNavbar) {
	          newNavEls.forEach(function (navEl) {
	            var $el = navEl.$el;
	            var offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
	            if (navEl.needsOpacityTransition) {
	              $el[0].style.opacity = easeProgress;
	            }
	            if (navEl.isSliding) {
	              $el.transform(("translate3d(" + (offset * (1 - easeProgress)) + "px,0,0)"));
	            }
	            if (navEl.hasIcon) {
	              if (direction === 'forward') {
	                navEl.$iconEl.transform(("translate3d(" + ((-offset - navbarWidth) * (1 - easeProgress)) + "px,0,0)"));
	              } else {
	                navEl.$iconEl.transform(("translate3d(" + ((-offset + (navbarWidth / 5)) * (1 - easeProgress)) + "px,0,0)"));
	              }
	            }
	          });
	          oldNavEls.forEach(function (navEl) {
	            var $el = navEl.$el;
	            var offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
	            if (navEl.needsOpacityTransition) {
	              $el[0].style.opacity = (1 - easeProgress);
	            }
	            if (navEl.isSliding) {
	              $el.transform(("translate3d(" + (offset * (easeProgress)) + "px,0,0)"));
	            }
	            if (navEl.hasIcon) {
	              if (direction === 'forward') {
	                navEl.$iconEl.transform(("translate3d(" + ((-offset + (navbarWidth / 5)) * (easeProgress)) + "px,0,0)"));
	              } else {
	                navEl.$iconEl.transform(("translate3d(" + ((-offset - navbarWidth) * (easeProgress)) + "px,0,0)"));
	              }
	            }
	          });
	        }
	      } else if (direction === 'forward') {
	        newPage.transform(("translate3d(0, " + ((1 - easeProgress) * 56) + "px,0)"));
	        newPage.css('opacity', easeProgress);
	      } else {
	        oldPage.transform(("translate3d(0, " + (easeProgress * 56) + "px,0)"));
	        oldPage.css('opacity', 1 - easeProgress);
	      }

	      if (done) {
	        onDone();
	        return;
	      }
	      Utils.nextFrame(render);
	    }

	    router.$el.addClass(routerTransitionClass);

	    Utils.nextFrame(render);
	  };
	  Router.prototype.animate = function animate () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    // Args: oldPage, newPage, oldNavbarInner, newNavbarInner, direction, callback
	    var router = this;
	    if (router.params.animateCustom) {
	      router.params.animateCustom.apply(router, args);
	    } else if (router.params.animateWithJS) {
	      router.animateWithJS.apply(router, args);
	    } else {
	      router.animateWithCSS.apply(router, args);
	    }
	  };
	  Router.prototype.removeModal = function removeModal (modalEl) {
	    var router = this;
	    router.removeEl(modalEl);
	  };
	  // eslint-disable-next-line
	  Router.prototype.removeTabContent = function removeTabContent (tabEl) {
	    var $tabEl = $$1$1(tabEl);
	    $tabEl.html('');
	  };
	  Router.prototype.removeNavbar = function removeNavbar (el) {
	    var router = this;
	    router.removeEl(el);
	  };
	  Router.prototype.removePage = function removePage (el) {
	    var router = this;
	    router.removeEl(el);
	  };
	  Router.prototype.removeEl = function removeEl (el) {
	    if (!el) { return; }
	    var router = this;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return; }
	    if ($el[0].f7Component && $el[0].f7Component.$destroy) {
	      $el[0].f7Component.$destroy();
	    }
	    if (!router.params.removeElements) {
	      return;
	    }
	    if (router.params.removeElementsWithTimeout) {
	      setTimeout(function () {
	        $el.remove();
	      }, router.params.removeElementsTimeout);
	    } else {
	      $el.remove();
	    }
	  };
	  Router.prototype.getPageEl = function getPageEl (content) {
	    var router = this;
	    if (typeof content === 'string') {
	      router.tempDom.innerHTML = content;
	    } else {
	      if ($$1$1(content).hasClass('page')) {
	        return content;
	      }
	      router.tempDom.innerHTML = '';
	      $$1$1(router.tempDom).append(content);
	    }

	    return router.findElement('.page', router.tempDom);
	  };
	  Router.prototype.findElement = function findElement (stringSelector, container, notStacked) {
	    var router = this;
	    var view = router.view;
	    var app = router.app;

	    // Modals Selector
	    var modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';

	    var $container = $$1$1(container);
	    var selector = stringSelector;
	    if (notStacked) { selector += ':not(.stacked)'; }

	    var found = $container
	      .find(selector)
	      .filter(function (index, el) { return $$1$1(el).parents(modalsSelector).length === 0; });

	    if (found.length > 1) {
	      if (typeof view.selector === 'string') {
	        // Search in related view
	        found = $container.find(((view.selector) + " " + selector));
	      }
	      if (found.length > 1) {
	        // Search in main view
	        found = $container.find(("." + (app.params.viewMainClass) + " " + selector));
	      }
	    }
	    if (found.length === 1) { return found; }

	    // Try to find not stacked
	    if (!notStacked) { found = router.findElement(selector, $container, true); }
	    if (found && found.length === 1) { return found; }
	    if (found && found.length > 1) { return $$1$1(found[0]); }
	    return undefined;
	  };
	  Router.prototype.flattenRoutes = function flattenRoutes (routes) {
	    var this$1 = this;
	    if ( routes === void 0 ) routes = this.routes;

	    var flattenedRoutes = [];
	    routes.forEach(function (route) {
	      if ('routes' in route) {
	        var mergedPathsRoutes = route.routes.map(function (childRoute) {
	          var cRoute = Utils.extend({}, childRoute);
	          cRoute.path = (((route.path) + "/" + (cRoute.path))).replace('///', '/').replace('//', '/');
	          return cRoute;
	        });
	        flattenedRoutes = flattenedRoutes.concat(route, this$1.flattenRoutes(mergedPathsRoutes));
	      } else if ('tabs' in route && route.tabs) {
	        var mergedPathsRoutes$1 = route.tabs.map(function (tabRoute) {
	          var tRoute = Utils.extend({}, route, {
	            path: (((route.path) + "/" + (tabRoute.path))).replace('///', '/').replace('//', '/'),
	            parentPath: route.path,
	            tab: tabRoute,
	          });
	          delete tRoute.tabs;
	          return tRoute;
	        });
	        flattenedRoutes = flattenedRoutes.concat(this$1.flattenRoutes(mergedPathsRoutes$1));
	      } else {
	        flattenedRoutes.push(route);
	      }
	    });
	    return flattenedRoutes;
	  };
	  // eslint-disable-next-line
	  Router.prototype.parseRouteUrl = function parseRouteUrl (url) {
	    if (!url) { return {}; }
	    var query = Utils.parseUrlQuery(url);
	    var hash = url.split('#')[1];
	    var params = {};
	    var path = url.split('#')[0].split('?')[0];
	    return {
	      query: query,
	      hash: hash,
	      params: params,
	      url: url,
	      path: path,
	    };
	  };
	  Router.prototype.findTabRoute = function findTabRoute (tabEl) {
	    var router = this;
	    var $tabEl = $$1$1(tabEl);
	    var parentPath = router.currentRoute.route.parentPath;
	    var tabId = $tabEl.attr('id');
	    var flattenedRoutes = router.flattenRoutes(router.routes);
	    var foundTabRoute;
	    flattenedRoutes.forEach(function (route) {
	      if (
	        route.parentPath === parentPath &&
	        route.tab &&
	        route.tab.id === tabId
	      ) {
	        foundTabRoute = route;
	      }
	    });
	    return foundTabRoute;
	  };
	  Router.prototype.findRouteByKey = function findRouteByKey (key, value) {
	    var router = this;
	    var routes = router.routes;
	    var flattenedRoutes = router.flattenRoutes(routes);
	    var matchingRoute;

	    flattenedRoutes.forEach(function (route) {
	      if (matchingRoute) { return; }
	      if (route[key] === value) {
	        matchingRoute = route;
	      }
	    });
	    return matchingRoute;
	  };
	  Router.prototype.findMatchingRoute = function findMatchingRoute (url) {
	    if (!url) { return undefined; }
	    var router = this;
	    var routes = router.routes;
	    var flattenedRoutes = router.flattenRoutes(routes);
	    var ref = router.parseRouteUrl(url);
	    var path = ref.path;
	    var query = ref.query;
	    var hash = ref.hash;
	    var params = ref.params;
	    var matchingRoute;
	    flattenedRoutes.forEach(function (route) {
	      if (matchingRoute) { return; }
	      var keys = [];

	      var pathsToMatch = [route.path];
	      if (route.alias) {
	        if (typeof route.alias === 'string') { pathsToMatch.push(route.alias); }
	        else if (Array.isArray(route.alias)) {
	          route.alias.forEach(function (aliasPath) {
	            pathsToMatch.push(aliasPath);
	          });
	        }
	      }

	      var matched;
	      pathsToMatch.forEach(function (pathToMatch) {
	        if (matched) { return; }
	        matched = pathToRegexp_1(pathToMatch, keys).exec(path);
	      });

	      if (matched) {
	        keys.forEach(function (keyObj, index) {
	          var paramValue = matched[index + 1];
	          params[keyObj.name] = paramValue;
	        });

	        var parentPath;
	        if (route.parentPath) {
	          parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
	        }

	        matchingRoute = {
	          query: query,
	          hash: hash,
	          params: params,
	          url: url,
	          path: path,
	          parentPath: parentPath,
	          route: route,
	          name: route.name,
	        };
	      }
	    });
	    return matchingRoute;
	  };
	  Router.prototype.removeFromXhrCache = function removeFromXhrCache (url) {
	    var router = this;
	    var xhrCache = router.cache.xhr;
	    var index = false;
	    for (var i = 0; i < xhrCache.length; i += 1) {
	      if (xhrCache[i].url === url) { index = i; }
	    }
	    if (index !== false) { xhrCache.splice(index, 1); }
	  };
	  Router.prototype.xhrRequest = function xhrRequest (requestUrl, options) {
	    var router = this;
	    var params = router.params;
	    var ignoreCache = options.ignoreCache;
	    var url = requestUrl;

	    var hasQuery = url.indexOf('?') >= 0;
	    if (params.passRouteQueryToRequest &&
	      options &&
	      options.route &&
	      options.route.query &&
	      Object.keys(options.route.query).length
	    ) {
	      url += "" + (hasQuery ? '&' : '?') + (Utils.serializeObject(options.route.query));
	      hasQuery = true;
	    }

	    if (params.passRouteParamsToRequest &&
	      options &&
	      options.route &&
	      options.route.params &&
	      Object.keys(options.route.params).length
	    ) {
	      url += "" + (hasQuery ? '&' : '?') + (Utils.serializeObject(options.route.params));
	      hasQuery = true;
	    }

	    if (url.indexOf('{{') >= 0 &&
	      options &&
	      options.route &&
	      options.route.params &&
	      Object.keys(options.route.params).length
	    ) {
	      Object.keys(options.route.params).forEach(function (paramName) {
	        var regExp = new RegExp(("{{" + paramName + "}}"), 'g');
	        url = url.replace(regExp, options.route.params[paramName] || '');
	      });
	    }
	    // should we ignore get params or not
	    if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
	      url = url.split('?')[0];
	    }
	    return Utils.promise(function (resolve, reject) {
	      if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
	        for (var i = 0; i < router.cache.xhr.length; i += 1) {
	          var cachedUrl = router.cache.xhr[i];
	          if (cachedUrl.url === url) {
	            // Check expiration
	            if (Utils.now() - cachedUrl.time < params.xhrCacheDuration) {
	              // Load from cache
	              resolve(cachedUrl.content);
	              return;
	            }
	          }
	        }
	      }
	      router.xhr = router.app.request({
	        url: url,
	        method: 'GET',
	        beforeSend: function beforeSend(xhr) {
	          router.emit('routerAjaxStart', xhr, options);
	        },
	        complete: function complete(xhr, status) {
	          router.emit('routerAjaxComplete', xhr);
	          if ((status !== 'error' && status !== 'timeout' && (xhr.status >= 200 && xhr.status < 300)) || xhr.status === 0) {
	            if (params.xhrCache && xhr.responseText !== '') {
	              router.removeFromXhrCache(url);
	              router.cache.xhr.push({
	                url: url,
	                time: Utils.now(),
	                content: xhr.responseText,
	              });
	            }
	            router.emit('routerAjaxSuccess', xhr, options);
	            resolve(xhr.responseText);
	          } else {
	            router.emit('routerAjaxError', xhr, options);
	            reject(xhr);
	          }
	        },
	        error: function error(xhr) {
	          router.emit('routerAjaxError', xhr, options);
	          reject(xhr);
	        },
	      });
	    });
	  };
	  // Remove theme elements
	  Router.prototype.removeThemeElements = function removeThemeElements (el) {
	    var router = this;
	    var theme = router.app.theme;
	    $$1$1(el).find(("." + (theme === 'md' ? 'ios' : 'md') + "-only, .if-" + (theme === 'md' ? 'ios' : 'md'))).remove();
	  };
	  Router.prototype.templateLoader = function templateLoader (template, templateUrl, options, resolve, reject) {
	    var router = this;
	    function compile(t) {
	      var compiledHtml;
	      var context;
	      try {
	        context = options.context || {};
	        if (typeof context === 'function') { context = context.call(router); }
	        else if (typeof context === 'string') {
	          try {
	            context = JSON.parse(context);
	          } catch (err) {
	            reject();
	            throw (err);
	          }
	        }
	        if (typeof t === 'function') {
	          compiledHtml = t(context);
	        } else {
	          compiledHtml = Template7.compile(t)(Utils.extend({}, context || {}, {
	            $app: router.app,
	            $root: Utils.extend({}, router.app.data, router.app.methods),
	            $route: options.route,
	            $router: router,
	            $theme: {
	              ios: router.app.theme === 'ios',
	              md: router.app.theme === 'md',
	            },
	          }));
	        }
	      } catch (err) {
	        reject();
	        throw (err);
	      }
	      resolve(compiledHtml, { context: context });
	    }
	    if (templateUrl) {
	      // Load via XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router
	        .xhrRequest(templateUrl, options)
	        .then(function (templateContent) {
	          compile(templateContent);
	        })
	        .catch(function () {
	          reject();
	        });
	    } else {
	      compile(template);
	    }
	  };
	  Router.prototype.modalTemplateLoader = function modalTemplateLoader (template, templateUrl, options, resolve, reject) {
	    var router = this;
	    return router.templateLoader(template, templateUrl, options, function (html) {
	      resolve(html);
	    }, reject);
	  };
	  Router.prototype.tabTemplateLoader = function tabTemplateLoader (template, templateUrl, options, resolve, reject) {
	    var router = this;
	    return router.templateLoader(template, templateUrl, options, function (html) {
	      resolve(html);
	    }, reject);
	  };
	  Router.prototype.pageTemplateLoader = function pageTemplateLoader (template, templateUrl, options, resolve, reject) {
	    var router = this;
	    return router.templateLoader(template, templateUrl, options, function (html, newOptions) {
	      if ( newOptions === void 0 ) newOptions = {};

	      resolve(router.getPageEl(html), newOptions);
	    }, reject);
	  };
	  Router.prototype.componentLoader = function componentLoader (component, componentUrl, options, resolve, reject) {
	    if ( options === void 0 ) options = {};

	    var router = this;
	    var url = typeof component === 'string' ? component : componentUrl;
	    function compile(c) {
	      var extendContext = Utils.extend(
	        {},
	        options.context || {},
	        {
	          $: $$1$1,
	          $$: $$1$1,
	          $app: router.app,
	          $root: Utils.extend({}, router.app.data, router.app.methods),
	          $route: options.route,
	          $router: router,
	          $dom7: $$1$1,
	          $theme: {
	            ios: router.app.theme === 'ios',
	            md: router.app.theme === 'md',
	          },
	        }
	      );
	      var createdComponent = Component.create(c, extendContext);
	      resolve(createdComponent.el);
	    }
	    if (url) {
	      // Load via XHR
	      if (router.xhr) {
	        router.xhr.abort();
	        router.xhr = false;
	      }
	      router
	        .xhrRequest(url, options)
	        .then(function (loadedComponent) {
	          compile(Component.parse(loadedComponent));
	        })
	        .catch(function (err) {
	          reject();
	          throw (err);
	        });
	    } else {
	      compile(component);
	    }
	  };
	  Router.prototype.modalComponentLoader = function modalComponentLoader (rootEl, component, componentUrl, options, resolve, reject) {
	    var router = this;
	    router.componentLoader(component, componentUrl, options, function (el) {
	      resolve(el);
	    }, reject);
	  };
	  Router.prototype.tabComponentLoader = function tabComponentLoader (tabEl, component, componentUrl, options, resolve, reject) {
	    var router = this;
	    router.componentLoader(component, componentUrl, options, function (el) {
	      resolve(el);
	    }, reject);
	  };
	  Router.prototype.pageComponentLoader = function pageComponentLoader (routerEl, component, componentUrl, options, resolve, reject) {
	    var router = this;
	    router.componentLoader(component, componentUrl, options, function (el, newOptions) {
	      if ( newOptions === void 0 ) newOptions = {};

	      resolve(el, newOptions);
	    }, reject);
	  };
	  Router.prototype.getPageData = function getPageData (pageEl, navbarEl, from, to, route, pageFromEl) {
	    if ( route === void 0 ) route = {};

	    var router = this;
	    var $pageEl = $$1$1(pageEl);
	    var $navbarEl = $$1$1(navbarEl);
	    var currentPage = $pageEl[0].f7Page || {};
	    var direction;
	    var pageFrom;
	    if ((from === 'next' && to === 'current') || (from === 'current' && to === 'previous')) { direction = 'forward'; }
	    if ((from === 'current' && to === 'next') || (from === 'previous' && to === 'current')) { direction = 'backward'; }
	    if (currentPage && !currentPage.fromPage) {
	      var $pageFromEl = $$1$1(pageFromEl);
	      if ($pageFromEl.length) {
	        pageFrom = $pageFromEl[0].f7Page;
	      }
	    }
	    var page = {
	      app: router.app,
	      view: router.view,
	      router: router,
	      $el: $pageEl,
	      el: $pageEl[0],
	      $pageEl: $pageEl,
	      pageEl: $pageEl[0],
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl[0],
	      name: $pageEl.attr('data-name'),
	      position: from,
	      from: from,
	      to: to,
	      direction: direction,
	      route: currentPage.route ? currentPage.route : route,
	      pageFrom: currentPage.pageFrom || pageFrom,
	    };

	    if ($navbarEl && $navbarEl[0]) {
	      $navbarEl[0].f7Page = page;
	    }
	    $pageEl[0].f7Page = page;
	    return page;
	  };
	  // Callbacks
	  Router.prototype.pageCallback = function pageCallback (callback, pageEl, navbarEl, from, to, options, pageFromEl) {
	    if ( options === void 0 ) options = {};

	    if (!pageEl) { return; }
	    var router = this;
	    var $pageEl = $$1$1(pageEl);
	    if (!$pageEl.length) { return; }
	    var route = options.route;
	    var restoreScrollTopOnBack = router.params.restoreScrollTopOnBack;

	    var camelName = "page" + (callback[0].toUpperCase() + callback.slice(1, callback.length));
	    var colonName = "page:" + (callback.toLowerCase());

	    var page = {};
	    if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
	      page = Utils.extend($pageEl[0].f7Page, { from: from, to: to, position: from });
	    } else {
	      page = router.getPageData(pageEl, navbarEl, from, to, route, pageFromEl);
	    }

	    var ref = options.route ? options.route.route : {};
	    var on = ref.on; if ( on === void 0 ) on = {};
	    var once = ref.once; if ( once === void 0 ) once = {};
	    if (options.on) {
	      Utils.extend(on, options.on);
	    }
	    if (options.once) {
	      Utils.extend(once, options.once);
	    }

	    function attachEvents() {
	      if ($pageEl[0].f7RouteEventsAttached) { return; }
	      $pageEl[0].f7RouteEventsAttached = true;
	      if (on && Object.keys(on).length > 0) {
	        $pageEl[0].f7RouteEventsOn = on;
	        Object.keys(on).forEach(function (eventName) {
	          on[eventName] = on[eventName].bind(router);
	          $pageEl.on(Utils.eventNameToColonCase(eventName), on[eventName]);
	        });
	      }
	      if (once && Object.keys(once).length > 0) {
	        $pageEl[0].f7RouteEventsOnce = once;
	        Object.keys(once).forEach(function (eventName) {
	          once[eventName] = once[eventName].bind(router);
	          $pageEl.once(Utils.eventNameToColonCase(eventName), once[eventName]);
	        });
	      }
	    }

	    function detachEvents() {
	      if (!$pageEl[0].f7RouteEventsAttached) { return; }
	      if ($pageEl[0].f7RouteEventsOn) {
	        Object.keys($pageEl[0].f7RouteEventsOn).forEach(function (eventName) {
	          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
	        });
	      }
	      if ($pageEl[0].f7RouteEventsOnce) {
	        Object.keys($pageEl[0].f7RouteEventsOnce).forEach(function (eventName) {
	          $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
	        });
	      }
	      $pageEl[0].f7RouteEventsAttached = null;
	      $pageEl[0].f7RouteEventsOn = null;
	      $pageEl[0].f7RouteEventsOnce = null;
	      delete $pageEl[0].f7RouteEventsAttached;
	      delete $pageEl[0].f7RouteEventsOn;
	      delete $pageEl[0].f7RouteEventsOnce;
	    }

	    if (callback === 'mounted') {
	      attachEvents();
	    }
	    if (callback === 'init') {
	      if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url]) {
	        $pageEl.find('.page-content').scrollTop(router.scrollHistory[page.route.url]);
	      }
	      attachEvents();
	      if ($pageEl[0].f7PageInitialized) {
	        $pageEl.trigger('page:reinit', page);
	        router.emit('pageReinit', page);
	        return;
	      }
	      $pageEl[0].f7PageInitialized = true;
	    }
	    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
	      // Save scroll position
	      router.scrollHistory[page.route.url] = $pageEl.find('.page-content').scrollTop();
	    }
	    if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
	      // Delete scroll position
	      delete router.scrollHistory[page.route.url];
	    }

	    $pageEl.trigger(colonName, page);
	    router.emit(camelName, page);

	    if (callback === 'beforeRemove') {
	      detachEvents();
	      $pageEl[0].f7Page = null;
	    }
	  };
	  Router.prototype.saveHistory = function saveHistory () {
	    var router = this;
	    router.view.history = router.history;
	    if (router.params.pushState) {
	      window.localStorage[("f7router-" + (router.view.id) + "-history")] = JSON.stringify(router.history);
	    }
	  };
	  Router.prototype.restoreHistory = function restoreHistory () {
	    var router = this;
	    if (router.params.pushState && window.localStorage[("f7router-" + (router.view.id) + "-history")]) {
	      router.history = JSON.parse(window.localStorage[("f7router-" + (router.view.id) + "-history")]);
	      router.view.history = router.history;
	    }
	  };
	  Router.prototype.clearHistory = function clearHistory () {
	    var router = this;
	    router.history = [];
	    router.saveHistory();
	  };
	  Router.prototype.init = function init () {
	    var router = this;
	    var app = router.app;
	    var view = router.view;

	    // Init Swipeback
	    {
	      if (view && router.params.iosSwipeBack && app.theme === 'ios') {
	        SwipeBack(router);
	      }
	    }

	    // Dynamic not separated navbbar
	    if (router.dynamicNavbar && !router.separateNavbar) {
	      router.$el.addClass('router-dynamic-navbar-inside');
	    }

	    var initUrl = router.params.url;
	    var documentUrl = document.location.href.split(document.location.origin)[1];
	    var historyRestored;
	    if (!router.params.pushState) {
	      if (!initUrl) {
	        initUrl = documentUrl;
	      }
	      if (document.location.search && initUrl.indexOf('?') < 0) {
	        initUrl += document.location.search;
	      }
	      if (document.location.hash && initUrl.indexOf('#') < 0) {
	        initUrl += document.location.hash;
	      }
	    } else {
	      if (router.params.pushStateRoot && documentUrl.indexOf(router.params.pushStateRoot) >= 0) {
	        documentUrl = documentUrl.split(router.params.pushStateRoot)[1];
	        if (documentUrl === '') { documentUrl = '/'; }
	      }
	      if (router.params.pushStateSeparator.length > 0 && documentUrl.indexOf(router.params.pushStateSeparator) >= 0) {
	        initUrl = documentUrl.split(router.params.pushStateSeparator)[1];
	      } else {
	        initUrl = documentUrl;
	      }
	      router.restoreHistory();
	      if (router.history.indexOf(initUrl) >= 0) {
	        router.history = router.history.slice(0, router.history.indexOf(initUrl) + 1);
	      } else if (router.params.url === initUrl) {
	        router.history = [initUrl];
	      } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
	        initUrl = router.history[router.history.length - 1];
	      } else {
	        router.history = [documentUrl.split(router.params.pushStateSeparator)[0] || '/', initUrl];
	      }
	      if (router.history.length > 1) {
	        historyRestored = true;
	      } else {
	        router.history = [];
	      }
	      router.saveHistory();
	    }
	    var currentRoute;
	    if (router.history.length > 1) {
	      // Will load page
	      currentRoute = router.findMatchingRoute(router.history[0]);
	      if (!currentRoute) {
	        currentRoute = Utils.extend(router.parseRouteUrl(router.history[0]), {
	          route: {
	            url: router.history[0],
	            path: router.history[0].split('?')[0],
	          },
	        });
	      }
	    } else {
	      // Don't load page
	      currentRoute = router.findMatchingRoute(initUrl);
	      if (!currentRoute) {
	        currentRoute = Utils.extend(router.parseRouteUrl(initUrl), {
	          route: {
	            url: initUrl,
	            path: initUrl.split('?')[0],
	          },
	        });
	      }
	    }

	    if (router.params.stackPages) {
	      router.$el.children('.page').each(function (index, pageEl) {
	        var $pageEl = $$1$1(pageEl);
	        router.initialPages.push($pageEl[0]);
	        if (router.separateNavbar && $pageEl.children('.navbar').length > 0) {
	          router.initialNavbars.push($pageEl.children('.navbar').find('.navbar-inner')[0]);
	        }
	      });
	    }

	    if (router.$el.children('.page:not(.stacked)').length === 0 && initUrl) {
	      // No pages presented in DOM, reload new page
	      router.navigate(initUrl, {
	        reloadCurrent: true,
	        pushState: false,
	      });
	    } else {
	      // Init current DOM page
	      router.currentRoute = currentRoute;
	      router.$el.children('.page:not(.stacked)').each(function (index, pageEl) {
	        var $pageEl = $$1$1(pageEl);
	        var $navbarInnerEl;
	        $pageEl.addClass('page-current');
	        if (router.separateNavbar) {
	          $navbarInnerEl = $pageEl.children('.navbar').children('.navbar-inner');
	          if ($navbarInnerEl.length > 0) {
	            if (!router.$navbarEl.parents(document).length) {
	              router.$el.prepend(router.$navbarEl);
	            }
	            router.$navbarEl.append($navbarInnerEl);
	            $pageEl.children('.navbar').remove();
	          } else {
	            router.$navbarEl.addClass('navbar-hidden');
	          }
	        }
	        var initOptions = {
	          route: router.currentRoute,
	        };
	        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
	          Utils.extend(initOptions, router.currentRoute.route.options);
	        }
	        router.currentPageEl = $pageEl[0];
	        if (router.dynamicNavbar && $navbarInnerEl.length) {
	          router.currentNavbarEl = $navbarInnerEl[0];
	        }
	        router.removeThemeElements($pageEl);
	        if (router.dynamicNavbar && $navbarInnerEl.length) {
	          router.removeThemeElements($navbarInnerEl);
	        }
	        if (initOptions.route.route.tab) {
	          router.tabLoad(initOptions.route.route.tab, Utils.extend({}, initOptions));
	        }
	        router.pageCallback('init', $pageEl, $navbarInnerEl, 'current', undefined, initOptions);
	      });
	      if (historyRestored) {
	        router.navigate(initUrl, {
	          pushState: false,
	          history: false,
	          animate: router.params.pushStateAnimateOnLoad,
	          once: {
	            pageAfterIn: function pageAfterIn() {
	              if (router.history.length > 2) {
	                router.back({ preload: true });
	              }
	            },
	          },
	        });
	      } else {
	        router.history.push(initUrl);
	        router.saveHistory();
	      }
	    }
	    router.emit('local::init routerInit', router);
	  };
	  Router.prototype.destroy = function destroy () {
	    var router = this;

	    router.emit('local::destroy routerDestroy', router);

	    // Delete props & methods
	    Object.keys(router).forEach(function (routerProp) {
	      router[routerProp] = null;
	      delete router[routerProp];
	    });

	    router = null;
	  };

	  return Router;
	}(Framework7Class));

	var Router = {
	  name: 'router',
	  static: {
	    Router: Router$1,
	  },
	  instance: {
	    cache: {
	      xhr: [],
	      templates: [],
	      components: [],
	    },
	  },
	  create: function create() {
	    var instance = this;
	    if (instance.app) {
	      // View Router
	      if (instance.params.router) {
	        instance.router = new Router$1(instance.app, instance);
	      }
	    } else {
	      // App Router
	      instance.router = new Router$1(instance);
	    }
	  },
	};

	var View = (function (Framework7Class$$1) {
	  function View(appInstance, el, viewParams) {
	    if ( viewParams === void 0 ) viewParams = {};

	    Framework7Class$$1.call(this, viewParams, [appInstance]);

	    var app = appInstance;
	    var $el = $$1$1(el);
	    var view = this;

	    var defaults = {
	      routes: [],
	      routesAdd: [],
	    };

	    // Default View params
	    view.params = Utils.extend(defaults, app.params.view, viewParams);

	    // Routes
	    if (view.params.routes.length > 0) {
	      view.routes = view.params.routes;
	    } else {
	      view.routes = [].concat(app.routes, view.params.routesAdd);
	    }

	    // Selector
	    var selector;
	    if (typeof el === 'string') { selector = el; }
	    else {
	      // Supposed to be HTMLElement or Dom7
	      selector = ($el.attr('id') ? ("#" + ($el.attr('id'))) : '') + ($el.attr('class') ? ("." + ($el.attr('class').replace(/ /g, '.').replace('.active', ''))) : '');
	    }

	    // DynamicNavbar
	    var $navbarEl;
	    if (app.theme === 'ios' && view.params.iosDynamicNavbar && view.params.iosSeparateDynamicNavbar) {
	      $navbarEl = $el.children('.navbar').eq(0);
	      if ($navbarEl.length === 0) {
	        $navbarEl = $$1$1('<div class="navbar"></div>');
	      }
	    }

	    // View Props
	    Utils.extend(false, view, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      name: view.params.name,
	      main: view.params.main || $el.hasClass('view-main'),
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl ? $navbarEl[0] : undefined,
	      selector: selector,
	      history: [],
	      scrollHistory: {},
	    });

	    // Save in DOM
	    $el[0].f7View = view;

	    // Install Modules
	    view.useModules();

	    // Add to app
	    app.views.push(view);
	    if (view.main) {
	      app.views.main = view;
	    }
	    if (view.name) {
	      app.views[view.name] = view;
	    }

	    // Index
	    view.index = app.views.indexOf(view);

	    // View ID
	    var viewId;
	    if (view.name) {
	      viewId = "view_" + (view.name);
	    } else if (view.main) {
	      viewId = 'view_main';
	    } else {
	      viewId = "view_" + (view.index);
	    }
	    view.id = viewId;

	    // Init View
	    if (app.initialized) {
	      view.init();
	    } else {
	      app.on('init', function () {
	        view.init();
	      });
	    }

	    return view;
	  }

	  if ( Framework7Class$$1 ) View.__proto__ = Framework7Class$$1;
	  View.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  View.prototype.constructor = View;
	  View.prototype.destroy = function destroy () {
	    var view = this;
	    var app = view.app;

	    view.$el.trigger('view:beforedestroy', view);
	    view.emit('local::beforeDestroy viewBeforeDestroy', view);

	    if (view.main) {
	      app.views.main = null;
	      delete app.views.main;
	    } else if (view.name) {
	      app.views[view.name] = null;
	      delete app.views[view.name];
	    }
	    view.$el[0].f7View = null;
	    delete view.$el[0].f7View;

	    app.views.splice(app.views.indexOf(view), 1);

	    // Destroy Router
	    if (view.params.router && view.router) {
	      view.router.destroy();
	    }

	    view.emit('local::destroy viewDestroy', view);

	    // Delete props & methods
	    Object.keys(view).forEach(function (viewProp) {
	      view[viewProp] = null;
	      delete view[viewProp];
	    });

	    view = null;
	  };
	  View.prototype.init = function init () {
	    var view = this;
	    if (view.params.router) {
	      view.router.init();
	    }
	  };

	  return View;
	}(Framework7Class));

	// Use Router
	View.use(Router);

	function initClicks(app) {
	  function handleClicks(e) {
	    var clicked = $$1$1(e.target);
	    var clickedLink = clicked.closest('a');
	    var isLink = clickedLink.length > 0;
	    var url = isLink && clickedLink.attr('href');
	    var isTabLink = isLink && clickedLink.hasClass('tab-link') && (clickedLink.attr('data-tab') || (url && url.indexOf('#') === 0));

	    // Check if link is external
	    if (isLink) {
	      // eslint-disable-next-line
	      if (clickedLink.is(app.params.clicks.externalLinks) || (url && url.indexOf('javascript:') >= 0)) {
	        var target = clickedLink.attr('target');
	        if (url && (target === '_system' || target === '_blank' || target === '_browser')) {
	          e.preventDefault();
	          if (target !== '_browser' && window.cordova && window.cordova.InAppBrowser) {
	            window.cordova.InAppBrowser.open(url, target);
	          } else {
	            window.open(url, target);
	          }
	        }
	        return;
	      }
	    }

	    // Modules Clicks
	    Object.keys(app.modules).forEach(function (moduleName) {
	      var moduleClicks = app.modules[moduleName].clicks;
	      if (!moduleClicks) { return; }
	      Object.keys(moduleClicks).forEach(function (clickSelector) {
	        var matchingClickedElement = clicked.closest(clickSelector).eq(0);
	        if (matchingClickedElement.length > 0) {
	          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset());
	        }
	      });
	    });

	    // Load Page
	    var clickedLinkData = {};
	    if (isLink) {
	      e.preventDefault();
	      clickedLinkData = clickedLink.dataset();
	    }
	    var validUrl = url && url.length > 0 && url !== '#' && !isTabLink;
	    var template = clickedLinkData.template;
	    if (validUrl || clickedLink.hasClass('back') || template) {
	      var view;
	      if (clickedLinkData.view) {
	        view = $$1$1(clickedLinkData.view)[0].f7View;
	      } else {
	        view = clicked.parents('.view')[0] && clicked.parents('.view')[0].f7View;
	        if (view && view.params.linksView) {
	          if (typeof view.params.linksView === 'string') { view = $$1$1(view.params.linksView)[0].f7View; }
	          else if (view.params.linksView instanceof View) { view = view.params.linksView; }
	        }
	      }
	      if (!view) {
	        if (app.views.main) { view = app.views.main; }
	      }
	      if (!view || !view.router) { return; }
	      if (clickedLink.hasClass('back')) { view.router.back(url, clickedLinkData); }
	      else { view.router.navigate(url, clickedLinkData); }
	    }
	  }

	  app.on('click', handleClicks);

	  // Prevent scrolling on overlays
	  function preventScrolling(e) {
	    e.preventDefault();
	  }
	  if (Support.touch && !Device.android) {
	    var activeListener = Support.passiveListener ? { passive: false, capture: false } : false;
	    $$1$1(document).on((app.params.fastClicks ? 'touchstart' : 'touchmove'), '.panel-backdrop, .dialog-backdrop, .preloader-backdrop, .popup-backdrop, .searchbar-backdrop', preventScrolling, activeListener);
	  }
	}
	var ClicksModule = {
	  name: 'clicks',
	  params: {
	    clicks: {
	      // External Links
	      externalLinks: '.external',
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      initClicks(app);
	    },
	  },
	};

	var HistoryModule = {
	  name: 'history',
	  static: {
	    history: History,
	  },
	  on: {
	    init: function init() {
	      History.init(this);
	    },
	  },
	};

	var keyPrefix = 'f7storage-';
	var Storage = {
	  get: function get(key) {
	    return Utils.promise(function (resolve, reject) {
	      try {
	        var value = JSON.parse(window.localStorage.getItem(("" + keyPrefix + key)));
	        resolve(value);
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  set: function set(key, value) {
	    return Utils.promise(function (resolve, reject) {
	      try {
	        window.localStorage.setItem(("" + keyPrefix + key), JSON.stringify(value));
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  remove: function remove(key) {
	    return Utils.promise(function (resolve, reject) {
	      try {
	        window.localStorage.removeItem(("" + keyPrefix + key));
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  clear: function clear() {

	  },
	  length: function length() {

	  },
	  keys: function keys() {
	    return Utils.promise(function (resolve, reject) {
	      try {
	        var keys = Object.keys(window.localStorage)
	          .filter(function (keyName) { return keyName.indexOf(keyPrefix) === 0; })
	          .map(function (keyName) { return keyName.replace(keyPrefix, ''); });
	        resolve(keys);
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	  forEach: function forEach(callback) {
	    return Utils.promise(function (resolve, reject) {
	      try {
	        Object.keys(window.localStorage)
	          .filter(function (keyName) { return keyName.indexOf(keyPrefix) === 0; })
	          .forEach(function (keyName, index) {
	            var key = keyName.replace(keyPrefix, '');
	            Storage.get(key).then(function (value) {
	              callback(key, value, index);
	            });
	          });
	        resolve();
	      } catch (e) {
	        reject(e);
	      }
	    });
	  },
	};

	var StorageModule = {
	  name: 'storage',
	  static: {
	    Storage: Storage,
	    storage: Storage,
	  },
	};

	var Statusbar = {
	  hide: function hide() {
	    $$1$1('html').removeClass('with-statusbar');
	    if (Device.cordova && window.StatusBar) {
	      window.StatusBar.hide();
	    }
	  },
	  show: function show() {
	    if (Device.cordova && window.StatusBar) {
	      window.StatusBar.show();
	      Utils.nextTick(function () {
	        if (Device.needsStatusbarOverlay()) {
	          $$1$1('html').addClass('with-statusbar');
	        }
	      });
	      return;
	    }
	    $$1$1('html').addClass('with-statusbar');
	  },
	  onClick: function onClick() {
	    var app = this;
	    var pageContent;
	    if ($$1$1('.popup.modal-in').length > 0) {
	      // Check for opened popup
	      pageContent = $$1$1('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($$1$1('.panel.panel-active').length > 0) {
	      // Check for opened panel
	      pageContent = $$1$1('.panel.panel-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($$1$1('.views > .view.tab-active').length > 0) {
	      // View in tab bar app layout
	      pageContent = $$1$1('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else if ($$1$1('.views').length > 0) {
	      pageContent = $$1$1('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    } else {
	      pageContent = app.root.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
	    }

	    if (pageContent && pageContent.length > 0) {
	      // Check for tab
	      if (pageContent.hasClass('tab')) {
	        pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
	      }
	      if (pageContent.length > 0) { pageContent.scrollTop(0, 300); }
	    }
	  },
	  setIosTextColor: function setIosTextColor(color) {
	    if (Device.cordova && window.StatusBar) {
	      if (color === 'white') {
	        window.StatusBar.styleLightContent();
	      } else {
	        window.StatusBar.styleDefault();
	      }
	    }
	  },
	  setBackgroundColor: function setBackgroundColor(color) {
	    $$1$1('.statusbar').css('background-color', color);
	    if (Device.cordova && window.StatusBar) {
	      window.StatusBar.backgroundColorByHexString(color);
	    }
	  },
	  isVisible: function isVisible() {
	    if (Device.cordova && window.StatusBar) {
	      return window.StatusBar.isVisible;
	    }
	    return false;
	  },
	  iosOverlaysWebView: function iosOverlaysWebView(overlays) {
	    if ( overlays === void 0 ) overlays = true;

	    if (!Device.ios) { return; }
	    if (Device.cordova && window.StatusBar) {
	      window.StatusBar.overlaysWebView(overlays);
	      if (overlays) {
	        $$1$1('html').addClass('with-statusbar');
	      } else {
	        $$1$1('html').removeClass('with-statusbar');
	      }
	    }
	  },
	  checkOverlay: function checkOverlay() {
	    if (Device.needsStatusbarOverlay()) {
	      $$1$1('html').addClass('with-statusbar');
	    } else {
	      $$1$1('html').removeClass('with-statusbar');
	    }
	  },
	  init: function init() {
	    var app = this;
	    var params = app.params.statusbar;
	    if (!params.enabled) { return; }

	    if (params.overlay === 'auto') {
	      if (Device.needsStatusbarOverlay()) {
	        $$1$1('html').addClass('with-statusbar');
	      }

	      if (Device.ios && (Device.cordova || Device.webView)) {
	        if (window.orientation === 0) {
	          app.once('resize', function () {
	            Statusbar.checkOverlay();
	          });
	        }

	        $$1$1(document).on('resume', function () {
	          Statusbar.checkOverlay();
	        }, false);

	        app.on('orientationchange resize', function () {
	          Statusbar.checkOverlay();
	        });
	      }
	    } else if (params.overlay === true) {
	      $$1$1('html').addClass('with-statusbar');
	    } else if (params.overlay === false) {
	      $$1$1('html').removeClass('with-statusbar');
	    }

	    if (Device.cordova && window.StatusBar) {
	      if (params.scrollTopOnClick) {
	        $$1$1(window).on('statusTap', Statusbar.onClick.bind(app));
	      }
	      if (params.iosOverlaysWebView) {
	        window.StatusBar.overlaysWebView(true);
	      } else {
	        window.StatusBar.overlaysWebView(false);
	      }

	      if (params.iosTextColor === 'white') {
	        window.StatusBar.styleLightContent();
	      } else {
	        window.StatusBar.styleDefault();
	      }
	    }
	    if (params.iosBackgroundColor && app.theme === 'ios') {
	      Statusbar.setBackgroundColor(params.iosBackgroundColor);
	    }
	    if (params.materialBackgroundColor && app.theme === 'md') {
	      Statusbar.setBackgroundColor(params.materialBackgroundColor);
	    }
	  },
	};

	var Statusbar$1 = {
	  name: 'statusbar',
	  params: {
	    statusbar: {
	      enabled: true,
	      overlay: 'auto',
	      scrollTopOnClick: true,
	      iosOverlaysWebView: true,
	      iosTextColor: 'black',
	      iosBackgroundColor: null,
	      materialBackgroundColor: null,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      statusbar: {
	        checkOverlay: Statusbar.checkOverlay,
	        hide: Statusbar.hide,
	        show: Statusbar.show,
	        iosOverlaysWebView: Statusbar.iosOverlaysWebView,
	        setIosTextColor: Statusbar.setIosTextColor,
	        setBackgroundColor: Statusbar.setBackgroundColor,
	        isVisible: Statusbar.isVisible,
	        init: Statusbar.init.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      Statusbar.init.call(app);
	    },
	  },
	  clicks: {
	    '.statusbar': function onStatusbarClick() {
	      var app = this;
	      if (!app.params.statusbar.enabled) { return; }
	      if (!app.params.statusbar.scrollTopOnClick) { return; }
	      Statusbar.onClick.call(app);
	    },
	  },
	};

	function getCurrentView(app) {
	  var popoverView = $$1$1('.popover.modal-in .view');
	  var popupView = $$1$1('.popup.modal-in .view');
	  var panelView = $$1$1('.panel.panel-active .view');
	  var appViews = $$1$1('.views');
	  if (appViews.length === 0) { appViews = app.root; }
	  // Find active view as tab
	  var appView = appViews.children('.view');
	  // Propably in tabs or split view
	  if (appView.length > 1) {
	    if (appView.hasClass('tab')) {
	      // Tabs
	      appView = appViews.children('.view.tab-active');
	    } else {
	      // Split View, leave appView intact
	    }
	  }
	  if (popoverView.length > 0 && popoverView[0].f7View) { return popoverView[0].f7View; }
	  if (popupView.length > 0 && popupView[0].f7View) { return popupView[0].f7View; }
	  if (panelView.length > 0 && panelView[0].f7View) { return panelView[0].f7View; }
	  if (appView.length > 0) {
	    if (appView.length === 1 && appView[0].f7View) { return appView[0].f7View; }
	    if (appView.length > 1) {
	      return app.views.main;
	    }
	  }
	  return undefined;
	}

	var View$2 = {
	  name: 'view',
	  params: {
	    view: {
	      name: undefined,
	      main: false,
	      router: true,
	      linksView: null,
	      stackPages: false,
	      xhrCache: true,
	      xhrCacheIgnore: [],
	      xhrCacheIgnoreGetParameters: false,
	      xhrCacheDuration: 1000 * 60 * 10, // Ten minutes
	      preloadPreviousPage: true,
	      uniqueHistory: false,
	      uniqueHistoryIgnoreGetParameters: false,
	      allowDuplicateUrls: false,
	      reloadPages: false,
	      removeElements: true,
	      removeElementsWithTimeout: false,
	      removeElementsTimeout: 0,
	      restoreScrollTopOnBack: true,
	      unloadTabContent: true,
	      passRouteQueryToRequest: true,
	      passRouteParamsToRequest: false,
	      // Swipe Back
	      iosSwipeBack: true,
	      iosSwipeBackAnimateShadow: true,
	      iosSwipeBackAnimateOpacity: true,
	      iosSwipeBackActiveArea: 30,
	      iosSwipeBackThreshold: 0,
	      // Push State
	      pushState: false,
	      pushStateRoot: undefined,
	      pushStateAnimate: true,
	      pushStateAnimateOnLoad: false,
	      pushStateSeparator: '#!',
	      pushStateOnLoad: true,
	      // Animate Pages
	      animate: true,
	      animateWithJS: false,
	      // iOS Dynamic Navbar
	      iosDynamicNavbar: true,
	      iosSeparateDynamicNavbar: true,
	      // Animate iOS Navbar Back Icon
	      iosAnimateNavbarBackIcon: true,
	      // Delays
	      iosPageLoadDelay: 0,
	      materialPageLoadDelay: 0,
	    },
	  },
	  static: {
	    View: View,
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      views: Utils.extend([], {
	        create: function create(el, params) {
	          return new View(app, el, params);
	        },
	        get: function get(viewEl) {
	          var $viewEl = $$1$1(viewEl);
	          if ($viewEl.length && $viewEl[0].f7View) { return $viewEl[0].f7View; }
	          return undefined;
	        },
	      }),
	    });
	    Object.defineProperty(app.views, 'current', {
	      enumerable: true,
	      configurable: true,
	      get: function get() {
	        return getCurrentView(app);
	      },
	    });
	    // Alias
	    app.view = app.views;
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      $$1$1('.view-init').each(function (index, viewEl) {
	        if (viewEl.f7View) { return; }
	        var viewParams = $$1$1(viewEl).dataset();
	        app.views.create(viewEl, viewParams);
	      });
	    },
	    modalOpen: function modalOpen(modal) {
	      var app = this;
	      modal.$el.find('.view-init').each(function (index, viewEl) {
	        if (viewEl.f7View) { return; }
	        var viewParams = $$1$1(viewEl).dataset();
	        app.views.create(viewEl, viewParams);
	      });
	    },
	    modalBeforeDestroy: function modalBeforeDestroy(modal) {
	      if (!modal || !modal.$el) { return; }
	      modal.$el.find('.view-init').each(function (index, viewEl) {
	        var view = viewEl.f7View;
	        if (!view) { return; }
	        view.destroy();
	      });
	    },
	  },
	};

	var Navbar = {
	  size: function size(el) {
	    var app = this;
	    if (app.theme !== 'ios') { return; }
	    var $el = $$1$1(el);
	    if ($el.hasClass('navbar')) {
	      $el = $el.children('.navbar-inner').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	      return;
	    }
	    if (
	      $el.hasClass('stacked') ||
	      $el.parents('.stacked').length > 0 ||
	      $el.parents('.tab:not(.tab-active)').length > 0 ||
	      $el.parents('.popup:not(.modal-in)').length > 0
	    ) {
	      return;
	    }
	    var $viewEl = $el.parents('.view').eq(0);
	    var left = app.rtl ? $el.children('.right') : $el.children('.left');
	    var right = app.rtl ? $el.children('.left') : $el.children('.right');
	    var title = $el.children('.title');
	    var subnavbar = $el.children('.subnavbar');
	    var noLeft = left.length === 0;
	    var noRight = right.length === 0;
	    var leftWidth = noLeft ? 0 : left.outerWidth(true);
	    var rightWidth = noRight ? 0 : right.outerWidth(true);
	    var titleWidth = title.outerWidth(true);
	    var navbarStyles = $el.styles();
	    var navbarWidth = $el[0].offsetWidth;
	    var navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
	    var isPrevious = $el.hasClass('navbar-previous');
	    var sliding = $el.hasClass('sliding');

	    var router;
	    var dynamicNavbar;
	    var separateNavbar;
	    var separateNavbarRightOffset = 0;
	    var separateNavbarLeftOffset = 0;

	    if ($viewEl.length > 0 && $viewEl[0].f7View) {
	      router = $viewEl[0].f7View.router;
	      dynamicNavbar = router && router.dynamicNavbar;
	      separateNavbar = router && router.separateNavbar;
	      if (!separateNavbar) {
	        separateNavbarRightOffset = navbarWidth;
	        separateNavbarLeftOffset = navbarWidth / 5;
	      }
	    }

	    var currLeft;
	    var diff;
	    if (noRight) {
	      currLeft = navbarInnerWidth - titleWidth;
	    }
	    if (noLeft) {
	      currLeft = 0;
	    }
	    if (!noLeft && !noRight) {
	      currLeft = ((navbarInnerWidth - rightWidth - titleWidth) + leftWidth) / 2;
	    }
	    var requiredLeft = (navbarInnerWidth - titleWidth) / 2;
	    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
	      if (requiredLeft < leftWidth) {
	        requiredLeft = leftWidth;
	      }
	      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
	        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
	      }
	      diff = requiredLeft - currLeft;
	    } else {
	      diff = 0;
	    }

	    // RTL inverter
	    var inverter = app.rtl ? -1 : 1;

	    if (dynamicNavbar) {
	      if (title.hasClass('sliding') || (title.length > 0 && sliding)) {
	        var titleLeftOffset = (-(currLeft + diff) * inverter) + separateNavbarLeftOffset;
	        var titleRightOffset = ((navbarInnerWidth - currLeft - diff - titleWidth) * inverter) - separateNavbarRightOffset;

	        if (isPrevious) {
	          if (router && router.params.iosAnimateNavbarBackIcon) {
	            var activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');
	            if (activeNavbarBackLink.length > 0) {
	              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
	            }
	          }
	        }
	        title[0].f7NavbarLeftOffset = titleLeftOffset;
	        title[0].f7NavbarRightOffset = titleRightOffset;
	      }
	      if (!noLeft && (left.hasClass('sliding') || sliding)) {
	        if (app.rtl) {
	          left[0].f7NavbarLeftOffset = (-(navbarInnerWidth - left[0].offsetWidth) / 2) * inverter;
	          left[0].f7NavbarRightOffset = leftWidth * inverter;
	        } else {
	          left[0].f7NavbarLeftOffset = -leftWidth + separateNavbarLeftOffset;
	          left[0].f7NavbarRightOffset = ((navbarInnerWidth - left[0].offsetWidth) / 2) - separateNavbarRightOffset;
	          if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
	            left[0].f7NavbarRightOffset -= left.find('.back .icon')[0].offsetWidth;
	          }
	        }
	      }
	      if (!noRight && (right.hasClass('sliding') || sliding)) {
	        if (app.rtl) {
	          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
	          right[0].f7NavbarRightOffset = ((navbarInnerWidth - right[0].offsetWidth) / 2) * inverter;
	        } else {
	          right[0].f7NavbarLeftOffset = (-(navbarInnerWidth - right[0].offsetWidth) / 2) + separateNavbarLeftOffset;
	          right[0].f7NavbarRightOffset = rightWidth - separateNavbarRightOffset;
	        }
	      }
	      if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
	        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : (-subnavbar[0].offsetWidth + separateNavbarLeftOffset);
	        subnavbar[0].f7NavbarRightOffset = (-subnavbar[0].f7NavbarLeftOffset - separateNavbarRightOffset) + separateNavbarLeftOffset;
	      }
	    }

	    // Title left
	    if (app.params.navbar.iosCenterTitle) {
	      var titleLeft = diff;
	      if (app.rtl && noLeft && noRight && title.length > 0) { titleLeft = -titleLeft; }
	      title.css({ left: (titleLeft + "px") });
	    }
	  },
	  hide: function hide(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var $el = $$1$1(el);
	    if ($el.hasClass('navbar-inner')) { $el = $el.parents('.navbar'); }
	    if (!$el.length) { return; }
	    if ($el.hasClass('navbar-hidden')) { return; }
	    var className = "navbar-hidden" + (animate ? ' navbar-transitioning' : '');
	    $el.transitionEnd(function () {
	      $el.removeClass('navbar-transitioning');
	    });
	    $el.addClass(className);
	  },
	  show: function show(el, animate) {
	    if ( el === void 0 ) el = '.navbar-hidden';
	    if ( animate === void 0 ) animate = true;

	    var $el = $$1$1(el);
	    if ($el.hasClass('navbar-inner')) { $el = $el.parents('.navbar'); }
	    if (!$el.length) { return; }
	    if (!$el.hasClass('navbar-hidden')) { return; }
	    if (animate) {
	      $el.addClass('navbar-transitioning');
	      $el.transitionEnd(function () {
	        $el.removeClass('navbar-transitioning');
	      });
	    }
	    $el.removeClass('navbar-hidden');
	  },
	  getElByPage: function getElByPage(page) {
	    var $pageEl;
	    var $navbarEl;
	    var pageData;
	    if (page.$navbarEl || page.$el) {
	      pageData = page;
	      $pageEl = page.$el;
	    } else {
	      $pageEl = $$1$1(page);
	      if ($pageEl.length > 0) { pageData = $pageEl[0].f7Page; }
	    }
	    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
	      $navbarEl = pageData.$navbarEl;
	    } else if ($pageEl) {
	      $navbarEl = $pageEl.children('.navbar').children('.navbar-inner');
	    }
	    if (!$navbarEl || ($navbarEl && $navbarEl.length === 0)) { return undefined; }
	    return $navbarEl[0];
	  },
	  getPageByEl: function getPageByEl(navbarInnerEl) {
	    var $navbarInnerEl = $$1$1(navbarInnerEl);
	    if ($navbarInnerEl.hasClass('navbar')) {
	      $navbarInnerEl = $navbarInnerEl.find('.navbar-inner');
	      if ($navbarInnerEl.length > 1) { return undefined; }
	    }
	    return $navbarInnerEl[0].f7Page;
	  },
	  initHideNavbarOnScroll: function initHideNavbarOnScroll(pageEl, navbarInnerEl) {
	    var app = this;
	    var $pageEl = $$1$1(pageEl);
	    var $navbarEl = $$1$1(navbarInnerEl || app.navbar.getElByPage(pageEl)).closest('.navbar');

	    var previousScrollTop;
	    var currentScrollTop;

	    var scrollHeight;
	    var offsetHeight;
	    var reachEnd;
	    var action;
	    var navbarHidden;
	    function handleScroll() {
	      var scrollContent = this;
	      if ($pageEl.hasClass('page-previous')) { return; }
	      currentScrollTop = scrollContent.scrollTop;
	      scrollHeight = scrollContent.scrollHeight;
	      offsetHeight = scrollContent.offsetHeight;
	      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
	      navbarHidden = $navbarEl.hasClass('navbar-hidden');

	      if (reachEnd) {
	        if (app.params.navbar.showOnPageScrollEnd) {
	          action = 'show';
	        }
	      } else if (previousScrollTop > currentScrollTop) {
	        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= 44) {
	          action = 'show';
	        } else {
	          action = 'hide';
	        }
	      } else if (currentScrollTop > 44) {
	        action = 'hide';
	      } else {
	        action = 'show';
	      }

	      if (action === 'show' && navbarHidden) {
	        app.navbar.show($navbarEl);
	        navbarHidden = false;
	      } else if (action === 'hide' && !navbarHidden) {
	        app.navbar.hide($navbarEl);
	        navbarHidden = true;
	      }

	      previousScrollTop = currentScrollTop;
	    }
	    $pageEl.on('scroll', '.page-content', handleScroll, true);
	    $pageEl[0].f7ScrollNavbarHandler = handleScroll;
	  },
	};
	var Navbar$1 = {
	  name: 'navbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      navbar: {
	        size: Navbar.size.bind(app),
	        hide: Navbar.hide.bind(app),
	        show: Navbar.show.bind(app),
	        getElByPage: Navbar.getElByPage.bind(app),
	        initHideNavbarOnScroll: Navbar.initHideNavbarOnScroll.bind(app),
	      },
	    });
	  },
	  params: {
	    navbar: {
	      scrollTopOnTitleClick: true,
	      iosCenterTitle: true,
	      hideOnPageScroll: false,
	      showOnPageScrollEnd: true,
	      showOnPageScrollTop: true,
	    },
	  },
	  on: {
	    'panelBreakpoint resize': function onResize() {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      $$1$1('.navbar').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      if (page.$el[0].f7ScrollNavbarHandler) {
	        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollNavbarHandler, true);
	      }
	    },
	    pageBeforeIn: function pageBeforeIn(page) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      var $navbarEl;
	      var view = page.$el.parents('.view')[0].f7View;
	      var navbarInnerEl = app.navbar.getElByPage(page);
	      if (!navbarInnerEl) {
	        $navbarEl = page.$el.parents('.view').children('.navbar');
	      } else {
	        $navbarEl = $$1$1(navbarInnerEl).parents('.navbar');
	      }
	      if (page.$el.hasClass('no-navbar') || (view.router.dynamicNavbar && !navbarInnerEl)) {
	        var animate = !!(page.pageFrom && page.router.history.length > 0);
	        app.navbar.hide($navbarEl, animate);
	      } else {
	        app.navbar.show($navbarEl);
	      }
	    },
	    pageReinit: function pageReinit(page) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      var $navbarEl = $$1$1(app.navbar.getElByPage(page));
	      if (!$navbarEl || $navbarEl.length === 0) { return; }
	      app.navbar.size($navbarEl);
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      var $navbarEl = $$1$1(app.navbar.getElByPage(page));
	      if (!$navbarEl || $navbarEl.length === 0) { return; }
	      if (app.theme === 'ios') {
	        app.navbar.size($navbarEl);
	      }
	      if (
	        app.params.navbar.hideOnPageScroll ||
	        page.$el.find('.hide-navbar-on-scroll').length ||
	        page.$el.hasClass('hide-navbar-on-scroll') ||
	        page.$el.find('.hide-bars-on-scroll').length ||
	        page.$el.hasClass('hide-bars-on-scroll')
	      ) {
	        if (
	          page.$el.find('.keep-navbar-on-scroll').length ||
	          page.$el.hasClass('keep-navbar-on-scroll') ||
	          page.$el.find('.keep-bars-on-scroll').length ||
	          page.$el.hasClass('keep-bars-on-scroll')
	        ) {
	          return;
	        }
	        app.navbar.initHideNavbarOnScroll(page.el, $navbarEl[0]);
	      }
	    },
	    modalOpen: function modalOpen(modal) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      modal.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    panelOpen: function panelOpen(panel) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    panelSwipeOpen: function panelSwipeOpen(panel) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      panel.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	    tabShow: function tabShow(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each(function (index, navbarEl) {
	        app.navbar.size(navbarEl);
	      });
	    },
	  },
	  clicks: {
	    '.navbar .title': function onTitleClick($clickedEl) {
	      var app = this;
	      if (!app.params.navbar.scrollTopOnTitleClick) { return; }
	      if ($clickedEl.closest('a').length > 0) {
	        return;
	      }
	      var pageContent;
	      // Find active page
	      var navbar = $clickedEl.parents('.navbar');

	      // Static Layout
	      pageContent = navbar.parents('.page-content');

	      if (pageContent.length === 0) {
	        // Fixed Layout
	        if (navbar.parents('.page').length > 0) {
	          pageContent = navbar.parents('.page').find('.page-content');
	        }
	        // Through Layout
	        if (pageContent.length === 0) {
	          if (navbar.nextAll('.page-current:not(.stacked)').length > 0) {
	            pageContent = navbar.nextAll('.page-current:not(.stacked)').find('.page-content');
	          }
	        }
	      }
	      if (pageContent && pageContent.length > 0) {
	        // Check for tab
	        if (pageContent.hasClass('tab')) {
	          pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
	        }
	        if (pageContent.length > 0) { pageContent.scrollTop(0, 300); }
	      }
	    },
	  },
	};

	var Toolbar = {
	  setHighlight: function setHighlight(tabbarEl) {
	    var app = this;
	    if (app.theme !== 'md') { return; }

	    var $tabbarEl = $$1$1(tabbarEl);

	    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) { return; }

	    if ($tabbarEl.find('.tab-link-highlight').length === 0) {
	      $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
	    }

	    var $highlightEl = $tabbarEl.find('.tab-link-highlight');
	    var $activeLink = $tabbarEl.find('.tab-link-active');
	    var highlightWidth;
	    var highlightTranslate;

	    if ($tabbarEl.hasClass('tabbar-scrollable')) {
	      highlightWidth = ($activeLink[0].offsetWidth) + "px";
	      highlightTranslate = ($activeLink[0].offsetLeft) + "px";
	    } else {
	      var activeIndex = $activeLink.index();
	      var tabLinksCount = $tabbarEl.find('.tab-link').length;
	      highlightWidth = (100 / tabLinksCount) + "%";
	      highlightTranslate = ((app.rtl ? -activeIndex : activeIndex) * 100) + "%";
	    }

	    $highlightEl
	      .css('width', highlightWidth)
	      .transform(("translate3d(" + highlightTranslate + ",0,0)"));
	  },
	  init: function init(tabbarEl) {
	    var app = this;
	    app.toolbar.setHighlight(tabbarEl);
	  },
	  hide: function hide(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var $el = $$1$1(el);
	    if ($el.hasClass('toolbar-hidden')) { return; }
	    var className = "toolbar-hidden" + (animate ? ' toolbar-transitioning' : '');
	    $el.transitionEnd(function () {
	      $el.removeClass('toolbar-transitioning');
	    });
	    $el.addClass(className);
	  },
	  show: function show(el, animate) {
	    if ( animate === void 0 ) animate = true;

	    var $el = $$1$1(el);
	    if (!$el.hasClass('toolbar-hidden')) { return; }
	    if (animate) {
	      $el.addClass('toolbar-transitioning');
	      $el.transitionEnd(function () {
	        $el.removeClass('toolbar-transitioning');
	      });
	    }
	    $el.removeClass('toolbar-hidden');
	  },
	  initHideToolbarOnScroll: function initHideToolbarOnScroll(pageEl) {
	    var app = this;
	    var $pageEl = $$1$1(pageEl);
	    var $toolbarEl = $pageEl.parents('.view').children('.toolbar');
	    if ($toolbarEl.length === 0) {
	      $toolbarEl = $pageEl.find('.toolbar');
	    }
	    if ($toolbarEl.length === 0) {
	      $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
	    }
	    if ($toolbarEl.length === 0) {
	      return;
	    }

	    var previousScrollTop;
	    var currentScrollTop;

	    var scrollHeight;
	    var offsetHeight;
	    var reachEnd;
	    var action;
	    var toolbarHidden;
	    function handleScroll() {
	      var scrollContent = this;
	      if ($pageEl.hasClass('page-previous')) { return; }
	      currentScrollTop = scrollContent.scrollTop;
	      scrollHeight = scrollContent.scrollHeight;
	      offsetHeight = scrollContent.offsetHeight;
	      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
	      toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

	      if (reachEnd) {
	        if (app.params.toolbar.showOnPageScrollEnd) {
	          action = 'show';
	        }
	      } else if (previousScrollTop > currentScrollTop) {
	        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
	          action = 'show';
	        } else {
	          action = 'hide';
	        }
	      } else if (currentScrollTop > 44) {
	        action = 'hide';
	      } else {
	        action = 'show';
	      }

	      if (action === 'show' && toolbarHidden) {
	        app.toolbar.show($toolbarEl);
	        toolbarHidden = false;
	      } else if (action === 'hide' && !toolbarHidden) {
	        app.toolbar.hide($toolbarEl);
	        toolbarHidden = true;
	      }

	      previousScrollTop = currentScrollTop;
	    }
	    $pageEl.on('scroll', '.page-content', handleScroll, true);
	    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
	  },
	};
	var Toolbar$1 = {
	  name: 'toolbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      toolbar: {
	        hide: Toolbar.hide.bind(app),
	        show: Toolbar.show.bind(app),
	        setHighlight: Toolbar.setHighlight.bind(app),
	        initHideToolbarOnScroll: Toolbar.initHideToolbarOnScroll.bind(app),
	        init: Toolbar.init.bind(app),
	      },
	    });
	  },
	  params: {
	    toolbar: {
	      hideOnPageScroll: false,
	      showOnPageScrollEnd: true,
	      showOnPageScrollTop: true,
	    },
	  },
	  on: {
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      if (page.$el[0].f7ScrollToolbarHandler) {
	        page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
	      }
	    },
	    pageBeforeIn: function pageBeforeIn(page) {
	      var app = this;
	      if (app.theme !== 'ios') { return; }
	      var $toolbarEl = page.$el.parents('.view').children('.toolbar');
	      if ($toolbarEl.length === 0) {
	        $toolbarEl = page.$el.find('.toolbar');
	      }
	      if ($toolbarEl.length === 0) {
	        $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
	      }
	      if ($toolbarEl.length === 0) {
	        return;
	      }
	      if (page.$el.hasClass('no-toolbar')) {
	        app.toolbar.hide($toolbarEl);
	      } else {
	        app.toolbar.show($toolbarEl);
	      }
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.tabbar, .tabbar-labels').each(function (index, tabbarEl) {
	        app.toolbar.init(tabbarEl);
	      });
	      if (
	        app.params.toolbar.hideOnPageScroll ||
	        page.$el.find('.hide-toolbar-on-scroll').length ||
	        page.$el.hasClass('hide-toolbar-on-scroll') ||
	        page.$el.find('.hide-bars-on-scroll').length ||
	        page.$el.hasClass('hide-bars-on-scroll')
	      ) {
	        if (
	          page.$el.find('.keep-toolbar-on-scroll').length ||
	          page.$el.hasClass('keep-toolbar-on-scroll') ||
	          page.$el.find('.keep-bars-on-scroll').length ||
	          page.$el.hasClass('keep-bars-on-scroll')
	        ) {
	          return;
	        }
	        app.toolbar.initHideToolbarOnScroll(page.el);
	      }
	    },
	    init: function init() {
	      var app = this;
	      app.root.find('.tabbar, .tabbar-labels').each(function (index, tabbarEl) {
	        app.toolbar.init(tabbarEl);
	      });
	    },
	  },
	};

	var Subnavbar = {
	  name: 'subnavbar',
	  on: {
	    pageInit: function pageInit(page) {
	      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
	        page.$el.addClass('page-with-subnavbar');
	      }
	      if (page.$el.find('.subnavbar').length) {
	        page.$el.addClass('page-with-subnavbar');
	      }
	    },
	  },
	};

	var TouchRipple$1 = function TouchRipple($el, x, y) {
	  var ripple = this;
	  if (!$el) { return undefined; }
	  var box = $el[0].getBoundingClientRect();
	  var center = {
	    x: x - box.left,
	    y: y - box.top,
	  };
	  var width = box.width;
	  var height = box.height;
	  var diameter = Math.max((Math.pow( ((Math.pow( height, 2 )) + (Math.pow( width, 2 ))), 0.5 )), 48);

	  ripple.$rippleWaveEl = $$1$1(("<div class=\"ripple-wave\" style=\"width: " + diameter + "px; height: " + diameter + "px; margin-top:-" + (diameter / 2) + "px; margin-left:-" + (diameter / 2) + "px; left:" + (center.x) + "px; top:" + (center.y) + "px;\"></div>"));

	  $el.prepend(ripple.$rippleWaveEl);

	  /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	  ripple._clientLeft = ripple.$rippleWaveEl[0].clientLeft;

	  ripple.rippleTransform = "translate3d(" + (-center.x + (width / 2)) + "px, " + (-center.y + (height / 2)) + "px, 0) scale(1)";

	  ripple.$rippleWaveEl.transform(ripple.rippleTransform);

	  return ripple;
	};
	TouchRipple$1.prototype.onRemove = function onRemove () {
	  var ripple = this;
	  ripple.$rippleWaveEl.remove();
	  Object.keys(ripple).forEach(function (key) {
	    ripple[key] = null;
	    delete ripple[key];
	  });
	  ripple = null;
	};
	TouchRipple$1.prototype.remove = function remove () {
	  var ripple = this;
	  if (ripple.removing) { return; }
	  var $rippleWaveEl = this.$rippleWaveEl;
	  var rippleTransform = this.rippleTransform;
	  var removeTimeout = Utils.nextTick(function () {
	    ripple.onRemove();
	  }, 400);
	  ripple.removing = true;
	  $rippleWaveEl
	    .addClass('ripple-wave-fill')
	    .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'))
	    .transitionEnd(function () {
	      clearTimeout(removeTimeout);
	      Utils.nextFrame(function () {
	        $rippleWaveEl
	          .addClass('ripple-wave-out')
	          .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'));

	        removeTimeout = Utils.nextTick(function () {
	          ripple.onRemove();
	        }, 700);

	        $rippleWaveEl.transitionEnd(function () {
	          clearTimeout(removeTimeout);
	          ripple.onRemove();
	        });
	      });
	    });
	};

	var TouchRipple = {
	  name: 'touch-ripple',
	  static: {
	    TouchRipple: TouchRipple$1,
	  },
	  create: function create() {
	    var app = this;
	    app.touchRipple = {
	      create: function create() {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        return new (Function.prototype.bind.apply( TouchRipple$1, [ null ].concat( args) ));
	      },
	    };
	  },
	};

	var openedModals = [];
	var dialogsQueue = [];
	function clearDialogsQueue() {
	  if (dialogsQueue.length === 0) { return; }
	  var dialog = dialogsQueue.shift();
	  dialog.open();
	}
	var Modal$1 = (function (Framework7Class$$1) {
	  function Modal(app, params) {
	    Framework7Class$$1.call(this, params, [app]);

	    var modal = this;

	    var defaults = {};

	    // Extend defaults with modules params
	    modal.useModulesParams(defaults);

	    modal.params = Utils.extend(defaults, params);

	    // Install Modules
	    modal.useModules();

	    return this;
	  }

	  if ( Framework7Class$$1 ) Modal.__proto__ = Framework7Class$$1;
	  Modal.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Modal.prototype.constructor = Modal;
	  Modal.prototype.onOpen = function onOpen () {
	    var modal = this;
	    openedModals.push(modal);
	    $$1$1('html').addClass(("with-modal-" + (modal.type.toLowerCase())));
	    modal.$el.trigger(("modal:open " + (modal.type.toLowerCase()) + ":open"), modal);
	    modal.emit(("local::open modalOpen " + (modal.type) + "Open"), modal);
	  };
	  Modal.prototype.onOpened = function onOpened () {
	    var modal = this;
	    modal.$el.trigger(("modal:opened " + (modal.type.toLowerCase()) + ":opened"), modal);
	    modal.emit(("local::opened modalOpened " + (modal.type) + "Opened"), modal);
	  };
	  Modal.prototype.onClose = function onClose () {
	    var modal = this;
	    if (!modal.type || !modal.$el) { return; }
	    openedModals.splice(openedModals.indexOf(modal), 1);
	    $$1$1('html').removeClass(("with-modal-" + (modal.type.toLowerCase())));
	    modal.$el.trigger(("modal:close " + (modal.type.toLowerCase()) + ":close"), modal);
	    modal.emit(("local::close modalClose " + (modal.type) + "Close"), modal);
	  };
	  Modal.prototype.onClosed = function onClosed () {
	    var modal = this;
	    if (!modal.type || !modal.$el) { return; }
	    modal.$el.removeClass('modal-out');
	    modal.$el.hide();
	    modal.$el.trigger(("modal:closed " + (modal.type.toLowerCase()) + ":closed"), modal);
	    modal.emit(("local::closed modalClosed " + (modal.type) + "Closed"), modal);
	  };
	  Modal.prototype.open = function open (animateModal) {
	    var modal = this;
	    var app = modal.app;
	    var $el = modal.$el;
	    var $backdropEl = modal.$backdropEl;
	    var type = modal.type;
	    var animate = true;
	    if (typeof animateModal !== 'undefined') { animate = animateModal; }
	    else if (typeof modal.params.animate !== 'undefined') {
	      animate = modal.params.animate;
	    }

	    if (!$el || $el.hasClass('modal-in')) {
	      return modal;
	    }

	    if (type === 'dialog' && app.params.modal.queueDialogs) {
	      var pushToQueue;
	      if ($$1$1('.dialog.modal-in').length > 0) {
	        pushToQueue = true;
	      } else if (openedModals.length > 0) {
	        openedModals.forEach(function (openedModal) {
	          if (openedModal.type === 'dialog') { pushToQueue = true; }
	        });
	      }
	      if (pushToQueue) {
	        dialogsQueue.push(modal);
	        return modal;
	      }
	    }

	    var $modalParentEl = $el.parent();
	    var wasInDom = $el.parents(document).length > 0;
	    if (app.params.modal.moveToRoot && !$modalParentEl.is(app.root)) {
	      app.root.append($el);
	      modal.once((type + "Closed"), function () {
	        if (wasInDom) {
	          $modalParentEl.append($el);
	        } else {
	          $el.remove();
	        }
	      });
	    }
	    // Show Modal
	    $el.show();

	    // Set Dialog offset
	    if (type === 'dialog') {
	      $el.css({
	        marginTop: ((-Math.round($el.outerHeight() / 2)) + "px"),
	      });
	    }

	    // Emit open
	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    modal._clientLeft = $el[0].clientLeft;

	    // Backdrop
	    if ($backdropEl) {
	      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
	      $backdropEl.addClass('backdrop-in');
	    }
	    // Modal
	    function transitionEnd() {
	      if ($el.hasClass('modal-out')) {
	        modal.onClosed();
	      } else {
	        modal.onOpened();
	      }
	    }
	    if (animate) {
	      $el
	        .animationEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .transitionEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .removeClass('modal-out not-animated')
	        .addClass('modal-in');
	      modal.onOpen();
	    } else {
	      $el.removeClass('modal-out').addClass('modal-in not-animated');
	      modal.onOpen();
	      modal.onOpened();
	    }

	    return modal;
	  };
	  Modal.prototype.close = function close (animateModal) {
	    var modal = this;
	    var $el = modal.$el;
	    var $backdropEl = modal.$backdropEl;

	    var animate = true;
	    if (typeof animateModal !== 'undefined') { animate = animateModal; }
	    else if (typeof modal.params.animate !== 'undefined') {
	      animate = modal.params.animate;
	    }

	    if (!$el || !$el.hasClass('modal-in')) {
	      return modal;
	    }

	    // backdrop
	    if ($backdropEl) {
	      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
	      $backdropEl.removeClass('backdrop-in');
	    }

	    // Modal
	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    function transitionEnd() {
	      if ($el.hasClass('modal-out')) {
	        modal.onClosed();
	      } else {
	        modal.onOpened();
	      }
	    }
	    if (animate) {
	      $el
	        .animationEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .transitionEnd(function () {
	          transitionEnd();
	        });
	      $el
	        .removeClass('modal-in')
	        .addClass('modal-out');
	      // Emit close
	      modal.onClose();
	    } else {
	      $el
	        .addClass('not-animated')
	        .removeClass('modal-in')
	        .addClass('modal-out');
	      // Emit close
	      modal.onClose();
	      modal.onClosed();
	    }

	    if (modal.type === 'dialog') {
	      clearDialogsQueue();
	    }

	    return modal;
	  };
	  Modal.prototype.destroy = function destroy () {
	    var modal = this;
	    if (modal.destroyed) { return; }
	    modal.emit(("local::beforeDestroy modalBeforeDestroy " + (modal.type) + "BeforeDestroy"), modal);
	    if (modal.$el) {
	      modal.$el.trigger(("modal:beforedestroy " + (modal.type.toLowerCase()) + ":beforedestroy"), modal);
	      if (modal.$el.length && modal.$el[0].f7Modal) {
	        delete modal.$el[0].f7Modal;
	      }
	    }
	    Utils.deleteProps(modal);
	    modal.destroyed = true;
	  };

	  return Modal;
	}(Framework7Class));

	var CustomModal = (function (Modal) {
	  function CustomModal(app, params) {
	    var extendedParams = Utils.extend({
	      backdrop: true,
	      closeByBackdropClick: true,
	      on: {},
	    }, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var customModal = this;

	    customModal.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!customModal.params.el) {
	      $el = $$1$1(customModal.params.content);
	    } else {
	      $el = $$1$1(customModal.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return customModal.destroy();
	    }
	    var $backdropEl;
	    if (customModal.params.backdrop) {
	      $backdropEl = app.root.children('.custom-modal-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="custom-modal-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    function handleClick(e) {
	      if (!customModal || customModal.destroyed) { return; }
	      if ($backdropEl && e.target === $backdropEl[0]) {
	        customModal.close();
	      }
	    }

	    customModal.on('customModalOpened', function () {
	      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
	        app.on('click', handleClick);
	      }
	    });
	    customModal.on('customModalClose', function () {
	      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
	        app.off('click', handleClick);
	      }
	    });

	    Utils.extend(customModal, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'customModal',
	    });

	    $el[0].f7Modal = customModal;

	    return customModal;
	  }

	  if ( Modal ) CustomModal.__proto__ = Modal;
	  CustomModal.prototype = Object.create( Modal && Modal.prototype );
	  CustomModal.prototype.constructor = CustomModal;

	  return CustomModal;
	}(Modal$1));

	var Modal = {
	  name: 'modal',
	  static: {
	    Modal: Modal$1,
	    CustomModal: CustomModal,
	  },
	  create: function create() {
	    var app = this;
	    app.customModal = {
	      create: function create(params) {
	        return new CustomModal(app, params);
	      },
	    };
	  },
	  params: {
	    modal: {
	      moveToRoot: true,
	      queueDialogs: true,
	    },
	  },
	};

	var Dialog$1 = (function (Modal) {
	  function Dialog(app, params) {
	    var extendedParams = Utils.extend({
	      title: app.params.dialog.title,
	      text: undefined,
	      content: '',
	      buttons: [],
	      verticalButtons: false,
	      onClick: undefined,
	      cssClass: undefined,
	      on: {},
	    }, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var dialog = this;

	    var title = extendedParams.title;
	    var text = extendedParams.text;
	    var content = extendedParams.content;
	    var buttons = extendedParams.buttons;
	    var verticalButtons = extendedParams.verticalButtons;
	    var cssClass = extendedParams.cssClass;

	    dialog.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!dialog.params.el) {
	      var dialogClasses = ['dialog'];
	      if (buttons.length === 0) { dialogClasses.push('dialog-no-buttons'); }
	      if (buttons.length > 0) { dialogClasses.push(("dialog-buttons-" + (buttons.length))); }
	      if (verticalButtons) { dialogClasses.push('dialog-buttons-vertical'); }
	      if (cssClass) { dialogClasses.push(cssClass); }

	      var buttonsHTML = '';
	      if (buttons.length > 0) {
	        buttonsHTML = "\n          <div class=\"dialog-buttons\">\n            " + (buttons.map(function (button) { return ("\n              <span class=\"dialog-button" + (button.bold ? ' dialog-button-bold' : '') + (button.color ? (" color-" + (button.color)) : '') + (button.cssClass ? (" " + (button.cssClass)) : '') + "\">" + (button.text) + "</span>\n            "); }).join('')) + "\n          </div>\n        ";
	      }

	      var dialogHtml = "\n        <div class=\"" + (dialogClasses.join(' ')) + "\">\n          <div class=\"dialog-inner\">\n            " + (title ? ("<div class=\"dialog-title\">" + title + "</div>") : '') + "\n            " + (text ? ("<div class=\"dialog-text\">" + text + "</div>") : '') + "\n            " + content + "\n          </div>\n          " + buttonsHTML + "\n        </div>\n      ";
	      $el = $$1$1(dialogHtml);
	    } else {
	      $el = $$1$1(dialog.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return dialog.destroy();
	    }

	    var $backdropEl = app.root.children('.dialog-backdrop');
	    if ($backdropEl.length === 0) {
	      $backdropEl = $$1$1('<div class="dialog-backdrop"></div>');
	      app.root.append($backdropEl);
	    }

	    // Assign events
	    function buttonOnClick(e) {
	      var buttonEl = this;
	      var index = $$1$1(buttonEl).index();
	      var button = buttons[index];
	      if (button.onClick) { button.onClick(dialog, e); }
	      if (dialog.params.onClick) { dialog.params.onClick(dialog, index); }
	      if (button.close !== false) { dialog.close(); }
	    }
	    if (buttons && buttons.length > 0) {
	      dialog.on('open', function () {
	        $el.find('.dialog-button').each(function (index, buttonEl) {
	          $$1$1(buttonEl).on('click', buttonOnClick);
	        });
	      });
	      dialog.on('close', function () {
	        $el.find('.dialog-button').each(function (index, buttonEl) {
	          $$1$1(buttonEl).off('click', buttonOnClick);
	        });
	      });
	    }
	    Utils.extend(dialog, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl[0],
	      type: 'dialog',
	      setProgress: function setProgress(progress, duration) {
	        app.progressbar.set($el.find('.progressbar'), progress, duration);
	        return dialog;
	      },
	      setText: function setText(newText) {
	        var $textEl = $el.find('.dialog-text');
	        if ($textEl.length === 0) {
	          $textEl = $$1$1('<div class="dialog-text"></div>');
	          if (typeof title !== 'undefined') {
	            $textEl.insertAfter($el.find('.dialog-title'));
	          } else {
	            $el.find('.dialog-inner').prepend($textEl);
	          }
	        }
	        $textEl.html(newText);
	        dialog.params.text = newText;
	        return dialog;
	      },
	      setTitle: function setTitle(newTitle) {
	        var $titleEl = $el.find('.dialog-title');
	        if ($titleEl.length === 0) {
	          $titleEl = $$1$1('<div class="dialog-title"></div>');
	          $el.find('.dialog-inner').prepend($titleEl);
	        }
	        $titleEl.html(newTitle);
	        dialog.params.title = newTitle;
	        return dialog;
	      },
	    });

	    $el[0].f7Modal = dialog;

	    if (dialog.params.destroyOnClose) {
	      dialog.once('closed', function () {
	        setTimeout(function () {
	          dialog.destroy();
	        }, 0);
	      });
	    }

	    return dialog;
	  }

	  if ( Modal ) Dialog.__proto__ = Modal;
	  Dialog.prototype = Object.create( Modal && Modal.prototype );
	  Dialog.prototype.constructor = Dialog;

	  return Dialog;
	}(Modal$1));

	var ConstructorMethods = function (parameters) {
	  if ( parameters === void 0 ) parameters = {};

	  var defaultSelector = parameters.defaultSelector;
	  var constructor = parameters.constructor;
	  var domProp = parameters.domProp;
	  var app = parameters.app;
	  var addMethods = parameters.addMethods;
	  var methods = {
	    create: function create() {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      if (app) { return new (Function.prototype.bind.apply( constructor, [ null ].concat( [app], args) )); }
	      return new (Function.prototype.bind.apply( constructor, [ null ].concat( args) ));
	    },
	    get: function get(el) {
	      if ( el === void 0 ) el = defaultSelector;

	      if (el instanceof constructor) { return el; }
	      var $el = $$1$1(el);
	      if ($el.length === 0) { return undefined; }
	      return $el[0][domProp];
	    },
	    destroy: function destroy(el) {
	      var instance = methods.get(el);
	      if (instance && instance.destroy) { return instance.destroy(); }
	      return undefined;
	    },
	  };
	  if (addMethods && Array.isArray(addMethods)) {
	    addMethods.forEach(function (methodName) {
	      methods[methodName] = function (el) {
	        if ( el === void 0 ) el = defaultSelector;
	        var args = [], len = arguments.length - 1;
	        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

	        var instance = methods.get(el);
	        if (instance && instance[methodName]) { return instance[methodName].apply(instance, args); }
	        return undefined;
	      };
	    });
	  }
	  return methods;
	};

	var ModalMethods = function (parameters) {
	  if ( parameters === void 0 ) parameters = {};

	  var defaultSelector = parameters.defaultSelector;
	  var constructor = parameters.constructor;
	  var app = parameters.app;
	  var methods = Utils.extend(
	    ConstructorMethods({
	      defaultSelector: defaultSelector,
	      constructor: constructor,
	      app: app,
	      domProp: 'f7Modal',
	    }),
	    {
	      open: function open(el, animate) {
	        var $el = $$1$1(el);
	        var instance = $el[0].f7Modal;
	        if (!instance) { instance = new constructor(app, { el: $el }); }
	        return instance.open(animate);
	      },
	      close: function close(el, animate) {
	        if ( el === void 0 ) el = defaultSelector;

	        var $el = $$1$1(el);
	        if ($el.length === 0) { return undefined; }
	        var instance = $el[0].f7Modal;
	        if (!instance) { instance = new constructor(app, { el: $el }); }
	        return instance.close(animate);
	      },
	    }
	  );
	  return methods;
	};

	var Dialog = {
	  name: 'dialog',
	  params: {
	    dialog: {
	      title: undefined,
	      buttonOk: 'OK',
	      buttonCancel: 'Cancel',
	      usernamePlaceholder: 'Username',
	      passwordPlaceholder: 'Password',
	      preloaderTitle: 'Loading... ',
	      progressTitle: 'Loading... ',
	      closeByBackdropClick: false,
	      destroyPredefinedDialogs: true,
	    },
	  },
	  static: {
	    Dialog: Dialog$1,
	  },
	  create: function create() {
	    var app = this;
	    var defaultDialogTitle = app.params.dialog.title || app.name;
	    var destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
	    app.dialog = Utils.extend(
	      ModalMethods({
	        app: app,
	        constructor: Dialog$1,
	        defaultSelector: '.dialog.modal-in',
	      }),
	      {
	        // Shortcuts
	        alert: function alert() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          if (args.length === 2 && typeof args[1] === 'function') {
	            var assign;
	            (assign = args, text = assign[0], callbackOk = assign[1], title = assign[2]);
	          }
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle : title,
	            text: text,
	            buttons: [{
	              text: app.params.dialog.buttonOk,
	              bold: true,
	              onClick: callbackOk,
	            }],
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        prompt: function prompt() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            var assign;
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle : title,
	            text: text,
	            content: '<div class="dialog-input-field item-input"><div class="item-input-wrap"><input type="text" class="dialog-input"></div></div>',
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var inputValue = dialog.$el.find('.dialog-input').val();
	              if (index === 0 && callbackCancel) { callbackCancel(inputValue); }
	              if (index === 1 && callbackOk) { callbackOk(inputValue); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        confirm: function confirm() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            var assign;
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle : title,
	            text: text,
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	                onClick: callbackCancel,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	                onClick: callbackOk,
	              } ],
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        login: function login() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            var assign;
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle : title,
	            text: text,
	            content: ("\n              <div class=\"dialog-input-field dialog-input-double item-input\">\n                <div class=\"item-input-wrap\">\n                  <input type=\"text\" name=\"dialog-username\" placeholder=\"" + (app.params.dialog.usernamePlaceholder) + "\" class=\"dialog-input\">\n                </div>\n              </div>\n              <div class=\"dialog-input-field dialog-input-double item-input\">\n                <div class=\"item-input-wrap\">\n                  <input type=\"password\" name=\"dialog-password\" placeholder=\"" + (app.params.dialog.passwordPlaceholder) + "\" class=\"dialog-input\">\n                </div>\n              </div>"),
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var username = dialog.$el.find('[name="dialog-username"]').val();
	              var password = dialog.$el.find('[name="dialog-password"]').val();
	              if (index === 0 && callbackCancel) { callbackCancel(username, password); }
	              if (index === 1 && callbackOk) { callbackOk(username, password); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        password: function password() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var text = args[0];
	          var title = args[1];
	          var callbackOk = args[2];
	          var callbackCancel = args[3];
	          if (typeof args[1] === 'function') {
	            var assign;
	            (assign = args, text = assign[0], callbackOk = assign[1], callbackCancel = assign[2], title = assign[3]);
	          }
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? defaultDialogTitle : title,
	            text: text,
	            content: ("\n              <div class=\"dialog-input-field item-input\">\n                <div class=\"item-input-wrap\">\n                  <input type=\"password\" name=\"dialog-password\" placeholder=\"" + (app.params.dialog.passwordPlaceholder) + "\" class=\"dialog-input\">\n                </div>\n              </div>"),
	            buttons: [
	              {
	                text: app.params.dialog.buttonCancel,
	              },
	              {
	                text: app.params.dialog.buttonOk,
	                bold: true,
	              } ],
	            onClick: function onClick(dialog, index) {
	              var password = dialog.$el.find('[name="dialog-password"]').val();
	              if (index === 0 && callbackCancel) { callbackCancel(password); }
	              if (index === 1 && callbackOk) { callbackOk(password); }
	            },
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        preloader: function preloader(title) {
	          var preloaderInner = app.theme !== 'md' ? '' : Utils.mdPreloaderContent;
	          return new Dialog$1(app, {
	            title: typeof title === 'undefined' ? app.params.dialog.preloaderTitle : title,
	            content: ("<div class=\"preloader\">" + preloaderInner + "</div>"),
	            cssClass: 'dialog-preloader',
	            destroyOnClose: destroyOnClose,
	          }).open();
	        },
	        progress: function progress() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var title = args[0];
	          var progress = args[1];
	          var color = args[2];
	          if (args.length === 2) {
	            if (typeof args[0] === 'number') {
	              var assign;
	              (assign = args, progress = assign[0], color = assign[1], title = assign[2]);
	            } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
	              var assign$1;
	              (assign$1 = args, title = assign$1[0], color = assign$1[1], progress = assign$1[2]);
	            }
	          } else if (args.length === 1) {
	            if (typeof args[0] === 'number') {
	              var assign$2;
	              (assign$2 = args, progress = assign$2[0], title = assign$2[1], color = assign$2[2]);
	            }
	          }
	          var infinite = typeof progress === 'undefined';
	          var dialog = new Dialog$1(app, {
	            title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
	            cssClass: 'dialog-progress',
	            content: ("\n              <div class=\"progressbar" + (infinite ? '-infinite' : '') + (color ? (" color-" + color) : '') + "\">\n                " + (!infinite ? '<span></span>' : '') + "\n              </div>\n            "),
	            destroyOnClose: destroyOnClose,
	          });
	          if (!infinite) { dialog.setProgress(progress); }
	          return dialog.open();
	        },
	      }
	    );
	  },
	  clicks: {
	    '.dialog-backdrop': function closeDialog() {
	      var app = this;
	      if (!app.params.dialog.closeByBackdropClick) { return; }
	      app.dialog.close();
	    },
	  },
	};

	var Popup$1 = (function (Modal) {
	  function Popup(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.popup,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var popup = this;

	    popup.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!popup.params.el) {
	      $el = $$1$1(popup.params.content);
	    } else {
	      $el = $$1$1(popup.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return popup.destroy();
	    }

	    var $backdropEl;
	    if (popup.params.backdrop) {
	      $backdropEl = app.root.children('.popup-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="popup-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    Utils.extend(popup, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'popup',
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $$1$1(target);
	      if ($target.closest(popup.el).length === 0) {
	        if (
	          popup.params.closeByBackdropClick &&
	          popup.params.backdrop &&
	          popup.backdropEl &&
	          popup.backdropEl === target
	        ) {
	          popup.close();
	        }
	      }
	    }

	    popup.on('popupOpened', function () {
	      if (popup.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    popup.on('popupClose', function () {
	      if (popup.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    $el[0].f7Modal = popup;

	    return popup;
	  }

	  if ( Modal ) Popup.__proto__ = Modal;
	  Popup.prototype = Object.create( Modal && Modal.prototype );
	  Popup.prototype.constructor = Popup;

	  return Popup;
	}(Modal$1));

	var Popup = {
	  name: 'popup',
	  params: {
	    popup: {
	      backdrop: true,
	      closeByBackdropClick: true,
	    },
	  },
	  static: {
	    Popup: Popup$1,
	  },
	  create: function create() {
	    var app = this;
	    app.popup = ModalMethods({
	      app: app,
	      constructor: Popup$1,
	      defaultSelector: '.popup.modal-in',
	    });
	  },
	  clicks: {
	    '.popup-open': function openPopup($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popup.open(data.popup, data.animate);
	    },
	    '.popup-close': function closePopup($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popup.close(data.popup, data.animate);
	    },
	  },
	};

	var LoginScreen$1 = (function (Modal) {
	  function LoginScreen(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var loginScreen = this;

	    loginScreen.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!loginScreen.params.el) {
	      $el = $$1$1(loginScreen.params.content);
	    } else {
	      $el = $$1$1(loginScreen.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return loginScreen.destroy();
	    }

	    Utils.extend(loginScreen, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      type: 'loginScreen',
	    });

	    $el[0].f7Modal = loginScreen;

	    return loginScreen;
	  }

	  if ( Modal ) LoginScreen.__proto__ = Modal;
	  LoginScreen.prototype = Object.create( Modal && Modal.prototype );
	  LoginScreen.prototype.constructor = LoginScreen;

	  return LoginScreen;
	}(Modal$1));

	var LoginScreen = {
	  name: 'loginScreen',
	  static: {
	    LoginScreen: LoginScreen$1,
	  },
	  create: function create() {
	    var app = this;
	    app.loginScreen = ModalMethods({
	      app: app,
	      constructor: LoginScreen$1,
	      defaultSelector: '.login-screen.modal-in',
	    });
	  },
	  clicks: {
	    '.login-screen-open': function openLoginScreen($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.loginScreen.open(data.loginScreen, data.animate);
	    },
	    '.login-screen-close': function closeLoginScreen($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.loginScreen.close(data.loginScreen, data.animate);
	    },
	  },
	};

	var Popover$1 = (function (Modal) {
	  function Popover(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.popover,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var popover = this;

	    popover.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!popover.params.el) {
	      $el = $$1$1(popover.params.content);
	    } else {
	      $el = $$1$1(popover.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    // Find Target
	    var $targetEl = $$1$1(popover.params.targetEl).eq(0);

	    if ($el.length === 0) {
	      return popover.destroy();
	    }

	    // Backdrop
	    var $backdropEl;
	    if (popover.params.backdrop) {
	      $backdropEl = app.root.children('.popover-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="popover-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    // Find Angle
	    var $angleEl;
	    if ($el.find('.popover-angle').length === 0) {
	      $angleEl = $$1$1('<div class="popover-angle"></div>');
	      $el.prepend($angleEl);
	    } else {
	      $angleEl = $el.find('.popover-angle');
	    }

	    // Open
	    var originalOpen = popover.open;

	    Utils.extend(popover, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $targetEl: $targetEl,
	      targetEl: $targetEl[0],
	      $angleEl: $angleEl,
	      angleEl: $angleEl[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'popover',
	      open: function open() {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];

	        var targetEl = args[0];
	        var animate = args[1];
	        if (typeof args[0] === 'boolean') { var assign;
	          (assign = args, animate = assign[0], targetEl = assign[1]); }
	        if (targetEl) {
	          popover.$targetEl = $$1$1(targetEl);
	          popover.targetEl = popover.$targetEl[0];
	        }
	        originalOpen.call(popover, animate);
	      },
	    });

	    function handleResize() {
	      popover.resize();
	    }
	    popover.on('popoverOpen', function () {
	      popover.resize();
	      app.on('resize', handleResize);
	      popover.on('popoverClose popoverBeforeDestroy', function () {
	        app.off('resize', handleResize);
	      });
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $$1$1(target);
	      if ($target.closest(popover.el).length === 0) {
	        if (
	          popover.params.closeByBackdropClick &&
	          popover.params.backdrop &&
	          popover.backdropEl &&
	          popover.backdropEl === target
	        ) {
	          popover.close();
	        } else if (popover.params.closeByOutsideClick) {
	          popover.close();
	        }
	      }
	    }

	    popover.on('popoverOpened', function () {
	      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    popover.on('popoverClose', function () {
	      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    $el[0].f7Modal = popover;

	    return popover;
	  }

	  if ( Modal ) Popover.__proto__ = Modal;
	  Popover.prototype = Object.create( Modal && Modal.prototype );
	  Popover.prototype.constructor = Popover;
	  Popover.prototype.resize = function resize () {
	    var popover = this;
	    var app = popover.app;
	    var $el = popover.$el;
	    var $targetEl = popover.$targetEl;
	    var $angleEl = popover.$angleEl;
	    var ref = popover.params;
	    var targetX = ref.targetX;
	    var targetY = ref.targetY;
	    $el.css({ left: '', top: '' });
	    var ref$1 = [$el.width(), $el.height()];
	    var width = ref$1[0];
	    var height = ref$1[1];
	    var angleSize = 0;
	    var angleLeft;
	    var angleTop;
	    if (app.theme === 'ios') {
	      $angleEl.removeClass('on-left on-right on-top on-bottom').css({ left: '', top: '' });
	      angleSize = $angleEl.width() / 2;
	    } else {
	      $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom').css({ left: '', top: '' });
	    }

	    var targetWidth;
	    var targetHeight;
	    var targetOffsetLeft;
	    var targetOffsetTop;
	    if ($targetEl && $targetEl.length > 0) {
	      targetWidth = $targetEl.outerWidth();
	      targetHeight = $targetEl.outerHeight();

	      var targetOffset = $targetEl.offset();
	      targetOffsetLeft = targetOffset.left - app.left;
	      targetOffsetTop = targetOffset.top - app.top;

	      var targetParentPage = $targetEl.parents('.page');
	      if (targetParentPage.length > 0) {
	        targetOffsetTop -= targetParentPage[0].scrollTop;
	      }
	    } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
	      targetOffsetLeft = targetX;
	      targetOffsetTop = targetY;
	      targetWidth = popover.params.targetWidth || 0;
	      targetHeight = popover.params.targetHeight || 0;
	    }

	    var ref$2 = [0, 0, 0];
	    var left = ref$2[0];
	    var top = ref$2[1];
	    var diff = ref$2[2];
	    // Top Position
	    var position = app.theme === 'md' ? 'bottom' : 'top';
	    if (app.theme === 'md') {
	      if (height < app.height - targetOffsetTop - targetHeight) {
	        // On bottom
	        position = 'bottom';
	        top = targetOffsetTop;
	      } else if (height < targetOffsetTop) {
	        // On top
	        top = (targetOffsetTop - height) + targetHeight;
	        position = 'top';
	      } else {
	        // On middle
	        position = 'bottom';
	        top = targetOffsetTop;
	      }

	      if (top <= 0) {
	        top = 8;
	      } else if (top + height >= app.height) {
	        top = app.height - height - 8;
	      }

	      // Horizontal Position
	      left = (targetOffsetLeft + targetWidth) - width - 8;
	      if (left + width >= app.width - 8) {
	        left = (targetOffsetLeft + targetWidth) - width - 8;
	      }
	      if (left < 8) {
	        left = 8;
	      }
	      if (position === 'top') {
	        $el.addClass('popover-on-top');
	      }
	      if (position === 'bottom') {
	        $el.addClass('popover-on-bottom');
	      }
	    } else {
	      if ((height + angleSize) < targetOffsetTop) {
	        // On top
	        top = targetOffsetTop - height - angleSize;
	      } else if ((height + angleSize) < app.height - targetOffsetTop - targetHeight) {
	        // On bottom
	        position = 'bottom';
	        top = targetOffsetTop + targetHeight + angleSize;
	      } else {
	        // On middle
	        position = 'middle';
	        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
	        diff = top;
	        if (top <= 0) {
	          top = 5;
	        } else if (top + height >= app.height) {
	          top = app.height - height - 5;
	        }
	        diff -= top;
	      }

	      // Horizontal Position
	      if (position === 'top' || position === 'bottom') {
	        left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
	        diff = left;
	        if (left < 5) { left = 5; }
	        if (left + width > app.width) { left = app.width - width - 5; }
	        if (left < 0) { left = 0; }
	        if (position === 'top') {
	          $angleEl.addClass('on-bottom');
	        }
	        if (position === 'bottom') {
	          $angleEl.addClass('on-top');
	        }
	        diff -= left;
	        angleLeft = ((width / 2) - angleSize) + diff;
	        angleLeft = Math.max(Math.min(angleLeft, width - (angleSize * 2) - 13), 13);
	        $angleEl.css({ left: (angleLeft + "px") });
	      } else if (position === 'middle') {
	        left = targetOffsetLeft - width - angleSize;
	        $angleEl.addClass('on-right');
	        if (left < 5 || (left + width > app.width)) {
	          if (left < 5) { left = targetOffsetLeft + targetWidth + angleSize; }
	          if (left + width > app.width) { left = app.width - width - 5; }
	          $angleEl.removeClass('on-right').addClass('on-left');
	        }
	        angleTop = ((height / 2) - angleSize) + diff;
	        angleTop = Math.max(Math.min(angleTop, height - (angleSize * 2) - 13), 13);
	        $angleEl.css({ top: (angleTop + "px") });
	      }
	    }

	    // Apply Styles
	    $el.css({ top: (top + "px"), left: (left + "px") });
	  };

	  return Popover;
	}(Modal$1));

	var Popover = {
	  name: 'popover',
	  params: {
	    popover: {
	      closeByBackdropClick: true,
	      closeByOutsideClick: false,
	      backdrop: true,
	    },
	  },
	  static: {
	    Popover: Popover$1,
	  },
	  create: function create() {
	    var app = this;
	    app.popover = Utils.extend(
	      ModalMethods({
	        app: app,
	        constructor: Popover$1,
	        defaultSelector: '.popover.modal-in',
	      }),
	      {
	        open: function open(popoverEl, targetEl, animate) {
	          var $popoverEl = $$1$1(popoverEl);
	          var popover = $popoverEl[0].f7Modal;
	          if (!popover) { popover = new Popover$1(app, { el: $popoverEl, targetEl: targetEl }); }
	          return popover.open(targetEl, animate);
	        },
	      }
	    );
	  },
	  clicks: {
	    '.popover-open': function openPopover($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popover.open(data.popover, $clickedEl, data.animate);
	    },
	    '.popover-close': function closePopover($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.popover.close(data.popover, data.animate);
	    },
	  },
	};

	/* eslint indent: ["off"] */
	var Actions$1 = (function (Modal) {
	  function Actions(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.actions,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var actions = this;

	    actions.params = extendedParams;

	    // Buttons
	    var groups;
	    if (actions.params.buttons) {
	      groups = actions.params.buttons;
	      if (!Array.isArray(groups[0])) { groups = [groups]; }
	    }
	    actions.groups = groups;

	    // Find Element
	    var $el;
	    if (actions.params.el) {
	      $el = $$1$1(actions.params.el);
	    } else if (actions.params.content) {
	      $el = $$1$1(actions.params.content);
	    } else if (actions.params.buttons) {
	      if (actions.params.convertToPopover) {
	        actions.popoverHtml = actions.renderPopover();
	      }
	      actions.actionsHtml = actions.render();
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
	      return actions.destroy();
	    }

	    // Backdrop
	    var $backdropEl;
	    if (actions.params.backdrop) {
	      $backdropEl = app.root.children('.actions-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="actions-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    var originalOpen = actions.open;
	    var originalClose = actions.close;

	    var popover;
	    function buttonOnClick(e) {
	      var buttonEl = this;
	      var buttonIndex;
	      var groupIndex;
	      if ($$1$1(buttonEl).hasClass('item-link')) {
	        buttonIndex = $$1$1(buttonEl).parents('li').index();
	        groupIndex = $$1$1(buttonEl).parents('.list').index();
	      } else {
	        buttonIndex = $$1$1(buttonEl).index();
	        groupIndex = $$1$1(buttonEl).parents('.actions-group').index();
	      }
	      var button = groups[groupIndex][buttonIndex];
	      if (button.onClick) { button.onClick(actions, e); }
	      if (actions.params.onClick) { actions.params.onClick(actions, e); }
	      if (button.close !== false) { actions.close(); }
	    }
	    actions.open = function open(animate) {
	      var convertToPopover = false;
	      var ref = actions.params;
	      var targetEl = ref.targetEl;
	      var targetX = ref.targetX;
	      var targetY = ref.targetY;
	      var targetWidth = ref.targetWidth;
	      var targetHeight = ref.targetHeight;
	      if (actions.params.convertToPopover && (targetEl || (targetX !== undefined && targetY !== undefined))) {
	        // Popover
	        if (
	          actions.params.forceToPopover ||
	          (app.device.ios && app.device.ipad) ||
	          app.width >= 768
	        ) {
	          convertToPopover = true;
	        }
	      }
	      if (convertToPopover && actions.popoverHtml) {
	        popover = app.popover.create({
	          content: actions.popoverHtml,
	          backdrop: actions.params.backdrop,
	          targetEl: targetEl,
	          targetX: targetX,
	          targetY: targetY,
	          targetWidth: targetWidth,
	          targetHeight: targetHeight,
	        });
	        popover.open(animate);
	        popover.once('popoverOpened', function () {
	          popover.$el.find('.item-link').each(function (groupIndex, buttonEl) {
	            $$1$1(buttonEl).on('click', buttonOnClick);
	          });
	        });
	        popover.once('popoverClosed', function () {
	          popover.$el.find('.item-link').each(function (groupIndex, buttonEl) {
	            $$1$1(buttonEl).off('click', buttonOnClick);
	          });
	          Utils.nextTick(function () {
	            popover.destroy();
	            popover = undefined;
	          });
	        });
	      } else {
	        actions.$el = actions.actionsHtml ? $$1$1(actions.actionsHtml) : actions.$el;
	        actions.$el[0].f7Modal = actions;
	        actions.$el.find('.actions-button').each(function (groupIndex, buttonEl) {
	          $$1$1(buttonEl).on('click', buttonOnClick);
	        });
	        actions.once('actionsClosed', function () {
	          actions.$el.find('.list-button').each(function (groupIndex, buttonEl) {
	            $$1$1(buttonEl).off('click', buttonOnClick);
	          });
	        });
	        originalOpen.call(actions, animate);
	      }
	      return actions;
	    };

	    actions.close = function close(animate) {
	      if (popover) {
	        popover.close(animate);
	      } else {
	        originalClose.call(actions, animate);
	      }
	      return actions;
	    };

	    Utils.extend(actions, {
	      app: app,
	      $el: $el,
	      el: $el ? $el[0] : undefined,
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'actions',
	    });

	    function handleClick(e) {
	      var target = e.target;
	      var $target = $$1$1(target);
	      if ($target.closest(actions.el).length === 0) {
	        if (
	          actions.params.closeByBackdropClick &&
	          actions.params.backdrop &&
	          actions.backdropEl &&
	          actions.backdropEl === target
	        ) {
	          actions.close();
	        }
	      }
	    }

	    actions.on('opened', function () {
	      if (actions.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    actions.on('close', function () {
	      if (actions.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    if ($el) {
	      $el[0].f7Modal = actions;
	    }

	    return actions;
	  }

	  if ( Modal ) Actions.__proto__ = Modal;
	  Actions.prototype = Object.create( Modal && Modal.prototype );
	  Actions.prototype.constructor = Actions;
	  Actions.prototype.render = function render () {
	    var actions = this;
	    if (actions.params.render) { return actions.params.render.call(actions, actions); }
	    var groups = actions.groups;
	    return ("\n      <div class=\"actions-modal" + (actions.params.grid ? ' actions-grid' : '') + "\">\n        " + (groups.map(function (group) { return ("<div class=\"actions-group\">\n            " + (group.map(function (button) {
	              var buttonClasses = [("actions-" + (button.label ? 'label' : 'button'))];
	              var color = button.color;
	              var bg = button.bg;
	              var bold = button.bold;
	              var disabled = button.disabled;
	              var label = button.label;
	              var text = button.text;
	              var icon = button.icon;
	              if (color) { buttonClasses.push(("color-" + color)); }
	              if (bg) { buttonClasses.push(("bg-" + color)); }
	              if (bold) { buttonClasses.push('actions-button-bold'); }
	              if (disabled) { buttonClasses.push('disabled'); }
	              if (label) {
	                return ("<div class=\"" + (buttonClasses.join(' ')) + "\">" + text + "</div>");
	              }
	              return ("\n                <div class=\"" + (buttonClasses.join(' ')) + "\">\n                  " + (icon ? ("<div class=\"actions-button-media\">" + icon + "</div>") : '') + "\n                  <div class=\"actions-button-text\">" + text + "</div>\n                </div>").trim();
	            }).join('')) + "\n          </div>"); }).join('')) + "\n      </div>\n    ").trim();
	  };
	  Actions.prototype.renderPopover = function renderPopover () {
	    var actions = this;
	    if (actions.params.renderPopover) { return actions.params.renderPopover.call(actions, actions); }
	    var groups = actions.groups;
	    return ("\n      <div class=\"popover popover-from-actions\">\n        <div class=\"popover-inner\">\n          " + (groups.map(function (group) { return ("\n            <div class=\"list\">\n              <ul>\n                " + (group.map(function (button) {
	                  var itemClasses = [];
	                  var color = button.color;
	                  var bg = button.bg;
	                  var bold = button.bold;
	                  var disabled = button.disabled;
	                  var label = button.label;
	                  var text = button.text;
	                  var icon = button.icon;
	                  if (color) { itemClasses.push(("color-" + color)); }
	                  if (bg) { itemClasses.push(("bg-" + bg)); }
	                  if (bold) { itemClasses.push('popover-from-actions-bold'); }
	                  if (disabled) { itemClasses.push('disabled'); }
	                  if (label) {
	                    itemClasses.push('popover-from-actions-label');
	                    return ("<li class=\"" + (itemClasses.join(' ')) + "\">" + text + "</li>");
	                  }
	                  itemClasses.push('item-link');
	                  if (icon) {
	                    itemClasses.push('item-content');
	                    return ("\n                      <li>\n                        <a class=\"" + (itemClasses.join(' ')) + "\">\n                          <div class=\"item-media\">\n                            " + icon + "\n                          </div>\n                          <div class=\"item-inner\">\n                            <div class=\"item-title\">\n                              " + text + "\n                            </div>\n                          </div>\n                        </a>\n                      </li>\n                    ");
	                  }
	                  itemClasses.push('list-button');
	                  return ("\n                    <li>\n                      <a href=\"#\" class=\"list-button " + (itemClasses.join(' ')) + "\">" + text + "</a>\n                    </li>\n                  ");
	                }).join('')) + "\n              </ul>\n            </div>\n          "); }).join('')) + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Actions;
	}(Modal$1));

	var Actions = {
	  name: 'actions',
	  params: {
	    actions: {
	      convertToPopover: true,
	      forceToPopover: false,
	      closeByBackdropClick: true,
	      render: null,
	      renderPopover: null,
	      backdrop: true,
	    },
	  },
	  static: {
	    Actions: Actions$1,
	  },
	  create: function create() {
	    var app = this;
	    app.actions = ModalMethods({
	      app: app,
	      constructor: Actions$1,
	      defaultSelector: '.actions-modal.modal-in',
	    });
	  },
	  clicks: {
	    '.actions-open': function openActions($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.actions.open(data.actions, data.animate);
	    },
	    '.actions-close': function closeActions($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.actions.close(data.actions, data.animate);
	    },
	  },
	};

	var Sheet$1 = (function (Modal) {
	  function Sheet(app, params) {
	    var extendedParams = Utils.extend(
	      { on: {} },
	      app.params.sheet,
	      params
	    );

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var sheet = this;

	    sheet.params = extendedParams;

	    // Find Element
	    var $el;
	    if (!sheet.params.el) {
	      $el = $$1$1(sheet.params.content);
	    } else {
	      $el = $$1$1(sheet.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return sheet.destroy();
	    }
	    var $backdropEl;
	    if (sheet.params.backdrop) {
	      $backdropEl = app.root.children('.sheet-backdrop');
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="sheet-backdrop"></div>');
	        app.root.append($backdropEl);
	      }
	    }

	    var $pageContentEl;
	    function scrollToOpen() {
	      var $scrollEl = $$1$1(sheet.params.scrollToEl).eq(0);
	      if ($scrollEl.length === 0) { return; }
	      $pageContentEl = $scrollEl.parents('.page-content');
	      if ($pageContentEl.length === 0) { return; }

	      var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	      var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	      var pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
	      var pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
	      var pageScroll = $pageContentEl.scrollTop();

	      var newPaddingBottom;

	      var scrollElTop = ($scrollEl.offset().top - paddingTop) + $scrollEl[0].offsetHeight;
	      if (scrollElTop > pageHeight) {
	        var scrollTop = (pageScroll + scrollElTop) - pageHeight;
	        if (scrollTop + pageHeight > pageScrollHeight) {
	          newPaddingBottom = ((scrollTop + pageHeight) - pageScrollHeight) + paddingBottom;
	          if (pageHeight === pageScrollHeight) {
	            newPaddingBottom = $el.height();
	          }
	          $pageContentEl.css({
	            'padding-bottom': (newPaddingBottom + "px"),
	          });
	        }
	        $pageContentEl.scrollTop(scrollTop, 300);
	      }
	    }

	    function scrollToClose() {
	      if ($pageContentEl && $pageContentEl.length > 0) {
	        $pageContentEl.css({
	          'padding-bottom': '',
	        });
	      }
	    }
	    function handleClick(e) {
	      var target = e.target;
	      var $target = $$1$1(target);
	      if ($target.closest(sheet.el).length === 0) {
	        if (
	          sheet.params.closeByBackdropClick &&
	          sheet.params.backdrop &&
	          sheet.backdropEl &&
	          sheet.backdropEl === target
	        ) {
	          sheet.close();
	        } else if (sheet.params.closeByOutsideClick) {
	          sheet.close();
	        }
	      }
	    }

	    sheet.on('sheetOpen', function () {
	      if (sheet.params.scrollToEl) {
	        scrollToOpen();
	      }
	    });
	    sheet.on('sheetOpened', function () {
	      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
	        app.on('click', handleClick);
	      }
	    });
	    sheet.on('sheetClose', function () {
	      if (sheet.params.scrollToEl) {
	        scrollToClose();
	      }
	      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
	        app.off('click', handleClick);
	      }
	    });

	    Utils.extend(sheet, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      type: 'sheet',
	    });

	    $el[0].f7Modal = sheet;

	    return sheet;
	  }

	  if ( Modal ) Sheet.__proto__ = Modal;
	  Sheet.prototype = Object.create( Modal && Modal.prototype );
	  Sheet.prototype.constructor = Sheet;

	  return Sheet;
	}(Modal$1));

	var Sheet = {
	  name: 'sheet',
	  params: {
	    sheet: {
	      closeByBackdropClick: true,
	      closeByOutsideClick: false,
	    },
	  },
	  static: {
	    Sheet: Sheet$1,
	  },
	  create: function create() {
	    var app = this;
	    if (!app.passedParams.sheet || !app.passedParams.sheet.backdrop) {
	      app.params.sheet.backdrop = app.theme === 'md';
	    }
	    app.sheet = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Sheet$1,
	        defaultSelector: '.sheet-modal.modal-in',
	      })
	    );
	  },
	  clicks: {
	    '.sheet-open': function openSheet($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      if ($$1$1('.sheet-modal.modal-in').length > 0 && data.sheet && $$1$1(data.sheet)[0] !== $$1$1('.sheet-modal.modal-in')[0]) {
	        app.sheet.close('.sheet-modal.modal-in');
	      }
	      app.sheet.open(data.sheet, data.animate);
	    },
	    '.sheet-close': function closeSheet($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sheet.close(data.sheet, data.animate);
	    },
	  },
	};

	var Toast$1 = (function (Modal) {
	  function Toast(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, app.params.toast, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var toast = this;

	    toast.app = app;

	    toast.params = extendedParams;

	    var ref = toast.params;
	    var closeButton = ref.closeButton;
	    var closeTimeout = ref.closeTimeout;

	    var $el;
	    if (!toast.params.el) {
	      // Find Element
	      var toastHtml = toast.render();

	      $el = $$1$1(toastHtml);
	    } else {
	      $el = $$1$1(toast.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return toast.destroy();
	    }

	    Utils.extend(toast, {
	      $el: $el,
	      el: $el[0],
	      type: 'toast',
	    });

	    $el[0].f7Modal = toast;

	    if (closeButton) {
	      $el.find('.toast-button').on('click', function () {
	        toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
	        toast.close();
	      });

	      toast.on('beforeDestroy', function () {
	        $el.find('.toast-button').off('click');
	      });
	    }

	    var timeoutId;
	    toast.on('open', function () {
	      $$1$1('.toast.modal-in').each(function (index, openedEl) {
	        var toastInstance = app.toast.get(openedEl);
	        if (openedEl !== toast.el && toastInstance) {
	          toastInstance.close();
	        }
	      });
	      if (closeTimeout) {
	        timeoutId = Utils.nextTick(function () {
	          toast.close();
	        }, closeTimeout);
	      }
	    });
	    toast.on('close', function () {
	      window.clearTimeout(timeoutId);
	    });

	    return toast;
	  }

	  if ( Modal ) Toast.__proto__ = Modal;
	  Toast.prototype = Object.create( Modal && Modal.prototype );
	  Toast.prototype.constructor = Toast;
	  Toast.prototype.render = function render () {
	    var toast = this;
	    var app = toast.app;
	    if (toast.params.render) { return toast.params.render.call(toast, toast); }
	    var ref = toast.params;
	    var position = ref.position;
	    var cssClass = ref.cssClass;
	    var icon = ref.icon;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var closeButtonColor = ref.closeButtonColor;
	    var closeButtonText = ref.closeButtonText;
	    return ("\n      <div class=\"toast toast-" + position + " " + (cssClass || '') + " " + (icon ? 'toast-with-icon' : '') + "\">\n        <div class=\"toast-content\">\n          " + (icon ? ("<div class=\"toast-icon\">" + icon + "</div>") : '') + "\n          <div class=\"toast-text\">" + text + "</div>\n          " + (closeButton && !icon ? ("\n          <a class=\"toast-button " + (app.theme === 'md' ? 'button' : 'link') + " " + (closeButtonColor ? ("color-" + closeButtonColor) : '') + "\">" + closeButtonText + "</a>\n          ").trim() : '') + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Toast;
	}(Modal$1));

	var Toast = {
	  name: 'toast',
	  static: {
	    Toast: Toast$1,
	  },
	  create: function create() {
	    var app = this;
	    app.toast = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Toast$1,
	        defaultSelector: '.toast.modal-in',
	      })
	    );
	  },
	  params: {
	    toast: {
	      icon: null,
	      text: null,
	      position: 'bottom',
	      closeButton: false,
	      closeButtonColor: null,
	      closeButtonText: 'Ok',
	      closeTimeout: null,
	      cssClass: null,
	      render: null,
	    },
	  },
	};

	var Preloader = {
	  init: function init(el) {
	    var app = this;
	    if (app.theme !== 'md') { return; }
	    var $el = $$1$1(el);
	    if ($el.length === 0 || $el.children('.preloader-inner').length > 0) { return; }
	    $el.append(Utils.mdPreloaderContent);
	  },
	  // Modal
	  visible: false,
	  show: function show(color) {
	    if ( color === void 0 ) color = 'white';

	    var app = this;
	    if (Preloader.visible) { return; }
	    var preloaderInner = app.theme !== 'md' ? '' : Utils.mdPreloaderContent;
	    $$1$1('html').addClass('with-modal-preloader');
	    app.root.append(("\n      <div class=\"preloader-backdrop\"></div>\n      <div class=\"preloader-modal\">\n        <div class=\"preloader color-" + color + "\">" + preloaderInner + "</div>\n      </div>\n    "));
	    Preloader.visible = true;
	  },
	  hide: function hide() {
	    var app = this;
	    if (!Preloader.visible) { return; }
	    $$1$1('html').removeClass('with-modal-preloader');
	    app.root.find('.preloader-backdrop, .preloader-modal').remove();
	    Preloader.visible = false;
	  },
	};
	var Preloader$1 = {
	  name: 'preloader',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      preloader: {
	        init: Preloader.init.bind(app),
	        show: Preloader.show.bind(app),
	        hide: Preloader.hide.bind(app),
	      },
	    });
	  },
	  on: {
	    photoBrowserOpen: function photoBrowserOpen(pb) {
	      var app = this;
	      if (app.theme !== 'md') { return; }
	      pb.$el.find('.preloader').each(function (index, preloaderEl) {
	        app.preloader.init(preloaderEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      if (app.theme !== 'md') { return; }
	      page.$el.find('.preloader').each(function (index, preloaderEl) {
	        app.preloader.init(preloaderEl);
	      });
	    },
	  },
	};

	var Progressbar = {
	  set: function set() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var app = this;
	    var el = args[0];
	    var progress = args[1];
	    var duration = args[2];
	    if (typeof args[0] === 'number') {
	      var assign;
	      (assign = args, progress = assign[0], duration = assign[1]);
	      el = app.root;
	    }
	    if (typeof progress === 'undefined' || progress === null) { return el; }
	    if (!progress) { progress = 0; }

	    var $el = $$1$1(el || app.root);
	    if ($el.length === 0) {
	      return el;
	    }
	    var progressNormalized = Math.min(Math.max(progress, 0), 100);
	    var $progressbarEl;
	    if ($el.hasClass('progressbar')) { $progressbarEl = $el.eq(0); }
	    else {
	      $progressbarEl = $el.children('.progressbar');
	    }
	    if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
	      return $progressbarEl;
	    }
	    var $progressbarLine = $progressbarEl.children('span');
	    if ($progressbarLine.length === 0) {
	      $progressbarLine = $$1$1('<span></span>');
	      $progressbarEl.append($progressbarLine);
	    }
	    $progressbarLine
	      .transition(typeof duration !== 'undefined' ? duration : '')
	      .transform(("translate3d(" + ((-100 + progressNormalized)) + "%,0,0)"));

	    return $progressbarEl[0];
	  },
	  show: function show() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var app = this;

	    // '.page', 50, 'multi'
	    var el = args[0];
	    var progress = args[1];
	    var color = args[2];
	    var type = 'determined';

	    if (args.length === 2) {
	      if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
	        // '.page', 'multi'
	        var assign;
	        (assign = args, el = assign[0], color = assign[1], progress = assign[2]);
	        type = 'infinite';
	      } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
	        // 50, 'multi'
	        var assign$1;
	        (assign$1 = args, progress = assign$1[0], color = assign$1[1]);
	        el = app.root;
	      }
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'number') {
	        el = app.root;
	        progress = args[0];
	      } else if (typeof args[0] === 'string') {
	        type = 'infinite';
	        el = app.root;
	        color = args[0];
	      }
	    } else if (args.length === 0) {
	      type = 'infinite';
	      el = app.root;
	    }

	    var $el = $$1$1(el);
	    if ($el.length === 0) { return undefined; }

	    var $progressbarEl;
	    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
	      $progressbarEl = $el;
	    } else {
	      $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');
	      if ($progressbarEl.length === 0) {
	        $progressbarEl = $$1$1(("\n          <span class=\"progressbar" + (type === 'infinite' ? '-infinite' : '') + (color ? (" color-" + color) : '') + " progressbar-in\">\n            " + (type === 'infinite' ? '' : '<span></span>') + "\n          </span>"));
	        $el.append($progressbarEl);
	      }
	    }

	    if (typeof progress !== 'undefined') {
	      app.progressbar.set($progressbarEl, progress);
	    }

	    return $progressbarEl[0];
	  },
	  hide: function hide(el, removeAfterHide) {
	    if ( removeAfterHide === void 0 ) removeAfterHide = true;

	    var app = this;
	    var $el = $$1$1(el || app.root);
	    if ($el.length === 0) { return undefined; }
	    var $progressbarEl;
	    if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
	      $progressbarEl = $el;
	    } else {
	      $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
	    }
	    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
	      return $progressbarEl;
	    }
	    $progressbarEl
	      .removeClass('progressbar-in')
	      .addClass('progressbar-out')
	      .animationEnd(function () {
	        if (removeAfterHide) {
	          $progressbarEl.remove();
	        }
	      });
	    return $progressbarEl;
	  },
	};

	var Progressbar$1 = {
	  name: 'progressbar',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      progressbar: {
	        set: Progressbar.set.bind(app),
	        show: Progressbar.show.bind(app),
	        hide: Progressbar.hide.bind(app),
	      },
	    });
	  },
	  on: {
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.progressbar').each(function (index, progressbarEl) {
	        var $progressbarEl = $$1$1(progressbarEl);
	        app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
	      });
	    },
	  },
	};

	var Sortable = {
	  init: function init() {
	    var app = this;
	    var isTouched;
	    var isMoved;
	    var touchStartY;
	    var touchesDiff;
	    var $sortingEl;
	    var $sortingItems;
	    var $sortableContainer;
	    var sortingElHeight;
	    var minTop;
	    var maxTop;
	    var $insertAfterEl;
	    var $insertBeforeEl;
	    var indexFrom;
	    var $pageEl;
	    var $pageContentEl;
	    var pageHeight;
	    var pageOffset;
	    var sortingElOffsetLocal;
	    var sortingElOffsetTop;
	    var initialScrollTop;

	    function handleTouchStart(e) {
	      isMoved = false;
	      isTouched = true;
	      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      $sortingEl = $$1$1(this).parent('li');
	      indexFrom = $sortingEl.index();
	      $sortableContainer = $sortingEl.parents('.sortable');
	      $sortingItems = $sortableContainer.children('ul').children('li');
	      if (app.panel) { app.panel.allowOpen = false; }
	      if (app.swipeout) { app.swipeout.allow = false; }
	    }
	    function handleTouchMove(e) {
	      if (!isTouched || !$sortingEl) { return; }
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (!isMoved) {
	        $pageEl = $sortingEl.parents('.page');
	        $pageContentEl = $sortingEl.parents('.page-content');
	        var paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	        var paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	        initialScrollTop = $pageContentEl[0].scrollTop;
	        pageOffset = $pageEl.offset().top + paddingTop;
	        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
	        $sortingEl.addClass('sorting');
	        $sortableContainer.addClass('sortable-sorting');
	        sortingElOffsetLocal = $sortingEl[0].offsetTop;
	        minTop = $sortingEl[0].offsetTop;
	        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
	        sortingElHeight = $sortingEl[0].offsetHeight;
	        sortingElOffsetTop = $sortingEl.offset().top;
	      }
	      isMoved = true;

	      e.preventDefault();
	      e.f7PreventSwipePanel = true;

	      touchesDiff = pageY - touchStartY;

	      var translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
	      var translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
	      $sortingEl.transform(("translate3d(0," + translate + "px,0)"));

	      var scrollAddition = 44;
	      var allowScroll = true;
	      if ((touchesDiff + translateScrollOffset) + scrollAddition < -minTop) {
	        allowScroll = false;
	      }
	      if ((touchesDiff + translateScrollOffset) - scrollAddition > maxTop) {
	        allowScroll = false;
	      }

	      $insertBeforeEl = undefined;
	      $insertAfterEl = undefined;

	      var scrollDiff;
	      if (allowScroll) {
	        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
	          // To Bottom
	          scrollDiff = (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition) - (pageOffset + pageHeight);
	        }
	        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
	          // To Top
	          scrollDiff = (sortingElOffsetTop + touchesDiff) - pageOffset - scrollAddition;
	        }
	        if (scrollDiff) {
	          $pageContentEl[0].scrollTop += scrollDiff;
	        }
	      }

	      $sortingItems.each(function (index, el) {
	        var $currentEl = $$1$1(el);
	        if ($currentEl[0] === $sortingEl[0]) { return; }
	        var currentElOffset = $currentEl[0].offsetTop;
	        var currentElHeight = $currentEl.height();
	        var sortingElOffset = sortingElOffsetLocal + translate;

	        if ((sortingElOffset >= currentElOffset - (currentElHeight / 2)) && $sortingEl.index() < $currentEl.index()) {
	          $currentEl.transform(("translate3d(0, " + (-sortingElHeight) + "px,0)"));
	          $insertAfterEl = $currentEl;
	          $insertBeforeEl = undefined;
	        } else if ((sortingElOffset <= currentElOffset + (currentElHeight / 2)) && $sortingEl.index() > $currentEl.index()) {
	          $currentEl.transform(("translate3d(0, " + sortingElHeight + "px,0)"));
	          $insertAfterEl = undefined;
	          if (!$insertBeforeEl) { $insertBeforeEl = $currentEl; }
	        } else {
	          $currentEl.transform('translate3d(0, 0%,0)');
	        }
	      });
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        if (isTouched && !isMoved) {
	          if (app.panel) { app.panel.allowOpen = true; }
	          if (app.swipeout) { app.swipeout.allow = true; }
	        }
	        return;
	      }
	      if (app.panel) { app.panel.allowOpen = true; }
	      if (app.swipeout) { app.swipeout.allow = true; }

	      $sortingItems.transform('');
	      $sortingEl.removeClass('sorting');
	      $sortableContainer.removeClass('sortable-sorting');

	      var virtualList;
	      var oldIndex;
	      var newIndex;
	      if ($insertAfterEl) {
	        $sortingEl.insertAfter($insertAfterEl);
	      }
	      if ($insertBeforeEl) {
	        $sortingEl.insertBefore($insertBeforeEl);
	      }

	      $sortingEl.trigger('sortable:sort', { from: indexFrom, to: $sortingEl.index() });
	      app.emit('sortableSort', $sortingEl[0], { from: indexFrom, to: $sortingEl.index() });

	      if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass('virtual-list')) {
	        virtualList = $sortableContainer[0].f7VirtualList;
	        oldIndex = $sortingEl[0].f7VirtualListIndex;
	        newIndex = $insertBeforeEl ? $insertBeforeEl[0].f7VirtualListIndex : $insertAfterEl[0].f7VirtualListIndex;
	        if (virtualList) { virtualList.moveItem(oldIndex, newIndex); }
	      }
	      $insertBeforeEl = undefined;
	      $insertAfterEl = undefined;
	      isTouched = false;
	      isMoved = false;
	    }

	    var activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;

	    $$1$1(document).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  },
	  enable: function enable(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return; }
	    $el.addClass('sortable-enabled');
	    $el.trigger('sortable:enable');
	    app.emit('sortableEnable', $el[0]);
	  },
	  disable: function disable(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return; }
	    $el.removeClass('sortable-enabled');
	    $el.trigger('sortable:disable');
	    app.emit('sortableDisable', $el[0]);
	  },
	  toggle: function toggle(el) {
	    if ( el === void 0 ) el = '.list.sortable';

	    var app = this;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return; }
	    if ($el.hasClass('sortable-enabled')) {
	      app.sortable.disable($el);
	    } else {
	      app.sortable.enable($el);
	    }
	  },
	};
	var Sortable$1 = {
	  name: 'sortable',
	  params: {
	    sortable: true,
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      sortable: {
	        init: Sortable.init.bind(app),
	        enable: Sortable.enable.bind(app),
	        disable: Sortable.disable.bind(app),
	        toggle: Sortable.toggle.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (app.params.sortable) { app.sortable.init(); }
	    },
	  },
	  clicks: {
	    '.sortable-enable': function enable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.enable(data.sortable);
	    },
	    '.sortable-disable': function disable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.disable(data.sortable);
	    },
	    '.sortable-toggle': function toggle($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.sortable.toggle(data.sortable);
	    },
	  },
	};

	var Swipeout = {
	  init: function init() {
	    var app = this;
	    var touchesStart = {};
	    var isTouched;
	    var isMoved;
	    var isScrolling;
	    var touchStartTime;
	    var touchesDiff;
	    var $swipeoutEl;
	    var $swipeoutContent;
	    var $actionsRight;
	    var $actionsLeft;
	    var actionsLeftWidth;
	    var actionsRightWidth;
	    var translate;
	    var opened;
	    var openedActionsSide;
	    var $leftButtons;
	    var $rightButtons;
	    var direction;
	    var $overswipeLeftButton;
	    var $overswipeRightButton;
	    var overswipeLeft;
	    var overswipeRight;

	    function handleTouchStart(e) {
	      if (!Swipeout.allow) { return; }
	      isMoved = false;
	      isTouched = true;
	      isScrolling = undefined;
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchStartTime = (new Date()).getTime();
	      $swipeoutEl = $$1$1(this);
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }

	      if (!isMoved) {
	        if ($$1$1('.list.sortable-opened').length > 0) { return; }
	        $swipeoutContent = $swipeoutEl.find('.swipeout-content');
	        $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
	        $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
	        actionsLeftWidth = null;
	        actionsRightWidth = null;
	        $leftButtons = null;
	        $rightButtons = null;
	        $overswipeRightButton = null;
	        $overswipeLeftButton = null;
	        if ($actionsLeft.length > 0) {
	          actionsLeftWidth = $actionsLeft.outerWidth();
	          $leftButtons = $actionsLeft.children('a');
	          $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
	        }
	        if ($actionsRight.length > 0) {
	          actionsRightWidth = $actionsRight.outerWidth();
	          $rightButtons = $actionsRight.children('a');
	          $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
	        }
	        opened = $swipeoutEl.hasClass('swipeout-opened');
	        if (opened) {
	          openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
	        }
	        $swipeoutEl.removeClass('swipeout-transitioning');
	        if (!app.params.swipeout.noFollow) {
	          $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
	          $swipeoutEl.removeClass('swipeout-opened');
	        }
	      }
	      isMoved = true;
	      e.preventDefault();

	      touchesDiff = pageX - touchesStart.x;
	      translate = touchesDiff;

	      if (opened) {
	        if (openedActionsSide === 'right') { translate -= actionsRightWidth; }
	        else { translate += actionsLeftWidth; }
	      }

	      if (
	        (translate > 0 && $actionsLeft.length === 0)
	        ||
	        (translate < 0 && $actionsRight.length === 0)
	      ) {
	        if (!opened) {
	          isTouched = false;
	          isMoved = false;
	          $swipeoutContent.transform('');
	          if ($rightButtons && $rightButtons.length > 0) {
	            $rightButtons.transform('');
	          }
	          if ($leftButtons && $leftButtons.length > 0) {
	            $leftButtons.transform('');
	          }
	          return;
	        }
	        translate = 0;
	      }

	      if (translate < 0) { direction = 'to-left'; }
	      else if (translate > 0) { direction = 'to-right'; }
	      else if (!direction) { direction = 'to-left'; }

	      var buttonOffset;
	      var progress;

	      e.f7PreventSwipePanel = true;
	      if (app.params.swipeout.noFollow) {
	        if (opened) {
	          if (openedActionsSide === 'right' && touchesDiff > 0) {
	            app.swipeout.close($swipeoutEl);
	          }
	          if (openedActionsSide === 'left' && touchesDiff < 0) {
	            app.swipeout.close($swipeoutEl);
	          }
	        } else {
	          if (touchesDiff < 0 && $actionsRight.length > 0) {
	            app.swipeout.open($swipeoutEl, 'right');
	          }
	          if (touchesDiff > 0 && $actionsLeft.length > 0) {
	            app.swipeout.open($swipeoutEl, 'left');
	          }
	        }
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      overswipeLeft = false;
	      overswipeRight = false;
	      if ($actionsRight.length > 0) {
	        // Show right actions
	        var buttonTranslate = translate;
	        progress = buttonTranslate / actionsRightWidth;
	        if (buttonTranslate < -actionsRightWidth) {
	          buttonTranslate = -actionsRightWidth - (Math.pow( (-buttonTranslate - actionsRightWidth), 0.8 ));
	          translate = buttonTranslate;
	          if ($overswipeRightButton.length > 0) {
	            overswipeRight = true;
	          }
	        }
	        if (direction !== 'to-left') {
	          progress = 0;
	          buttonTranslate = 0;
	        }
	        $rightButtons.each(function (index, buttonEl) {
	          var $buttonEl = $$1$1(buttonEl);
	          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
	          }
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
	            $buttonEl.css({ left: ((overswipeRight ? -buttonOffset : 0) + "px") });
	            if (overswipeRight) {
	              $buttonEl.addClass('swipeout-overswipe-active');
	            } else {
	              $buttonEl.removeClass('swipeout-overswipe-active');
	            }
	          }
	          $buttonEl.transform(("translate3d(" + (buttonTranslate - (buttonOffset * (1 + Math.max(progress, -1)))) + "px,0,0)"));
	        });
	      }
	      if ($actionsLeft.length > 0) {
	        // Show left actions
	        var buttonTranslate$1 = translate;
	        progress = buttonTranslate$1 / actionsLeftWidth;
	        if (buttonTranslate$1 > actionsLeftWidth) {
	          buttonTranslate$1 = actionsLeftWidth + (Math.pow( (buttonTranslate$1 - actionsLeftWidth), 0.8 ));
	          translate = buttonTranslate$1;
	          if ($overswipeLeftButton.length > 0) {
	            overswipeLeft = true;
	          }
	        }
	        if (direction !== 'to-right') {
	          buttonTranslate$1 = 0;
	          progress = 0;
	        }
	        $leftButtons.each(function (index, buttonEl) {
	          var $buttonEl = $$1$1(buttonEl);
	          if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
	          }
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
	            $buttonEl.css({ left: ((overswipeLeft ? buttonOffset : 0) + "px") });
	            if (overswipeLeft) {
	              $buttonEl.addClass('swipeout-overswipe-active');
	            } else {
	              $buttonEl.removeClass('swipeout-overswipe-active');
	            }
	          }
	          if ($leftButtons.length > 1) {
	            $buttonEl.css('z-index', $leftButtons.length - index);
	          }
	          $buttonEl.transform(("translate3d(" + (buttonTranslate$1 + (buttonOffset * (1 - Math.min(progress, 1)))) + "px,0,0)"));
	        });
	      }
	      $swipeoutEl.trigger('swipeout', progress);
	      app.emit('swipeout', $swipeoutEl[0], progress);
	      $swipeoutContent.transform(("translate3d(" + translate + "px,0,0)"));
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }

	      isTouched = false;
	      isMoved = false;
	      var timeDiff = (new Date()).getTime() - touchStartTime;
	      var $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
	      var actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
	      var action;
	      var $buttons;
	      var i;

	      if (
	        (
	          timeDiff < 300
	          &&
	          (
	            (touchesDiff < -10 && direction === 'to-left')
	            ||
	            (touchesDiff > 10 && direction === 'to-right')
	          )
	        )
	        ||
	        (
	          timeDiff >= 300
	          &&
	          (Math.abs(translate) > actionsWidth / 2)
	        )
	      ) {
	        action = 'open';
	      } else {
	        action = 'close';
	      }
	      if (timeDiff < 300) {
	        if (Math.abs(translate) === 0) { action = 'close'; }
	        if (Math.abs(translate) === actionsWidth) { action = 'open'; }
	      }

	      if (action === 'open') {
	        Swipeout.el = $swipeoutEl[0];
	        $swipeoutEl.trigger('swipeout:open');
	        app.emit('swipeoutOpen', $swipeoutEl[0]);
	        $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
	        var newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
	        $swipeoutContent.transform(("translate3d(" + newTranslate + "px,0,0)"));
	        $actions.addClass('swipeout-actions-opened');
	        $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;
	        if ($buttons) {
	          for (i = 0; i < $buttons.length; i += 1) {
	            $$1$1($buttons[i]).transform(("translate3d(" + newTranslate + "px,0,0)"));
	          }
	        }
	        if (overswipeRight) {
	          $actionsRight.find('.swipeout-overswipe')[0].click();
	        }
	        if (overswipeLeft) {
	          $actionsLeft.find('.swipeout-overswipe')[0].click();
	        }
	      } else {
	        $swipeoutEl.trigger('swipeout:close');
	        app.emit('swipeoutClose', $swipeoutEl[0]);
	        Swipeout.el = undefined;
	        $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
	        $swipeoutContent.transform('');
	        $actions.removeClass('swipeout-actions-opened');
	      }

	      var buttonOffset;
	      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
	        $leftButtons.each(function (index, buttonEl) {
	          var $buttonEl = $$1$1(buttonEl);
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if (typeof buttonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
	          }
	          $buttonEl.transform(("translate3d(" + buttonOffset + "px,0,0)"));
	        });
	      }
	      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
	        $rightButtons.each(function (index, buttonEl) {
	          var $buttonEl = $$1$1(buttonEl);
	          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
	          if (typeof buttonOffset === 'undefined') {
	            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
	          }
	          $buttonEl.transform(("translate3d(" + (-buttonOffset) + "px,0,0)"));
	        });
	      }
	      $swipeoutContent.transitionEnd(function () {
	        if ((opened && action === 'open') || (!opened && action === 'close')) { return; }
	        $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
	        app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
	        $swipeoutEl.removeClass('swipeout-transitioning');
	        if (opened && action === 'close') {
	          if ($actionsRight.length > 0) {
	            $rightButtons.transform('');
	          }
	          if ($actionsLeft.length > 0) {
	            $leftButtons.transform('');
	          }
	        }
	      });
	    }

	    var passiveListener = app.support.passiveListener ? { passive: true } : false;

	    app.on('touchstart', function (e) {
	      if (Swipeout.el) {
	        var $targetEl = $$1$1(e.target);
	        if (!(
	          $$1$1(Swipeout.el).is($targetEl[0]) ||
	          $targetEl.parents('.swipeout').is(Swipeout.el) ||
	          $targetEl.hasClass('modal-in') ||
	          $targetEl[0].className.indexOf('-backdrop') > 0 ||
	          $targetEl.hasClass('actions-modal') ||
	          $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0
	        )) {
	          app.swipeout.close(Swipeout.el);
	        }
	      }
	    });
	    $$1$1(document).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	  },
	  allow: true,
	  el: undefined,
	  open: function open() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var app = this;
	    var el = args[0];
	    var side = args[1];
	    var callback = args[2];
	    if (typeof args[1] === 'function') {
	      var assign;
	      (assign = args, el = assign[0], callback = assign[1], side = assign[2]);
	    }
	    var $el = $$1$1(el).eq(0);

	    if ($el.length === 0) { return; }
	    if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) { return; }
	    if (!side) {
	      if ($el.find('.swipeout-actions-right').length > 0) { side = 'right'; }
	      else { side = 'left'; }
	    }
	    var $swipeoutActions = $el.find((".swipeout-actions-" + side));
	    var $swipeoutContent = $el.find('.swipeout-content');
	    if ($swipeoutActions.length === 0) { return; }
	    $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
	    app.emit('swipeoutOpen', $el[0]);
	    $swipeoutActions.addClass('swipeout-actions-opened');
	    var $buttons = $swipeoutActions.children('a');
	    var swipeoutActionsWidth = $swipeoutActions.outerWidth();
	    var translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;
	    if ($buttons.length > 1) {
	      $buttons.each(function (buttonIndex, buttonEl) {
	        var $buttonEl = $$1$1(buttonEl);
	        if (side === 'right') {
	          $buttonEl.transform(("translate3d(" + (-buttonEl.offsetLeft) + "px,0,0)"));
	        } else {
	          $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)"));
	        }
	      });
	    }
	    $el.addClass('swipeout-transitioning');
	    $swipeoutContent.transitionEnd(function () {
	      $el.trigger('swipeout:opened');
	      app.emit('swipeoutOpened', $el[0]);
	      if (callback) { callback.call($el[0]); }
	    });
	    Utils.nextFrame(function () {
	      $buttons.transform(("translate3d(" + translate + "px,0,0)"));
	      $swipeoutContent.transform(("translate3d(" + translate + "px,0,0)"));
	    });
	    Swipeout.el = $el[0];
	  },
	  close: function close(el, callback) {
	    var app = this;
	    var $el = $$1$1(el).eq(0);
	    if ($el.length === 0) { return; }
	    if (!$el.hasClass('swipeout-opened')) { return; }
	    var side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
	    var $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
	    var $buttons = $swipeoutActions.children('a');
	    var swipeoutActionsWidth = $swipeoutActions.outerWidth();
	    Swipeout.allow = false;
	    $el.trigger('swipeout:close');
	    app.emit('swipeoutClose', $el[0]);
	    $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');

	    var closeTimeout;
	    function onSwipeoutClose() {
	      Swipeout.allow = true;
	      if ($el.hasClass('swipeout-opened')) { return; }
	      $el.removeClass('swipeout-transitioning');
	      $buttons.transform('');
	      $el.trigger('swipeout:closed');
	      app.emit('swipeoutClosed', $el[0]);
	      if (callback) { callback.call($el[0]); }
	      if (closeTimeout) { clearTimeout(closeTimeout); }
	    }
	    $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
	    closeTimeout = setTimeout(onSwipeoutClose, 500);

	    $buttons.each(function (index, buttonEl) {
	      var $buttonEl = $$1$1(buttonEl);
	      if (side === 'right') {
	        $buttonEl.transform(("translate3d(" + (-buttonEl.offsetLeft) + "px,0,0)"));
	      } else {
	        $buttonEl.transform(("translate3d(" + (swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft) + "px,0,0)"));
	      }
	      $buttonEl.css({ left: '0px' }).removeClass('swipeout-overswipe-active');
	    });
	    if (Swipeout.el && Swipeout.el === $el[0]) { Swipeout.el = undefined; }
	  },
	  delete: function delete$1(el, callback) {
	    var app = this;
	    var $el = $$1$1(el).eq(0);
	    if ($el.length === 0) { return; }
	    Swipeout.el = undefined;
	    $el.trigger('swipeout:delete');
	    app.emit('swipeoutDelete', $el[0]);
	    $el.css({ height: (($el.outerHeight()) + "px") });
	    $el.transitionEnd(function () {
	      $el.trigger('swipeout:deleted');
	      app.emit('swipeoutDeleted', $el[0]);
	      if (callback) { callback.call($el[0]); }
	      if ($el.parents('.virtual-list').length > 0) {
	        var virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
	        var virtualIndex = $el[0].f7VirtualListIndex;
	        if (virtualList && typeof virtualIndex !== 'undefined') { virtualList.deleteItem(virtualIndex); }
	      } else if (app.params.swipeout.removeElements) {
	        if (app.params.swipeout.removeElementsWithTimeout) {
	          setTimeout(function () {
	            $el.remove();
	          }, app.params.swipeout.removeElementsTimeout);
	        } else {
	          $el.remove();
	        }
	      } else {
	        $el.removeClass('swipeout-deleting swipeout-transitioning');
	      }
	    });
	    Utils.nextFrame(function () {
	      $el
	        .addClass('swipeout-deleting swipeout-transitioning')
	        .css({ height: '0px' })
	        .find('.swipeout-content')
	        .transform('translate3d(-100%,0,0)');
	    });
	  },
	};
	var Swipeout$1 = {
	  name: 'swipeout',
	  params: {
	    swipeout: {
	      actionsNoFold: false,
	      noFollow: false,
	      removeElements: true,
	      removeElementsWithTimeout: false,
	      removeElementsTimeout: 0,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      swipeout: {
	        init: Swipeout.init.bind(app),
	        open: Swipeout.open.bind(app),
	        close: Swipeout.close.bind(app),
	        delete: Swipeout.delete.bind(app),
	      },
	    });
	    Object.defineProperty(app.swipeout, 'el', {
	      enumerable: true,
	      configurable: true,
	      get: function () { return Swipeout.el; },
	      set: function set(el) {
	        Swipeout.el = el;
	      },
	    });
	    Object.defineProperty(app.swipeout, 'allow', {
	      enumerable: true,
	      configurable: true,
	      get: function () { return Swipeout.allow; },
	      set: function set(allow) {
	        Swipeout.allow = allow;
	      },
	    });
	  },
	  clicks: {
	    '.swipeout-open': function openSwipeout($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.swipeout.open(data.swipeout, data.side);
	    },
	    '.swipeout-close': function closeSwipeout($clickedEl) {
	      var app = this;
	      var $swipeoutEl = $clickedEl.closest('.swipeout');
	      if ($swipeoutEl.length === 0) { return; }
	      app.swipeout.close($swipeoutEl);
	    },
	    '.swipeout-delete': function deleteSwipeout($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var $swipeoutEl = $clickedEl.closest('.swipeout');
	      if ($swipeoutEl.length === 0) { return; }
	      var confirm = data.confirm;
	      var confirmTitle = data.confirmTitle;
	      if (data.confirm) {
	        app.dialog.confirm(confirm, confirmTitle, function () {
	          app.swipeout.delete($swipeoutEl);
	        });
	      } else {
	        app.swipeout.delete($swipeoutEl);
	      }
	    },
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (!app.params.swipeout) { return; }
	      app.swipeout.init();
	    },
	  },
	};

	var Accordion = {
	  toggleClicked: function toggleClicked($clickedEl) {
	    var app = this;
	    var $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
	    if (!$accordionItemEl.length) { $accordionItemEl = $clickedEl.parents('li').eq(0); }
	    app.accordion.toggle($accordionItemEl);
	  },
	  open: function open(el) {
	    var app = this;
	    var $el = $$1$1(el);
	    var $list = $el.parents('.accordion-list').eq(0);
	    var $contentEl = $el.children('.accordion-item-content');
	    if ($contentEl.length === 0) { $contentEl = $el.find('.accordion-item-content'); }
	    if ($contentEl.length === 0) { return; }
	    var $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');
	    if ($openedItem.length > 0) {
	      app.accordion.close($openedItem);
	    }
	    $contentEl.transitionEnd(function () {
	      if ($el.hasClass('accordion-item-opened')) {
	        $contentEl.css('height', '');
	        $contentEl.transition('');
	        $el.trigger('accordion:opened');
	        app.emit('accordionOpened', $el[0]);
	      } else {
	        $contentEl.css('height', '');
	        $el.trigger('accordion:closed');
	        app.emit('accordionClosed', $el[0]);
	      }
	    });
	    $contentEl.css('height', (($contentEl[0].scrollHeight) + "px"));
	    $el.trigger('accordion:open');
	    $el.addClass('accordion-item-opened');
	    app.emit('accordionOpen', $el[0]);
	  },
	  close: function close(el) {
	    var app = this;
	    var $el = $$1$1(el);
	    var $contentEl = $el.children('.accordion-item-content');
	    if ($contentEl.length === 0) { $contentEl = $el.find('.accordion-item-content'); }
	    $el.removeClass('accordion-item-opened');
	    $contentEl.transition(0);
	    $contentEl.css('height', (($contentEl[0].scrollHeight) + "px"));
	    // Close
	    $contentEl.transitionEnd(function () {
	      if ($el.hasClass('accordion-item-opened')) {
	        $contentEl.css('height', '');
	        $contentEl.transition('');
	        $el.trigger('accordion:opened');
	        app.emit('accordionOpened', $el[0]);
	      } else {
	        $contentEl.css('height', '');
	        $el.trigger('accordion:closed');
	        app.emit('accordionClosed', $el[0]);
	      }
	    });
	    Utils.nextFrame(function () {
	      $contentEl.transition('');
	      $contentEl.css('height', '');
	      $el.trigger('accordion:close');
	      app.emit('accordionClose');
	    });
	  },
	  toggle: function toggle(el) {
	    var app = this;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return; }
	    if ($el.hasClass('accordion-item-opened')) { app.accordion.close(el); }
	    else { app.accordion.open(el); }
	  },
	};

	var Accordion$1 = {
	  name: 'accordion',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      accordion: {
	        open: Accordion.open.bind(app),
	        close: Accordion.close.bind(app),
	        toggle: Accordion.toggle.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
	      var app = this;
	      Accordion.toggleClicked.call(app, $clickedEl);
	    },
	  },
	};

	var VirtualList$1 = (function (Framework7Class$$1) {
	  function VirtualList(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var vl = this;

	    var defaults = {
	      cols: 1,
	      height: app.theme === 'md' ? 48 : 44,
	      cache: true,
	      dynamicHeightBufferSize: 1,
	      showFilteredItemsOnly: false,
	      renderExternal: undefined,
	      setListHeight: true,
	      searchByItem: undefined,
	      searchAll: undefined,
	      itemTemplate: undefined,
	      ul: null,
	      createUl: true,
	      renderItem: function renderItem(item) {
	        return ("\n          <li>\n            <div class=\"item-content\">\n              <div class=\"item-inner\">\n                <div class=\"item-title\">" + item + "</div>\n              </div>\n            </div>\n          </li>\n        ").trim();
	      },
	      on: {},
	    };

	    // Extend defaults with modules params
	    vl.useModulesParams(defaults);

	    vl.params = Utils.extend(defaults, params);
	    if (vl.params.height === undefined || !vl.params.height) {
	      vl.params.height = app.theme === 'md' ? 48 : 44;
	    }

	    vl.$el = $$1$1(params.el);
	    vl.el = vl.$el[0];

	    if (vl.$el.length === 0) { return undefined; }
	    vl.$el[0].f7VirtualList = vl;

	    vl.items = vl.params.items;
	    if (vl.params.showFilteredItemsOnly) {
	      vl.filteredItems = [];
	    }
	    if (vl.params.itemTemplate) {
	      if (typeof vl.params.itemTemplate === 'string') { vl.renderItem = Template7.compile(vl.params.itemTemplate); }
	      else if (typeof vl.params.itemTemplate === 'function') { vl.renderItem = vl.params.itemTemplate; }
	    } else if (vl.params.renderItem) {
	      vl.renderItem = vl.params.renderItem;
	    }
	    vl.$pageContentEl = vl.$el.parents('.page-content');
	    vl.pageContentEl = vl.$pageContentEl[0];

	    // Bad scroll
	    if (typeof vl.params.updatableScroll !== 'undefined') {
	      vl.updatableScroll = vl.params.updatableScroll;
	    } else {
	      vl.updatableScroll = true;
	      if (Device.ios && Device.osVersion.split('.')[0] < 8) {
	        vl.updatableScroll = false;
	      }
	    }

	    // Append <ul>
	    var ul = vl.params.ul;
	    vl.$ul = ul ? $$1$1(vl.params.ul) : vl.$el.children('ul');
	    if (vl.$ul.length === 0 && vl.params.createUl) {
	      vl.$el.append('<ul></ul>');
	      vl.$ul = vl.$el.children('ul');
	    }
	    vl.ul = vl.$ul[0];

	    var $itemsWrapEl;
	    if (!vl.ul && !vl.params.createUl) { $itemsWrapEl = vl.$el; }
	    else { $itemsWrapEl = vl.$ul; }

	    Utils.extend(vl, {
	      $itemsWrapEl: $itemsWrapEl,
	      itemsWrapEl: $itemsWrapEl[0],
	      // DOM cached items
	      domCache: {},
	      displayDomCache: {},
	      // Temporary DOM Element
	      tempDomElement: document.createElement('ul'),
	      // Last repain position
	      lastRepaintY: null,
	      // Fragment
	      fragment: document.createDocumentFragment(),
	      // Props
	      pageHeight: undefined,
	      rowsPerScreen: undefined,
	      rowsBefore: undefined,
	      rowsAfter: undefined,
	      rowsToRender: undefined,
	      maxBufferHeight: 0,
	      listHeight: undefined,
	      dynamicHeight: typeof vl.params.height === 'function',
	    });

	    // Install Modules
	    vl.useModules();

	    // Attach events
	    var handleScrollBound = vl.handleScroll.bind(vl);
	    var handleResizeBound = vl.handleResize.bind(vl);
	    var $pageEl;
	    var $tabEl;
	    var $panelEl;
	    var $popupEl;
	    vl.attachEvents = function attachEvents() {
	      $pageEl = vl.$el.parents('.page').eq(0);
	      $tabEl = vl.$el.parents('.tab').eq(0);
	      $panelEl = vl.$el.parents('.panel').eq(0);
	      $popupEl = vl.$el.parents('.popup').eq(0);

	      vl.$pageContentEl.on('scroll', handleScrollBound);
	      if ($pageEl) { $pageEl.on('page:reinit', handleResizeBound); }
	      if ($tabEl) { $tabEl.on('tab:show', handleResizeBound); }
	      if ($panelEl) { $panelEl.on('panel:open', handleResizeBound); }
	      if ($popupEl) { $popupEl.on('popup:open', handleResizeBound); }
	      app.on('resize', handleResizeBound);
	    };
	    vl.detachEvents = function attachEvents() {
	      vl.$pageContentEl.off('scroll', handleScrollBound);
	      if ($pageEl) { $pageEl.off('page:reinit', handleResizeBound); }
	      if ($tabEl) { $tabEl.off('tab:show', handleResizeBound); }
	      if ($panelEl) { $panelEl.off('panel:open', handleResizeBound); }
	      if ($popupEl) { $popupEl.off('popup:open', handleResizeBound); }
	      app.off('resize', handleResizeBound);
	    };
	    // Init
	    vl.init();

	    return vl;
	  }

	  if ( Framework7Class$$1 ) VirtualList.__proto__ = Framework7Class$$1;
	  VirtualList.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  VirtualList.prototype.constructor = VirtualList;
	  VirtualList.prototype.setListSize = function setListSize () {
	    var vl = this;
	    var items = vl.filteredItems || vl.items;
	    vl.pageHeight = vl.$pageContentEl[0].offsetHeight;
	    if (vl.dynamicHeight) {
	      vl.listHeight = 0;
	      vl.heights = [];
	      for (var i = 0; i < items.length; i += 1) {
	        var itemHeight = vl.params.height(items[i]);
	        vl.listHeight += itemHeight;
	        vl.heights.push(itemHeight);
	      }
	    } else {
	      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
	      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
	      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
	      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
	      vl.rowsToRender = (vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter);
	      vl.maxBufferHeight = (vl.rowsBefore / 2) * vl.params.height;
	    }

	    if (vl.updatableScroll || vl.params.setListHeight) {
	      vl.$itemsWrapEl.css({ height: ((vl.listHeight) + "px") });
	    }
	  };
	  VirtualList.prototype.render = function render (force, forceScrollTop) {
	    var vl = this;
	    if (force) { vl.lastRepaintY = null; }

	    var scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$pageContentEl[0].getBoundingClientRect().top);

	    if (typeof forceScrollTop !== 'undefined') { scrollTop = forceScrollTop; }
	    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || (!vl.updatableScroll && (vl.$pageContentEl[0].scrollTop + vl.pageHeight >= vl.$pageContentEl[0].scrollHeight))) {
	      vl.lastRepaintY = scrollTop;
	    } else {
	      return;
	    }

	    var items = vl.filteredItems || vl.items;
	    var fromIndex;
	    var toIndex;
	    var heightBeforeFirstItem = 0;
	    var heightBeforeLastItem = 0;
	    if (vl.dynamicHeight) {
	      var itemTop = 0;
	      var itemHeight;
	      vl.maxBufferHeight = vl.pageHeight;

	      for (var j = 0; j < vl.heights.length; j += 1) {
	        itemHeight = vl.heights[j];
	        if (typeof fromIndex === 'undefined') {
	          if (itemTop + itemHeight >= scrollTop - (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)) { fromIndex = j; }
	          else { heightBeforeFirstItem += itemHeight; }
	        }

	        if (typeof toIndex === 'undefined') {
	          if (itemTop + itemHeight >= scrollTop + (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) || j === vl.heights.length - 1) { toIndex = j + 1; }
	          heightBeforeLastItem += itemHeight;
	        }
	        itemTop += itemHeight;
	      }
	      toIndex = Math.min(toIndex, items.length);
	    } else {
	      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
	      if (fromIndex < 0) {
	        fromIndex = 0;
	      }
	      toIndex = Math.min(fromIndex + (vl.rowsToRender * vl.params.cols), items.length);
	    }

	    var topPosition;
	    var renderExternalItems = [];
	    vl.reachEnd = false;
	    var i;
	    for (i = fromIndex; i < toIndex; i += 1) {
	      var itemEl = (void 0);
	      // Define real item index
	      var index = vl.items.indexOf(items[i]);

	      if (i === fromIndex) { vl.currentFromIndex = index; }
	      if (i === toIndex - 1) { vl.currentToIndex = index; }
	      if (vl.filteredItems) {
	        if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) { vl.reachEnd = true; }
	      } else if (index === vl.items.length - 1) { vl.reachEnd = true; }

	      // Find items
	      if (vl.params.renderExternal) {
	        renderExternalItems.push(items[i]);
	      } else if (vl.domCache[index]) {
	        itemEl = vl.domCache[index];
	        itemEl.f7VirtualListIndex = index;
	      } else {
	        if (vl.renderItem) {
	          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
	        } else {
	          vl.tempDomElement.innerHTML = items[i].toString().trim();
	        }
	        itemEl = vl.tempDomElement.childNodes[0];
	        if (vl.params.cache) { vl.domCache[index] = itemEl; }
	        itemEl.f7VirtualListIndex = index;
	      }

	      // Set item top position
	      if (i === fromIndex) {
	        if (vl.dynamicHeight) {
	          topPosition = heightBeforeFirstItem;
	        } else {
	          topPosition = ((i * vl.params.height) / vl.params.cols);
	        }
	      }
	      if (!vl.params.renderExternal) {
	        itemEl.style.top = topPosition + "px";

	        // Before item insert
	        vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]);

	        // Append item to fragment
	        vl.fragment.appendChild(itemEl);
	      }
	    }

	    // Update list height with not updatable scroll
	    if (!vl.updatableScroll) {
	      if (vl.dynamicHeight) {
	        vl.itemsWrapEl.style.height = heightBeforeLastItem + "px";
	      } else {
	        vl.itemsWrapEl.style.height = ((i * vl.params.height) / vl.params.cols) + "px";
	      }
	    }

	    // Update list html
	    if (vl.params.renderExternal) {
	      if (items && items.length === 0) {
	        vl.reachEnd = true;
	      }
	    } else {
	      vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
	      vl.itemsWrapEl.innerHTML = '';

	      vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

	      if (items && items.length === 0) {
	        vl.reachEnd = true;
	        if (vl.params.emptyTemplate) { vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate; }
	      } else {
	        vl.itemsWrapEl.appendChild(vl.fragment);
	      }

	      vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
	    }

	    if (typeof forceScrollTop !== 'undefined' && force) {
	      vl.$pageContentEl.scrollTop(forceScrollTop, 0);
	    }
	    if (vl.params.renderExternal) {
	      vl.params.renderExternal(vl, {
	        fromIndex: fromIndex,
	        toIndex: toIndex,
	        listHeight: vl.listHeight,
	        topPosition: topPosition,
	        items: renderExternalItems,
	      });
	    }
	  };
	  // Filter
	  VirtualList.prototype.filterItems = function filterItems (indexes, resetScrollTop) {
	    if ( resetScrollTop === void 0 ) resetScrollTop = true;

	    var vl = this;
	    vl.filteredItems = [];
	    for (var i = 0; i < indexes.length; i += 1) {
	      vl.filteredItems.push(vl.items[indexes[i]]);
	    }
	    if (resetScrollTop) {
	      vl.$pageContentEl[0].scrollTop = 0;
	    }
	    vl.update();
	  };
	  VirtualList.prototype.resetFilter = function resetFilter () {
	    var vl = this;
	    if (vl.params.showFilteredItemsOnly) {
	      vl.filteredItems = [];
	    } else {
	      vl.filteredItems = null;
	      delete vl.filteredItems;
	    }
	    vl.update();
	  };
	  VirtualList.prototype.scrollToItem = function scrollToItem (index) {
	    var vl = this;
	    if (index > vl.items.length) { return false; }
	    var itemTop = 0;
	    if (vl.dynamicHeight) {
	      for (var i = 0; i < index; i += 1) {
	        itemTop += vl.heights[i];
	      }
	    } else {
	      itemTop = index * vl.params.height;
	    }
	    var listTop = vl.$el[0].offsetTop;
	    vl.render(true, (listTop + itemTop) - parseInt(vl.$pageContentEl.css('padding-top'), 10));
	    return true;
	  };
	  VirtualList.prototype.handleScroll = function handleScroll () {
	    var vl = this;
	    vl.render();
	  };
	  // Handle resize event
	  VirtualList.prototype.isVisible = function isVisible () {
	    var vl = this;
	    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
	  };
	  VirtualList.prototype.handleResize = function handleResize () {
	    var vl = this;
	    if (vl.isVisible()) {
	      vl.setListSize();
	      vl.render(true);
	    }
	  };
	  // Append
	  VirtualList.prototype.appendItems = function appendItems (items) {
	    var vl = this;
	    for (var i = 0; i < items.length; i += 1) {
	      vl.items.push(items[i]);
	    }
	    vl.update();
	  };
	  VirtualList.prototype.appendItem = function appendItem (item) {
	    var vl = this;
	    vl.appendItems([item]);
	  };
	  // Replace
	  VirtualList.prototype.replaceAllItems = function replaceAllItems (items) {
	    var vl = this;
	    vl.items = items;
	    delete vl.filteredItems;
	    vl.domCache = {};
	    vl.update();
	  };
	  VirtualList.prototype.replaceItem = function replaceItem (index, item) {
	    var vl = this;
	    vl.items[index] = item;
	    if (vl.params.cache) { delete vl.domCache[index]; }
	    vl.update();
	  };
	  // Prepend
	  VirtualList.prototype.prependItems = function prependItems (items) {
	    var vl = this;
	    for (var i = items.length - 1; i >= 0; i -= 1) {
	      vl.items.unshift(items[i]);
	    }
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };
	  VirtualList.prototype.prependItem = function prependItem (item) {
	    var vl = this;
	    vl.prependItems([item]);
	  };

	  // Move
	  VirtualList.prototype.moveItem = function moveItem (from, to) {
	    var vl = this;
	    var fromIndex = from;
	    var toIndex = to;
	    if (fromIndex === toIndex) { return; }
	    // remove item from array
	    var item = vl.items.splice(fromIndex, 1)[0];
	    if (toIndex >= vl.items.length) {
	      // Add item to the end
	      vl.items.push(item);
	      toIndex = vl.items.length - 1;
	    } else {
	    // Add item to new index
	      vl.items.splice(toIndex, 0, item);
	    }
	    // Update cache
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        var cachedIndex = parseInt(cached, 10);
	        var leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
	        var rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
	        var indexShift = fromIndex < toIndex ? -1 : 1;
	        if (cachedIndex < leftIndex || cachedIndex > rightIndex) { newCache[cachedIndex] = vl.domCache[cachedIndex]; }
	        if (cachedIndex === leftIndex) { newCache[rightIndex] = vl.domCache[cachedIndex]; }
	        if (cachedIndex > leftIndex && cachedIndex <= rightIndex) { newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex]; }
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };
	  // Insert before
	  VirtualList.prototype.insertItemBefore = function insertItemBefore (index, item) {
	    var vl = this;
	    if (index === 0) {
	      vl.prependItem(item);
	      return;
	    }
	    if (index >= vl.items.length) {
	      vl.appendItem(item);
	      return;
	    }
	    vl.items.splice(index, 0, item);
	    // Update cache
	    if (vl.params.cache) {
	      var newCache = {};
	      Object.keys(vl.domCache).forEach(function (cached) {
	        var cachedIndex = parseInt(cached, 10);
	        if (cachedIndex >= index) {
	          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
	        }
	      });
	      vl.domCache = newCache;
	    }
	    vl.update();
	  };
	  // Delete
	  VirtualList.prototype.deleteItems = function deleteItems (indexes) {
	    var vl = this;
	    var prevIndex;
	    var indexShift = 0;
	    var loop = function ( i ) {
	      var index = indexes[i];
	      if (typeof prevIndex !== 'undefined') {
	        if (index > prevIndex) {
	          indexShift = -i;
	        }
	      }
	      index += indexShift;
	      prevIndex = indexes[i];
	      // Delete item
	      var deletedItem = vl.items.splice(index, 1)[0];

	      // Delete from filtered
	      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
	        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
	      }
	      // Update cache
	      if (vl.params.cache) {
	        var newCache = {};
	        Object.keys(vl.domCache).forEach(function (cached) {
	          var cachedIndex = parseInt(cached, 10);
	          if (cachedIndex === index) {
	            delete vl.domCache[index];
	          } else if (parseInt(cached, 10) > index) {
	            newCache[cachedIndex - 1] = vl.domCache[cached];
	          } else {
	            newCache[cachedIndex] = vl.domCache[cached];
	          }
	        });
	        vl.domCache = newCache;
	      }
	    };

	    for (var i = 0; i < indexes.length; i += 1) loop( i );
	    vl.update();
	  };
	  VirtualList.prototype.deleteAllItems = function deleteAllItems () {
	    var vl = this;
	    vl.items = [];
	    delete vl.filteredItems;
	    if (vl.params.cache) { vl.domCache = {}; }
	    vl.update();
	  };
	  VirtualList.prototype.deleteItem = function deleteItem (index) {
	    var vl = this;
	    vl.deleteItems([index]);
	  };
	  // Clear cache
	  VirtualList.prototype.clearCachefunction = function clearCachefunction () {
	    var vl = this;
	    vl.domCache = {};
	  };
	  // Update Virtual List
	  VirtualList.prototype.update = function update () {
	    var vl = this;
	    vl.setListSize();
	    vl.render(true);
	  };
	  VirtualList.prototype.init = function init () {
	    var vl = this;
	    vl.attachEvents();
	    vl.setListSize();
	    vl.render();
	  };
	  VirtualList.prototype.destroy = function destroy () {
	    var vl = this;
	    vl.detachEvents();
	    vl.$el[0].f7VirtualList = null;
	    delete vl.$el[0].f7VirtualList;
	    Utils.deleteProps(vl);
	    vl = null;
	  };

	  return VirtualList;
	}(Framework7Class));

	var VirtualList = {
	  name: 'virtualList',
	  static: {
	    VirtualList: VirtualList$1,
	  },
	  create: function create() {
	    var app = this;
	    app.virtualList = ConstructorMethods({
	      defaultSelector: '.virtual-list',
	      constructor: VirtualList$1,
	      app: app,
	      domProp: 'f7VirtualList',
	    });
	  },
	};

	var Timeline = {
	  name: 'timeline',
	};

	var Tab = {
	  show: function show() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var app = this;
	    var tabEl;
	    var tabLinkEl;
	    var animate;
	    var tabRoute;
	    if (args.length === 1 && args[0].constructor === Object) {
	      tabEl = args[0].tabEl;
	      tabLinkEl = args[0].tabLinkEl;
	      animate = args[0].animate;
	      tabRoute = args[0].tabRoute;
	    } else {
	      var assign;
	      (assign = args, tabEl = assign[0], tabLinkEl = assign[1], animate = assign[2], tabRoute = assign[3]);
	      if (typeof args[1] === 'boolean') {
	        var assign$1;
	        (assign$1 = args, tabEl = assign$1[0], animate = assign$1[1], tabLinkEl = assign$1[2], tabRoute = assign$1[3]);
	        if (args.length > 2 && tabLinkEl.constructor === Object) {
	          var assign$2;
	          (assign$2 = args, tabEl = assign$2[0], animate = assign$2[1], tabRoute = assign$2[2], tabLinkEl = assign$2[3]);
	        }
	      }
	    }
	    if (typeof animate === 'undefined') { animate = true; }

	    var $newTabEl = $$1$1(tabEl);

	    if ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active')) {
	      return {
	        $newTabEl: $newTabEl,
	        newTabEl: $newTabEl[0],
	      };
	    }

	    var $tabLinkEl;
	    if (tabLinkEl) { $tabLinkEl = $$1$1(tabLinkEl); }

	    var $tabsEl = $newTabEl.parent('.tabs');
	    if ($tabsEl.length === 0) {
	      return {
	        $newTabEl: $newTabEl,
	        newTabEl: $newTabEl[0],
	      };
	    }

	    // Release swipeouts in hidden tabs
	    if (app.swipeout) { app.swipeout.allowOpen = true; }

	    // Animated tabs
	    var tabsChangedCallbacks = [];

	    function onTabsChanged(callback) {
	      tabsChangedCallbacks.push(callback);
	    }
	    function tabsChanged() {
	      tabsChangedCallbacks.forEach(function (callback) {
	        callback();
	      });
	    }

	    var animated = false;

	    if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
	      $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');

	      var transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));
	      if (animate && transitionDuration) {
	        $tabsEl.transitionEnd(tabsChanged);
	        animated = true;
	      }

	      var tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
	      $tabsEl.transform(("translate3d(" + tabsTranslate + "%,0,0)"));
	    }

	    // Swipeable tabs
	    if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
	      var swiper = $tabsEl.parent()[0].swiper;
	      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
	        animated = true;
	        swiper
	          .once('slideChangeTransitionEnd', function () {
	            tabsChanged();
	          })
	          .slideTo($newTabEl.index(), animate ? undefined : 0);
	      }
	    }

	    // Remove active class from old tabs
	    var $oldTabEl = $tabsEl.children('.tab-active');
	    $oldTabEl
	      .removeClass('tab-active')
	      .trigger('tab:hide');
	    app.emit('tabHide', $oldTabEl[0]);

	    // Trigger 'show' event on new tab
	    $newTabEl
	      .addClass('tab-active')
	      .trigger('tab:show');
	    app.emit('tabShow', $newTabEl[0]);

	    // Find related link for new tab
	    if (!$tabLinkEl) {
	      // Search by id
	      if (typeof tabEl === 'string') { $tabLinkEl = $$1$1((".tab-link[href=\"" + tabEl + "\"]")); }
	      else { $tabLinkEl = $$1$1((".tab-link[href=\"#" + ($newTabEl.attr('id')) + "\"]")); }
	      // Search by data-tab
	      if (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0)) {
	        $$1$1('[data-tab]').each(function (index, el) {
	          if ($newTabEl.is($$1$1(el).attr('data-tab'))) { $tabLinkEl = $$1$1(el); }
	        });
	      }
	      if (tabRoute && (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0))) {
	        $tabLinkEl = $$1$1(("[data-route-tab-id=\"" + (tabRoute.route.tab.id) + "\"]"));
	        if ($tabLinkEl.length === 0) {
	          $tabLinkEl = $$1$1((".tab-link[href=\"" + (tabRoute.url) + "\"]"));
	        }
	      }
	      if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
	        // eslint-disable-next-line
	        $tabLinkEl = $tabLinkEl.filter(function (index, tabLinkElement) {
	          return $$1$1(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
	        });
	        if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
	          var $pageEl = $newTabEl.parents('.page');
	          var $navbarEl = $$1$1(app.navbar.getElByPage($pageEl));
	          $tabLinkEl = $navbarEl.find(("[data-route-tab-id=\"" + (tabRoute.route.tab.id) + "\"]"));
	          if ($tabLinkEl.length === 0) {
	            $tabLinkEl = $navbarEl.find((".tab-link[href=\"" + (tabRoute.url) + "\"]"));
	          }
	        }
	      }
	    }
	    if ($tabLinkEl.length > 0) {
	      // Find related link for old tab
	      var $oldTabLinkEl;
	      if ($oldTabEl && $oldTabEl.length > 0) {
	        // Search by id
	        var oldTabId = $oldTabEl.attr('id');
	        if (oldTabId) { $oldTabLinkEl = $$1$1((".tab-link[href=\"#" + oldTabId + "\"]")); }
	        // Search by data-tab
	        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
	          $$1$1('[data-tab]').each(function (index, tabLinkElement) {
	            if ($oldTabEl.is($$1$1(tabLinkElement).attr('data-tab'))) { $oldTabLinkEl = $$1$1(tabLinkElement); }
	          });
	        }
	        if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
	          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
	        }
	      } else if (tabRoute) {
	        $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
	      }

	      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
	        // eslint-disable-next-line
	        $oldTabLinkEl = $oldTabLinkEl.filter(function (index, tabLinkElement) {
	          return $$1$1(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
	        });
	      }

	      if ($oldTabLinkEl && $oldTabLinkEl.length > 0) { $oldTabLinkEl.removeClass('tab-link-active'); }

	      // Update links' classes
	      if ($tabLinkEl && $tabLinkEl.length > 0) {
	        $tabLinkEl.addClass('tab-link-active');
	        // Material Highlight
	        if (app.theme === 'md' && app.toolbar) {
	          var $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
	          if ($tabbarEl.length > 0) {
	            app.toolbar.setHighlight($tabbarEl);
	          }
	        }
	      }
	    }
	    return {
	      $newTabEl: $newTabEl,
	      newTabEl: $newTabEl[0],
	      $oldTabEl: $oldTabEl,
	      oldTabEl: $oldTabEl[0],
	      onTabsChanged: onTabsChanged,
	      animated: animated,
	    };
	  },
	};
	var Tabs = {
	  name: 'tabs',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      tab: {
	        show: Tab.show.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.tab-link': function tabLinkClick($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      if (($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0) || $clickedEl.attr('data-tab')) {
	        app.tab.show({
	          tabEl: data.tab || $clickedEl.attr('href'),
	          tabLinkEl: $clickedEl,
	          animate: data.animate,
	        });
	      }
	    },
	  },
	};

	function swipePanel$1(panel) {
	  var app = panel.app;
	  Utils.extend(panel, {
	    swipeable: true,
	    swipeInitialized: true,
	  });
	  var params = app.params.panel;
	  var $el = panel.$el;
	  var $backdropEl = panel.$backdropEl;
	  var side = panel.side;
	  var effect = panel.effect;
	  var otherPanel;

	  var isTouched;
	  var isMoved;
	  var isScrolling;
	  var touchesStart = {};
	  var touchStartTime;
	  var touchesDiff;
	  var translate;
	  var backdropOpacity;
	  var panelWidth;
	  var direction;

	  var $viewEl;

	  var touchMoves = 0;
	  function handleTouchStart(e) {
	    if (!panel.swipeable) { return; }
	    if (!app.panel.allowOpen || (!params.swipe && !params.swipeOnlyClose) || isTouched) { return; }
	    if ($$1$1('.modal-in, .photo-browser-in').length > 0) { return; }
	    otherPanel = app.panel[side === 'left' ? 'right' : 'left'] || {};
	    if (!panel.opened && otherPanel.opened) { return; }
	    if (!(params.swipeCloseOpposite || params.swipeOnlyClose)) {
	      if (otherPanel.opened) { return; }
	    }
	    if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') { return; }
	    if ($$1$1(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel').length > 0) { return; }
	    touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    if (params.swipeOnlyClose && !panel.opened) {
	      return;
	    }
	    if (params.swipe !== 'both' && params.swipeCloseOpposite && params.swipe !== side && !panel.opened) {
	      return;
	    }
	    if (params.swipeActiveArea && !panel.opened) {
	      if (side === 'left') {
	        if (touchesStart.x > params.swipeActiveArea) { return; }
	      }
	      if (side === 'right') {
	        if (touchesStart.x < app.width - params.swipeActiveArea) { return; }
	      }
	    }
	    touchMoves = 0;
	    $viewEl = $$1$1(panel.getViewEl());
	    isMoved = false;
	    isTouched = true;
	    isScrolling = undefined;

	    touchStartTime = Utils.now();
	    direction = undefined;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    touchMoves += 1;
	    if (touchMoves < 2) { return; }
	    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
	      isTouched = false;
	      return;
	    }
	    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (typeof isScrolling === 'undefined') {
	      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	    }
	    if (isScrolling) {
	      isTouched = false;
	      return;
	    }
	    if (!direction) {
	      if (pageX > touchesStart.x) {
	        direction = 'to-right';
	      } else {
	        direction = 'to-left';
	      }

	      if (params.swipe === 'both') {
	        if (params.swipeActiveArea > 0 && !panel.opened) {
	          if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
	            isTouched = false;
	            return;
	          }
	          if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
	            isTouched = false;
	            return;
	          }
	        }
	      }
	      if ($el.hasClass('panel-visible-by-breakpoint')) {
	        isTouched = false;
	        return;
	      }

	      if (
	        (side === 'left' &&
	          (
	            direction === 'to-left' && !$el.hasClass('panel-active')
	          )
	        )
	        ||
	        (side === 'right' &&
	          (
	            direction === 'to-right' && !$el.hasClass('panel-active')
	          )
	        )
	      ) {
	        isTouched = false;
	        return;
	      }
	    }

	    if (params.swipeNoFollow) {
	      var timeDiff = (new Date()).getTime() - touchStartTime;
	      if (timeDiff < 300) {
	        if (direction === 'to-left') {
	          if (side === 'right') { app.panel.open(side); }
	          if (side === 'left' && $el.hasClass('panel-active')) { app.panel.close(); }
	        }
	        if (direction === 'to-right') {
	          if (side === 'left') { app.panel.open(side); }
	          if (side === 'right' && $el.hasClass('panel-active')) { app.panel.close(); }
	        }
	      }
	      isTouched = false;
	      isMoved = false;
	      return;
	    }

	    if (!isMoved) {
	      if (!panel.opened) {
	        $el.show();
	        $backdropEl.show();
	        $el.trigger('panel:swipeopen', panel);
	        panel.emit('local::swipeOpen panelSwipeOpen', panel);
	      }
	      panelWidth = $el[0].offsetWidth;
	      $el.transition(0);
	    }

	    isMoved = true;

	    e.preventDefault();
	    var threshold = panel.opened ? 0 : -params.swipeThreshold;
	    if (side === 'right') { threshold = -threshold; }

	    touchesDiff = (pageX - touchesStart.x) + threshold;

	    if (side === 'right') {
	      if (effect === 'cover') {
	        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
	        if (translate < 0) { translate = 0; }
	        if (translate > panelWidth) {
	          translate = panelWidth;
	        }
	      } else {
	        translate = touchesDiff - (panel.opened ? panelWidth : 0);
	        if (translate > 0) { translate = 0; }
	        if (translate < -panelWidth) {
	          translate = -panelWidth;
	        }
	      }
	    } else {
	      translate = touchesDiff + (panel.opened ? panelWidth : 0);
	      if (translate < 0) { translate = 0; }
	      if (translate > panelWidth) {
	        translate = panelWidth;
	      }
	    }
	    if (effect === 'reveal') {
	      $viewEl.transform(("translate3d(" + translate + "px,0,0)")).transition(0);
	      $backdropEl.transform(("translate3d(" + translate + "px,0,0)")).transition(0);

	      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
	      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
	    } else {
	      if (side === 'left') { translate -= panelWidth; }
	      $el.transform(("translate3d(" + translate + "px,0,0)")).transition(0);

	      $backdropEl.transition(0);
	      backdropOpacity = 1 - Math.abs(translate / panelWidth);
	      $backdropEl.css({ opacity: backdropOpacity });

	      $el.trigger('panel:swipe', panel, Math.abs(translate / panelWidth));
	      panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
	    }
	  }
	  function handleTouchEnd() {
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    var timeDiff = (new Date()).getTime() - touchStartTime;
	    var action;
	    var edge = (translate === 0 || Math.abs(translate) === panelWidth);

	    if (!panel.opened) {
	      if (effect === 'cover') {
	        if (translate === 0) {
	          action = 'swap'; // open
	        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
	          action = 'swap'; // open
	        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
	          action = 'swap'; // open
	        } else {
	          action = 'reset'; // close
	        }
	      } else if (translate === 0) {
	        action = 'reset';
	      } else if (
	        (timeDiff < 300 && Math.abs(translate) > 0)
	        ||
	        (timeDiff >= 300 && (Math.abs(translate) >= panelWidth / 2))
	      ) {
	        action = 'swap';
	      } else {
	        action = 'reset';
	      }
	    } else if (effect === 'cover') {
	      if (translate === 0) {
	        action = 'reset'; // open
	      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
	        action = 'swap'; // open
	      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
	        action = 'reset'; // open
	      } else {
	        action = 'swap'; // close
	      }
	    } else if (translate === -panelWidth) {
	      action = 'reset';
	    } else if (
	      (timeDiff < 300 && Math.abs(translate) >= 0)
	      ||
	      (timeDiff >= 300 && (Math.abs(translate) <= panelWidth / 2))
	    ) {
	      if (side === 'left' && translate === panelWidth) { action = 'reset'; }
	      else { action = 'swap'; }
	    } else {
	      action = 'reset';
	    }
	    if (action === 'swap') {
	      if (panel.opened) {
	        panel.close(!edge);
	      } else {
	        panel.open(!edge);
	      }
	    }
	    if (action === 'reset') {
	      if (!panel.opened) {
	        if (edge) {
	          $el.css({ display: '' });
	        } else {
	          var target = effect === 'reveal' ? $viewEl : $el;
	          $$1$1('html').addClass('with-panel-transitioning');
	          target.transitionEnd(function () {
	            if ($el.hasClass('panel-active')) { return; }
	            $el.css({ display: '' });
	            $$1$1('html').removeClass('with-panel-transitioning');
	          });
	        }
	      }
	    }
	    if (effect === 'reveal') {
	      Utils.nextFrame(function () {
	        $viewEl.transition('');
	        $viewEl.transform('');
	      });
	    }
	    $el.transition('').transform('');
	    $backdropEl.css({ display: '' }).transform('').transition('').css('opacity', '');
	  }

	  // Add Events
	  app.on('touchstart:passive', handleTouchStart);
	  app.on('touchmove:active', handleTouchMove);
	  app.on('touchend:passive', handleTouchEnd);
	  panel.on('panelDestroy', function () {
	    app.off('touchstart:passive', handleTouchStart);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	  });
	}

	var Panel$1 = (function (Framework7Class$$1) {
	  function Panel(app, params) {
	    var obj;

	    if ( params === void 0 ) params = {};
	    Framework7Class$$1.call(this, params, [app]);
	    var panel = this;

	    var el = params.el;
	    var $el = $$1$1(el);
	    if ($el.length === 0) { return panel; }
	    if ($el[0].f7Panel) { return $el[0].f7Panel; }

	    $el[0].f7Panel = panel;

	    var opened = params.opened;
	    var side = params.side;
	    var effect = params.effect;
	    if (typeof opened === 'undefined') { opened = $el.hasClass('panel-active'); }
	    if (typeof side === 'undefined') { side = $el.hasClass('panel-left') ? 'left' : 'right'; }
	    if (typeof effect === 'undefined') { effect = $el.hasClass('panel-cover') ? 'cover' : 'reveal'; }

	    if (!app.panel[side]) {
	      Utils.extend(app.panel, ( obj = {}, obj[side] = panel, obj ));
	    }

	    var $backdropEl = $$1$1('.panel-backdrop');
	    if ($backdropEl.length === 0) {
	      $backdropEl = $$1$1('<div class="panel-backdrop"></div>');
	      $backdropEl.insertBefore($el);
	    }

	    Utils.extend(panel, {
	      app: app,
	      side: side,
	      effect: effect,
	      $el: $el,
	      el: $el[0],
	      opened: opened,
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl[0],
	    });

	    // Install Modules
	    panel.useModules();

	    // Init
	    panel.init();

	    return panel;
	  }

	  if ( Framework7Class$$1 ) Panel.__proto__ = Framework7Class$$1;
	  Panel.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Panel.prototype.constructor = Panel;
	  Panel.prototype.init = function init () {
	    var panel = this;
	    var app = panel.app;
	    if (app.params.panel[((panel.side) + "Breakpoint")]) {
	      panel.initBreakpoints();
	    }
	    {
	      if (
	        (app.params.panel.swipe === panel.side)
	        ||
	        (app.params.panel.swipe === 'both')
	        ||
	        (app.params.panel.swipe && app.params.panel.swipe !== panel.side && app.params.panel.swipeCloseOpposite)
	      ) {
	        panel.initSwipePanel();
	      }
	    }
	  };
	  Panel.prototype.getViewEl = function getViewEl () {
	    var panel = this;
	    var app = panel.app;
	    var viewEl;
	    if (app.root.children('.views').length > 0) {
	      viewEl = app.root.children('.views')[0];
	    } else {
	      viewEl = app.root.children('.view')[0];
	    }
	    return viewEl;
	  };
	  Panel.prototype.setBreakpoint = function setBreakpoint () {
	    var obj, obj$1;

	    var panel = this;
	    var app = panel.app;
	    var side = panel.side;
	    var $el = panel.$el;
	    var $viewEl = $$1$1(panel.getViewEl());
	    var breakpoint = app.params.panel[(side + "Breakpoint")];
	    var wasVisible = $el.hasClass('panel-visible-by-breakpoint');

	    if (app.width >= breakpoint) {
	      if (!wasVisible) {
	        $$1$1('html').removeClass(("with-panel-" + side + "-reveal with-panel-" + side + "-cover with-panel"));
	        $el.css('display', '').addClass('panel-visible-by-breakpoint').removeClass('panel-active');
	        panel.onOpen();
	        panel.onOpened();
	        $viewEl.css(( obj = {}, obj[("margin-" + side)] = (($el.width()) + "px"), obj ));
	        app.allowPanelOpen = true;
	        app.emit('local::breakpoint panelBreakpoint');
	        panel.$el.trigger('panel:breakpoint', panel);
	      }
	    } else if (wasVisible) {
	      $el.css('display', '').removeClass('panel-visible-by-breakpoint panel-active');
	      panel.onClose();
	      panel.onClosed();
	      $viewEl.css(( obj$1 = {}, obj$1[("margin-" + side)] = '', obj$1 ));
	      app.emit('local::breakpoint panelBreakpoint');
	      panel.$el.trigger('panel:breakpoint', panel);
	    }
	  };
	  Panel.prototype.initBreakpoints = function initBreakpoints () {
	    var panel = this;
	    var app = panel.app;
	    panel.resizeHandler = function resizeHandler() {
	      panel.setBreakpoint();
	    };
	    if (app.params.panel[((panel.side) + "Breakpoint")]) {
	      app.on('resize', panel.resizeHandler);
	    }
	    panel.setBreakpoint();
	    return panel;
	  };
	  Panel.prototype.initSwipePanel = function initSwipePanel () {
	    {
	      swipePanel$1(this);
	    }
	  };
	  Panel.prototype.destroy = function destroy () {
	    var panel = this;
	    var app = panel.app;

	    panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
	    panel.$el.trigger('panel:beforedestroy', panel);

	    if (panel.resizeHandler) {
	      app.off('resize', panel.resizeHandler);
	    }
	    panel.$el.trigger('panel:destroy', panel);
	    panel.emit('local::destroy panelDestroy');
	    delete app.panel[panel.side];
	    delete panel.el.f7Panel;
	    Utils.deleteProps(panel);
	    panel = null;
	  };
	  Panel.prototype.open = function open (animate) {
	    if ( animate === void 0 ) animate = true;

	    var panel = this;
	    var app = panel.app;
	    if (!app.panel.allowOpen) { return false; }

	    var side = panel.side;
	    var effect = panel.effect;
	    var $el = panel.$el;
	    var $backdropEl = panel.$backdropEl;
	    var opened = panel.opened;

	    // Ignore if opened
	    if (opened || $el.hasClass('panel-visible-by-breakpoint') || $el.hasClass('panel-active')) { return false; }

	    // Close if some panel is opened
	    app.panel.close(side === 'left' ? 'right' : 'left', animate);

	    app.panel.allowOpen = false;

	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    $el
	      .css({ display: 'block' })
	      .addClass('panel-active');

	    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
	    $backdropEl.show();

	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    panel._clientLeft = $el[0].clientLeft;

	    $$1$1('html').addClass(("with-panel with-panel-" + side + "-" + effect));
	    panel.onOpen();

	    // Transition End;
	    var transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

	    function panelTransitionEnd() {
	      transitionEndTarget.transitionEnd(function (e) {
	        if ($$1$1(e.target).is(transitionEndTarget)) {
	          if ($el.hasClass('panel-active')) {
	            panel.onOpened();
	            $backdropEl.css({ display: '' });
	          } else {
	            panel.onClosed();
	            $backdropEl.css({ display: '' });
	          }
	        } else { panelTransitionEnd(); }
	      });
	    }
	    if (animate) {
	      panelTransitionEnd();
	    } else {
	      panel.onOpened();
	      $backdropEl.css({ display: '' });
	    }

	    return true;
	  };
	  Panel.prototype.close = function close (animate) {
	    if ( animate === void 0 ) animate = true;

	    var panel = this;
	    var app = panel.app;

	    var side = panel.side;
	    var effect = panel.effect;
	    var $el = panel.$el;
	    var $backdropEl = panel.$backdropEl;
	    var opened = panel.opened;

	    if (!opened || $el.hasClass('panel-visible-by-breakpoint') || !$el.hasClass('panel-active')) { return false; }

	    $el[animate ? 'removeClass' : 'addClass']('not-animated');
	    $el.removeClass('panel-active');

	    $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');

	    var transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

	    panel.onClose();
	    app.panel.allowOpen = false;

	    if (animate) {
	      transitionEndTarget.transitionEnd(function () {
	        if ($el.hasClass('panel-active')) { return; }
	        $el.css({ display: '' });
	        $$1$1('html').removeClass('with-panel-transitioning');
	        panel.onClosed();
	      });
	      $$1$1('html')
	        .removeClass(("with-panel with-panel-" + side + "-" + effect))
	        .addClass('with-panel-transitioning');
	    } else {
	      $el.css({ display: '' });
	      $el.removeClass('not-animated');
	      $$1$1('html').removeClass(("with-panel with-panel-transitioning with-panel-" + side + "-" + effect));
	      panel.onClosed();
	    }
	    return true;
	  };
	  Panel.prototype.onOpen = function onOpen () {
	    var panel = this;
	    panel.opened = true;
	    panel.$el.trigger('panel:open', panel);
	    panel.emit('local::open panelOpen', panel);
	  };
	  Panel.prototype.onOpened = function onOpened () {
	    var panel = this;
	    var app = panel.app;
	    app.panel.allowOpen = true;

	    panel.$el.trigger('panel:opened', panel);
	    panel.emit('local::opened panelOpened', panel);
	  };
	  Panel.prototype.onClose = function onClose () {
	    var panel = this;
	    panel.opened = false;
	    panel.$el.addClass('panel-closing');
	    panel.$el.trigger('panel:close', panel);
	    panel.emit('local::close panelClose', panel);
	  };
	  Panel.prototype.onClosed = function onClosed () {
	    var panel = this;
	    var app = panel.app;
	    app.panel.allowOpen = true;
	    panel.$el.removeClass('panel-closing');
	    panel.$el.trigger('panel:closed', panel);
	    panel.emit('local::closed panelClosed', panel);
	  };

	  return Panel;
	}(Framework7Class));

	var Panel = {
	  name: 'panel',
	  params: {
	    panel: {
	      leftBreakpoint: 0,
	      rightBreakpoint: 0,
	      swipe: undefined, // or 'left' or 'right' or 'both'
	      swipeActiveArea: 0,
	      swipeCloseOpposite: true,
	      swipeOnlyClose: false,
	      swipeNoFollow: false,
	      swipeThreshold: 0,
	      closeByBackdropClick: true,
	    },
	  },
	  static: {
	    Panel: Panel$1,
	  },
	  instance: {
	    panel: {
	      allowOpen: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app.panel, {
	      disableSwipe: function disableSwipe(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var side;
	        var panels = [];
	        if (typeof panel === 'string') {
	          if (panel === 'both') {
	            side = 'both';
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            side = panel;
	            panels = app.panel[side];
	          }
	        } else {
	          panels = [panel];
	        }
	        panels.forEach(function (panelInstance) {
	          if (panelInstance) { Utils.extend(panelInstance, { swipeable: false }); }
	        });
	      },
	      enableSwipe: function enableSwipe(panel) {
	        if ( panel === void 0 ) panel = 'both';

	        var panels = [];
	        var side;
	        if (typeof panel === 'string') {
	          side = panel;
	          if (
	            (app.params.panel.swipe === 'left' && side === 'right') ||
	            (app.params.panel.swipe === 'right' && side === 'left') ||
	            side === 'both'
	          ) {
	            side = 'both';
	            app.params.panel.swipe = side;
	            panels = [app.panel.left, app.panel.right];
	          } else {
	            app.params.panel.swipe = side;
	            panels.push(app.panel[side]);
	          }
	        } else if (panel) {
	          panels.push(panel);
	        }
	        if (panels.length) {
	          panels.forEach(function (panelInstance) {
	            if (!panelInstance) { return; }
	            if (!panelInstance.swipeInitialized) {
	              panelInstance.initSwipePanel();
	            } else {
	              Utils.extend(panelInstance, { swipeable: true });
	            }
	          });
	        }
	      },
	      create: function create(params) {
	        return new Panel$1(app, params);
	      },
	      open: function open(side, animate) {
	        var panelSide = side;
	        if (!panelSide) {
	          if ($$1$1('.panel').length > 1) {
	            return false;
	          }
	          panelSide = $$1$1('.panel').hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return false; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide].open(animate);
	        }
	        var $panelEl = $$1$1((".panel-" + panelSide));
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl }).open(animate);
	        }
	        return false;
	      },
	      close: function close(side, animate) {
	        var $panelEl;
	        var panelSide;
	        if (panelSide) {
	          panelSide = side;
	          $panelEl = $$1$1((".panel-" + panelSide));
	        } else {
	          $panelEl = $$1$1('.panel.panel-active');
	          panelSide = $panelEl.hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return false; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide].close(animate);
	        }
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl }).close(animate);
	        }
	        return false;
	      },
	      get: function get(side) {
	        var panelSide = side;
	        if (!panelSide) {
	          if ($$1$1('.panel').length > 1) {
	            return undefined;
	          }
	          panelSide = $$1$1('.panel').hasClass('panel-left') ? 'left' : 'right';
	        }
	        if (!panelSide) { return undefined; }
	        if (app.panel[panelSide]) {
	          return app.panel[panelSide];
	        }
	        var $panelEl = $$1$1((".panel-" + panelSide));
	        if ($panelEl.length > 0) {
	          return app.panel.create({ el: $panelEl });
	        }
	        return undefined;
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;

	      // Create Panels
	      $$1$1('.panel').each(function (index, panelEl) {
	        var side = $$1$1(panelEl).hasClass('panel-left') ? 'left' : 'right';
	        app.panel[side] = app.panel.create({ el: panelEl, side: side });
	      });
	    },
	  },
	  clicks: {
	    '.panel-open': function open(clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var side = 'left';
	      if (data.panel === 'right' || ($$1$1('.panel').length === 1 && $$1$1('.panel').hasClass('panel-right'))) {
	        side = 'right';
	      }
	      app.panel.open(side, data.animate);
	    },
	    '.panel-close': function close(clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var side = data.panel;
	      app.panel.close(side, data.animate);
	    },
	    '.panel-backdrop': function close() {
	      var app = this;
	      var $panelEl = $$1$1('.panel-active');
	      var instance = $panelEl[0] && $panelEl[0].f7Panel;
	      $panelEl.trigger('panel:backdrop-click');
	      if (instance) {
	        instance.emit('backdropClick', instance);
	      }
	      app.emit('panelBackdropClick', instance || $panelEl[0]);
	      if (app.params.panel.closeByBackdropClick) { app.panel.close(); }
	    },
	  },
	};

	var Card = {
	  name: 'card',
	};

	var Chip = {
	  name: 'chip',
	};

	// Form Data
	var FormData$1 = {
	  store: function store(form, data) {
	    var app = this;
	    var formId = form;

	    var $formEl = $$1$1(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }
	    // Store form data in app.formsData
	    app.form.data[("form-" + formId)] = data;

	    // Store form data in local storage also
	    try {
	      window.localStorage[("f7form-" + formId)] = JSON.stringify(data);
	    } catch (e) {
	      throw e;
	    }
	  },
	  get: function get(form) {
	    var app = this;
	    var formId = form;

	    var $formEl = $$1$1(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }

	    try {
	      if (window.localStorage[("f7form-" + formId)]) {
	        return JSON.parse(window.localStorage[("f7form-" + formId)]);
	      }
	    } catch (e) {
	      throw e;
	    }
	    if (app.form.data[("form-" + formId)]) {
	      return app.form.data[("form-" + formId)];
	    }
	    return undefined;
	  },
	  remove: function remove(form) {
	    var app = this;
	    var formId = form;

	    var $formEl = $$1$1(form);
	    if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
	      formId = $formEl.attr('id');
	    }

	    // Delete form data from app.formsData
	    if (app.form.data[("form-" + formId)]) {
	      app.form.data[("form-" + formId)] = '';
	      delete app.form.data[("form-" + formId)];
	    }

	    // Delete form data from local storage also
	    try {
	      if (window.localStorage[("f7form-" + formId)]) {
	        window.localStorage[("f7form-" + formId)] = '';
	        window.localStorage.removeItem(("f7form-" + formId));
	      }
	    } catch (e) {
	      throw e;
	    }
	  },
	};

	// Form Storage
	var FormStorage = {
	  init: function init(formEl) {
	    var app = this;
	    var $formEl = $$1$1(formEl);
	    var formId = $formEl.attr('id');
	    if (!formId) { return; }
	    var initialData = app.form.getFormData(formId);
	    if (initialData) {
	      app.form.fillFromData($formEl, initialData);
	    }
	    function store() {
	      var data = app.form.convertToData($formEl);
	      if (!data) { return; }
	      app.form.storeFormData(formId, data);
	      $formEl.trigger('form:storedata', data);
	      app.emit('formStoreData', $formEl[0], data);
	    }
	    $formEl.on('change submit', store);
	  },
	  destroy: function destroy(formEl) {
	    var $formEl = $$1$1(formEl);
	    $formEl.off('change submit');
	  },
	};

	// Form To/From Data
	function formToData(formEl) {
	  var app = this;
	  var $formEl = $$1$1(formEl).eq(0);
	  if ($formEl.length === 0) { return undefined; }

	  // Form data
	  var data = {};

	  // Skip input types
	  var skipTypes = ['submit', 'image', 'button', 'file'];
	  var skipNames = [];
	  $formEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	    var $inputEl = $$1$1(inputEl);
	    var name = $inputEl.attr('name');
	    var type = $inputEl.attr('type');
	    var tag = inputEl.nodeName.toLowerCase();
	    if (skipTypes.indexOf(type) >= 0) { return; }
	    if (skipNames.indexOf(name) >= 0 || !name) { return; }
	    if (tag === 'select' && $inputEl.prop('multiple')) {
	      skipNames.push(name);
	      data[name] = [];
	      $formEl.find(("select[name=\"" + name + "\"] option")).each(function (index, el) {
	        if (el.selected) { data[name].push(el.value); }
	      });
	    } else {
	      switch (type) {
	        case 'checkbox':
	          skipNames.push(name);
	          data[name] = [];
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            if (el.checked) { data[name].push(el.value); }
	          });
	          break;
	        case 'radio':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            if (el.checked) { data[name] = el.value; }
	          });
	          break;
	        default:
	          data[name] = $inputEl.val();
	          break;
	      }
	    }
	  });
	  $formEl.trigger('form:todata', data);
	  app.emit('formToData', $formEl[0], data);

	  return data;
	}
	function formFromData(formEl, formData) {
	  var app = this;
	  var $formEl = $$1$1(formEl).eq(0);
	  if (!$formEl.length) { return; }

	  var data = formData;
	  var formId = $formEl.attr('id');

	  if (!data && formId) {
	    data = app.form.getFormData(formId);
	  }

	  if (!data) { return; }

	  // Skip input types
	  var skipTypes = ['submit', 'image', 'button', 'file'];
	  var skipNames = [];

	  $formEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	    var $inputEl = $$1$1(inputEl);
	    var name = $inputEl.attr('name');
	    var type = $inputEl.attr('type');
	    var tag = inputEl.nodeName.toLowerCase();
	    if (typeof data[name] === 'undefined' || data[name] === null) { return; }
	    if (skipTypes.indexOf(type) >= 0) { return; }
	    if (skipNames.indexOf(name) >= 0 || !name) { return; }
	    if (tag === 'select' && $inputEl.prop('multiple')) {
	      skipNames.push(name);
	      $formEl.find(("select[name=\"" + name + "\"] option")).each(function (index, el) {
	        var selectEl = el;
	        if (data[name].indexOf(el.value) >= 0) { selectEl.selected = true; }
	        else { selectEl.selected = false; }
	      });
	    } else {
	      switch (type) {
	        case 'checkbox':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            var checkboxEl = el;
	            if (data[name].indexOf(el.value) >= 0) { checkboxEl.checked = true; }
	            else { checkboxEl.checked = false; }
	          });
	          break;
	        case 'radio':
	          skipNames.push(name);
	          $formEl.find(("input[name=\"" + name + "\"]")).each(function (index, el) {
	            var radioEl = el;
	            if (data[name] === el.value) { radioEl.checked = true; }
	            else { radioEl.checked = false; }
	          });
	          break;
	        default:
	          $inputEl.val(data[name]);
	          break;
	      }
	    }
	    if (tag === 'select' || tag === 'input' || tag === 'textarea') {
	      $inputEl.trigger('change', 'fromdata');
	    }
	  });
	  $formEl.trigger('form:fromdata', data);
	  app.emit('formFromData', $formEl[0], data);
	}

	function initAjaxForm() {
	  var app = this;

	  function onSubmitChange(e, fromData) {
	    var $formEl = $$1$1(this);
	    if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) { return; }
	    if (e.type === 'submit') { e.preventDefault(); }

	    if (e.type === 'change' && fromData === 'fromdata') { return; }

	    var method = ($formEl.attr('method') || 'GET').toUpperCase();
	    var contentType = $formEl.prop('enctype') || $formEl.attr('enctype');

	    var url = $formEl.attr('action');
	    if (!url) { return; }

	    var data;
	    if (method === 'POST') { data = new window.FormData($formEl[0]); }
	    else { data = Utils.serializeObject(app.form.convertToData($formEl[0])); }

	    var xhr = app.request({
	      method: method,
	      url: url,
	      contentType: contentType,
	      data: data,
	      beforeSend: function beforeSend() {
	        $formEl.trigger('formajax:beforesend', data, xhr);
	        app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
	      },
	      error: function error() {
	        $formEl.trigger('formajax:error', data, xhr);
	        app.emit('formAjaxError', $formEl[0], data, xhr);
	      },
	      complete: function complete() {
	        $formEl.trigger('formajax:complete', data, xhr);
	        app.emit('formAjaxComplete', $formEl[0], data, xhr);
	      },
	      success: function success() {
	        $formEl.trigger('formajax:success', data, xhr);
	        app.emit('formAjaxSuccess', $formEl[0], data, xhr);
	      },
	    });
	  }
	  $$1$1(document).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
	}

	var Form = {
	  name: 'form',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      form: {
	        data: {},
	        storeFormData: FormData$1.store.bind(app),
	        getFormData: FormData$1.get.bind(app),
	        removeFormData: FormData$1.remove.bind(app),
	        convertToData: formToData.bind(app),
	        fillFromData: formFromData.bind(app),
	        storage: {
	          init: FormStorage.init.bind(app),
	          destroy: FormStorage.destroy.bind(app),
	        },
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      initAjaxForm.call(app);
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.destroy(formEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.init(formEl);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.destroy(formEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.form-store-data').each(function (index, formEl) {
	        app.form.storage.init(formEl);
	      });
	    },
	  },
	};

	var Input = {
	  ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
	  createTextareaResizableShadow: function createTextareaResizableShadow() {
	    var $shadowEl = $$1$1(document.createElement('textarea'));
	    $shadowEl.addClass('textarea-resizable-shadow');
	    $shadowEl.prop({
	      disabled: true,
	      readonly: true,
	    });
	    Input.textareaResizableShadow = $shadowEl;
	  },
	  textareaResizableShadow: undefined,
	  resizeTextarea: function resizeTextarea(textareaEl) {
	    var app = this;
	    var $textareaEl = $$1$1(textareaEl);
	    if (!Input.textareaResizableShadow) {
	      Input.createTextareaResizableShadow();
	    }
	    var $shadowEl = Input.textareaResizableShadow;
	    if (!$textareaEl.length) { return; }
	    if (!$textareaEl.hasClass('resizable')) { return; }
	    if (Input.textareaResizableShadow.parents().length === 0) {
	      app.root.append($shadowEl);
	    }

	    var styles = window.getComputedStyle($textareaEl[0]);
	    ('padding margin width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display').split(' ').forEach(function (style) {
	      var styleValue = styles[style];
	      if (('font-size line-height letter-spacing width').split(' ').indexOf(style) >= 0) {
	        styleValue = styleValue.replace(',', '.');
	      }
	      $shadowEl.css(style, styleValue);
	    });
	    var currentHeight = $textareaEl[0].clientHeight;

	    $shadowEl.val('');
	    var initialHeight = $shadowEl[0].scrollHeight;

	    $shadowEl.val($textareaEl.val());
	    $shadowEl.css('height', 0);
	    var scrollHeight = $shadowEl[0].scrollHeight;

	    if (currentHeight !== scrollHeight) {
	      if (scrollHeight > initialHeight) {
	        $textareaEl.css('height', (scrollHeight + "px"));
	        $textareaEl.trigger('textarea:resize', { initialHeight: initialHeight, currentHeight: currentHeight, scrollHeight: scrollHeight });
	      } else if (scrollHeight < currentHeight) {
	        $textareaEl.css('height', '');
	        $textareaEl.trigger('textarea:resize', { initialHeight: initialHeight, currentHeight: currentHeight, scrollHeight: scrollHeight });
	      }
	    }
	  },
	  validate: function validate(inputEl) {
	    var $inputEl = $$1$1(inputEl);
	    if (!$inputEl.length) { return; }
	    var $itemInputEl = $inputEl.parents('.item-input');
	    var validity = $inputEl[0].validity;
	    var validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';
	    if (!validity) { return; }
	    if (!validity.valid) {
	      var $errorEl = $inputEl.nextAll('.item-input-error-message');
	      if (validationMessage) {
	        if ($errorEl.length === 0) {
	          $errorEl = $$1$1('<div class="item-input-error-message"></div>');
	          $errorEl.insertAfter($inputEl);
	        }
	        $errorEl.text(validationMessage);
	      }
	      if ($errorEl.length > 0) {
	        $itemInputEl.addClass('item-input-with-error-message');
	      }
	      $itemInputEl.addClass('item-input-invalid');
	      $inputEl.addClass('input-invalid');
	    } else {
	      $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
	      $inputEl.removeClass('input-invalid');
	    }
	  },
	  validateInputs: function validateInputs(el) {
	    var app = this;
	    $$1$1(el).find('input, textarea, select').each(function (index, inputEl) {
	      app.input.validate(inputEl);
	    });
	  },
	  focus: function focus(inputEl) {
	    var $inputEl = $$1$1(inputEl);
	    var type = $inputEl.attr('type');
	    if (Input.ignoreTypes.indexOf(type) >= 0) { return; }
	    var $itemInputEl = $inputEl.parents('.item-input');
	    $itemInputEl.addClass('item-input-focused');
	    $inputEl.addClass('input-focused');
	  },
	  blur: function blur(inputEl) {
	    $$1$1(inputEl).parents('.item-input').removeClass('item-input-focused');
	    $$1$1(inputEl).removeClass('input-focused');
	  },
	  checkEmptyState: function checkEmptyState(inputEl) {
	    var $inputEl = $$1$1(inputEl);
	    var value = $inputEl.val();
	    var $itemInputEl = $inputEl.parents('.item-input');
	    if ((value && (typeof value === 'string' && value.trim() !== '')) || (Array.isArray(value) && value.length > 0)) {
	      $itemInputEl.addClass('item-input-with-value');
	      $inputEl.addClass('input-with-value');
	      $inputEl.trigger('input:notempty');
	    } else {
	      $itemInputEl.removeClass('item-input-with-value');
	      $inputEl.removeClass('input-with-value');
	      $inputEl.trigger('input:empty');
	    }
	  },
	  scrollIntoView: function scrollIntoView(inputEl, duration, centered) {
	    if ( duration === void 0 ) duration = 0;

	    var $inputEl = $$1$1(inputEl);
	    var $scrollableEl = $inputEl.parents('.page-content, .panel').eq(0);
	    if (!$scrollableEl.length) {
	      return false;
	    }
	    var contentHeight = $scrollableEl[0].offsetHeight;
	    var contentScrollTop = $scrollableEl[0].scrollTop;
	    var contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
	    var contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
	    var contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;

	    var inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
	    var inputHeight = $inputEl[0].offsetHeight;

	    var min = (inputOffsetTop + contentScrollTop) - contentPaddingTop;
	    var max = ((inputOffsetTop + contentScrollTop) - contentHeight) + contentPaddingBottom + inputHeight;
	    var centeredPosition = min + ((max - min) / 2);

	    if (contentScrollTop > min) {
	      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
	      return true;
	    } else if (contentScrollTop < max) {
	      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
	      return true;
	    }
	    return false;
	  },
	  init: function init() {
	    var app = this;
	    Input.createTextareaResizableShadow();
	    function onFocus() {
	      var inputEl = this;
	      if (app.params.input.scrollIntoViewOnFocus) {
	        if (Device.android) {
	          $$1$1(window).once('resize', function () {
	            if (document && document.activeElement === inputEl) {
	              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewCentered);
	            }
	          });
	        } else {
	          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewCentered);
	        }
	      }
	      app.input.focus(inputEl);
	    }
	    function onBlur() {
	      var $inputEl = $$1$1(this);
	      var tag = $inputEl[0].nodeName.toLowerCase();
	      app.input.blur($inputEl);
	      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
	        app.input.validate($inputEl);
	      }
	      // Resize textarea
	      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
	        if (Input.textareaResizableShadow) { Input.textareaResizableShadow.remove(); }
	      }
	    }
	    function onChange() {
	      var $inputEl = $$1$1(this);
	      var type = $inputEl.attr('type');
	      var tag = $inputEl[0].nodeName.toLowerCase();
	      if (Input.ignoreTypes.indexOf(type) >= 0) { return; }

	      // Check Empty State
	      app.input.checkEmptyState($inputEl);

	      // Check validation
	      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
	        app.input.validate($inputEl);
	      }

	      // Resize textarea
	      if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
	        app.input.resizeTextarea($inputEl);
	      }
	    }
	    function onInvalid(e) {
	      var $inputEl = $$1$1(this);
	      if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null) {
	        e.preventDefault();
	        app.input.validate($inputEl);
	      }
	    }
	    function clearInput() {
	      var $clicked = $$1$1(this);
	      var $inputEl = $clicked.siblings('input, textarea').eq(0);
	      var previousValue = $inputEl.val();
	      $inputEl
	        .val('')
	        .trigger('change')
	        .focus()
	        .trigger('input:clear', previousValue);
	    }
	    $$1$1(document).on('click', '.input-clear-button', clearInput);
	    $$1$1(document).on('change input', 'input, textarea, select', onChange, true);
	    $$1$1(document).on('focus', 'input, textarea, select', onFocus, true);
	    $$1$1(document).on('blur', 'input, textarea, select', onBlur, true);
	    $$1$1(document).on('invalid', 'input, textarea, select', onInvalid, true);
	  },
	};

	var Input$1 = {
	  name: 'input',
	  params: {
	    input: {
	      scrollIntoViewOnFocus: Device.android,
	      scrollIntoViewCentered: false,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      input: {
	        scrollIntoView: Input.scrollIntoView.bind(app),
	        focus: Input.focus.bind(app),
	        blur: Input.blur.bind(app),
	        validate: Input.validate.bind(app),
	        validateInputs: Input.validateInputs.bind(app),
	        checkEmptyState: Input.checkEmptyState.bind(app),
	        resizeTextarea: Input.resizeTextarea.bind(app),
	        init: Input.init.bind(app),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      app.input.init();
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $$1$1(tabEl);
	      $tabEl.find('.item-input').each(function (itemInputIndex, itemInputEl) {
	        var $itemInputEl = $$1$1(itemInputEl);
	        $itemInputEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	          var $inputEl = $$1$1(inputEl);
	          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) { return; }
	          app.input.checkEmptyState($inputEl);
	        });
	      });
	      $tabEl.find('textarea.resizable').each(function (textareaIndex, textareaEl) {
	        app.input.resizeTextarea(textareaEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      var $pageEl = page.$el;
	      $pageEl.find('.item-input').each(function (itemInputIndex, itemInputEl) {
	        var $itemInputEl = $$1$1(itemInputEl);
	        $itemInputEl.find('input, select, textarea').each(function (inputIndex, inputEl) {
	          var $inputEl = $$1$1(inputEl);
	          if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) { return; }
	          app.input.checkEmptyState($inputEl);
	        });
	      });
	      $pageEl.find('textarea.resizable').each(function (textareaIndex, textareaEl) {
	        app.input.resizeTextarea(textareaEl);
	      });
	    },
	  },
	};

	var Checkbox = {
	  name: 'checkbox',
	};

	var Radio = {
	  name: 'radio',
	};

	var Toggle$1 = (function (Framework7Class$$1) {
	  function Toggle(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var toggle = this;

	    var defaults = {};

	    // Extend defaults with modules params
	    toggle.useModulesParams(defaults);

	    toggle.params = Utils.extend(defaults, params);

	    var el = toggle.params.el;
	    if (!el) { return toggle; }

	    var $el = $$1$1(el);
	    if ($el.length === 0) { return toggle; }


	    var $inputEl = $el.children('input[type="checkbox"]');

	    Utils.extend(toggle, {
	      app: app,
	      $el: $el,
	      el: $el[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl[0],
	      disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled,
	    });

	    Object.defineProperty(toggle, 'checked', {
	      enumerable: true,
	      configurable: true,
	      set: function set(checked) {
	        if (!toggle || typeof toggle.$inputEl === 'undefined') { return; }
	        if (toggle.checked === checked) { return; }
	        $inputEl[0].checked = checked;
	        toggle.$inputEl.trigger('change');
	      },
	      get: function get() {
	        return $inputEl[0].checked;
	      },
	    });

	    $el[0].f7Toggle = toggle;

	    var isTouched;
	    var touchesStart = {};
	    var isScrolling;
	    var touchesDiff;
	    var toggleWidth;
	    var touchStartTime;
	    var touchStartChecked;
	    function handleTouchStart(e) {
	      if (isTouched || toggle.disabled) { return; }
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	      touchesDiff = 0;

	      isTouched = true;
	      isScrolling = undefined;
	      touchStartTime = Utils.now();
	      touchStartChecked = toggle.checked;

	      toggleWidth = $el[0].offsetWidth;
	      Utils.nextTick(function () {
	        if (isTouched) {
	          $el.addClass('toggle-active-state');
	        }
	      });
	    }
	    function handleTouchMove(e) {
	      if (!isTouched || toggle.disabled) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      var inverter = app.rtl ? -1 : 1;

	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();

	      touchesDiff = pageX - touchesStart.x;


	      var changed;
	      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
	        changed = true;
	      }
	      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
	        changed = true;
	      }
	      if (changed) {
	        touchesStart.x = pageX;
	        toggle.checked = !touchStartChecked;
	        touchStartChecked = !touchStartChecked;
	      }
	    }
	    function handleTouchEnd() {
	      if (!isTouched || toggle.disabled) {
	        if (isScrolling) { $el.removeClass('toggle-active-state'); }
	        isTouched = false;
	        return;
	      }
	      var inverter = app.rtl ? -1 : 1;
	      isTouched = false;

	      $el.removeClass('toggle-active-state');

	      var changed;
	      if ((Utils.now() - touchStartTime) < 300) {
	        if (touchesDiff * inverter < 0 && touchStartChecked) {
	          changed = true;
	        }
	        if (touchesDiff * inverter > 0 && !touchStartChecked) {
	          changed = true;
	        }
	        if (changed) {
	          toggle.checked = !touchStartChecked;
	        }
	      }
	    }
	    function handleInputChange() {
	      toggle.$el.trigger('toggle:change', toggle);
	      toggle.emit('local::change toggleChange', toggle);
	    }
	    toggle.attachEvents = function attachEvents() {
	      {
	        if (!Support.touch) { return; }
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $el.on(app.touchEvents.start, handleTouchStart, passive);
	        app.on('touchmove', handleTouchMove);
	        app.on('touchend:passive', handleTouchEnd);
	      }
	      toggle.$inputEl.on('change', handleInputChange);
	    };
	    toggle.detachEvents = function detachEvents() {
	      {
	        if (!Support.touch) { return; }
	        var passive = Support.passiveListener ? { passive: true } : false;
	        $el.off(app.touchEvents.start, handleTouchStart, passive);
	        app.off('touchmove', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      }
	      toggle.$inputEl.off('change', handleInputChange);
	    };


	    // Install Modules
	    toggle.useModules();

	    // Init
	    toggle.init();
	  }

	  if ( Framework7Class$$1 ) Toggle.__proto__ = Framework7Class$$1;
	  Toggle.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Toggle.prototype.constructor = Toggle;
	  Toggle.prototype.toggle = function toggle () {
	    var toggle = this;
	    toggle.checked = !toggle.checked;
	  };
	  Toggle.prototype.init = function init () {
	    var toggle = this;
	    toggle.attachEvents();
	  };
	  Toggle.prototype.destroy = function destroy () {
	    var toggle = this;
	    toggle.$el.trigger('toggle:beforedestroy', toggle);
	    toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
	    delete toggle.$el[0].f7Toggle;
	    toggle.detachEvents();
	    Utils.deleteProps(toggle);
	    toggle = null;
	  };

	  return Toggle;
	}(Framework7Class));

	var Toggle = {
	  name: 'toggle',
	  create: function create() {
	    var app = this;
	    app.toggle = ConstructorMethods({
	      defaultSelector: '.toggle',
	      constructor: Toggle$1,
	      app: app,
	      domProp: 'f7Toggle',
	    });
	  },
	  static: {
	    Toggle: Toggle$1,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.toggle-init').each(function (index, toggleEl) { return app.toggle.create({ el: toggleEl }); });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $$1$1(tabEl).find('.toggle-init').each(function (index, toggleEl) {
	        if (toggleEl.f7Toggle) { toggleEl.f7Toggle.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.toggle-init').each(function (index, toggleEl) { return app.toggle.create({ el: toggleEl }); });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.toggle-init').each(function (index, toggleEl) {
	        if (toggleEl.f7Toggle) { toggleEl.f7Toggle.destroy(); }
	      });
	    },
	  },
	};

	var Range$1 = (function (Framework7Class$$1) {
	  function Range(app, params) {
	    Framework7Class$$1.call(this, params, [app]);
	    var range = this;
	    var defaults = {
	      dual: false,
	      step: 1,
	      label: false,
	    };

	    // Extend defaults with modules params
	    range.useModulesParams(defaults);

	    range.params = Utils.extend(defaults, params);

	    var el = range.params.el;
	    if (!el) { return range; }

	    var $el = $$1$1(el);
	    if ($el.length === 0) { return range; }

	    var dataset = $el.dataset();

	    ('step min max value').split(' ').forEach(function (paramName) {
	      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
	        range.params[paramName] = parseFloat(dataset[paramName]);
	      }
	    });
	    ('dual label').split(' ').forEach(function (paramName) {
	      if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
	        range.params[paramName] = dataset[paramName];
	      }
	    });


	    if (!range.params.value) {
	      if (typeof dataset.value !== 'undefined') { range.params.value = dataset.value; }
	      if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
	        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
	      }
	    }

	    var $inputEl;
	    if (!range.params.dual) {
	      if (range.params.inputEl) {
	        $inputEl = $$1$1(range.params.inputEl);
	      } else if ($el.find('input[type="range"]').length) {
	        $inputEl = $el.find('input[type="range"]').eq(0);
	      }
	    }


	    Utils.extend(range, range.params, {
	      $el: $el,
	      el: $el[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl ? $inputEl[0] : undefined,
	    });

	    if ($inputEl) {
	      ('step min max').split(' ').forEach(function (paramName) {
	        if (!params[paramName] && $inputEl.attr(paramName)) {
	          range.params[paramName] = parseFloat($inputEl.attr(paramName));
	          range[paramName] = parseFloat($inputEl.attr(paramName));
	        }
	        if (typeof $inputEl.val() !== 'undefined') {
	          range.params.value = parseFloat($inputEl.val());
	          range.value = parseFloat($inputEl.val());
	        }
	      });
	    }

	    // Dual
	    if (range.dual) {
	      $el.addClass('range-slider-dual');
	    }
	    if (range.label) {
	      $el.addClass('range-slider-label');
	    }

	    // Check for layout
	    var $barEl = $$1$1('<div class="range-bar"></div>');
	    var $barActiveEl = $$1$1('<div class="range-bar-active"></div>');
	    $barEl.append($barActiveEl);

	    // Create Knobs
	    var knobHTML = "\n      <div class=\"range-knob-wrap\">\n        <div class=\"range-knob\"></div>\n        " + (range.label ? '<div class="range-knob-label"></div>' : '') + "\n      </div>\n    ";
	    var knobs = [$$1$1(knobHTML)];
	    var labels = [];

	    if (range.dual) {
	      knobs.push($$1$1(knobHTML));
	    }

	    $el.append($barEl);
	    knobs.forEach(function ($knobEl) {
	      $el.append($knobEl);
	    });

	    // Labels
	    if (range.label) {
	      labels.push(knobs[0].find('.range-knob-label'));
	      if (range.dual) {
	        labels.push(knobs[1].find('.range-knob-label'));
	      }
	    }

	    Utils.extend(range, {
	      app: app,
	      knobs: knobs,
	      labels: labels,
	      $barEl: $barEl,
	      $barActiveEl: $barActiveEl,
	    });

	    $el[0].f7Range = range;

	    // Touch Events
	    var isTouched;
	    var touchesStart = {};
	    var isScrolling;
	    var rangeOffsetLeft;
	    var $touchedKnobEl;
	    var dualValueIndex;

	    function handleTouchStart(e) {
	      if (isTouched) { return; }
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

	      isTouched = true;
	      isScrolling = undefined;
	      rangeOffsetLeft = $el.offset().left;

	      var progress;
	      if (range.app.rtl) {
	        progress = ((rangeOffsetLeft + range.rangeWidth) - touchesStart.x) / range.rangeWidth;
	      } else {
	        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
	      }

	      var newValue = (progress * (range.max - range.min)) + range.min;
	      if (range.dual) {
	        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
	          dualValueIndex = 0;
	          $touchedKnobEl = range.knobs[0];
	          newValue = [newValue, range.value[1]];
	        } else {
	          dualValueIndex = 1;
	          $touchedKnobEl = range.knobs[1];
	          newValue = [range.value[0], newValue];
	        }
	      } else {
	        $touchedKnobEl = range.knobs[0];
	        newValue = (progress * (range.max - range.min)) + range.min;
	      }
	      Utils.nextTick(function () {
	        if (isTouched) { $touchedKnobEl.addClass('range-knob-active-state'); }
	      }, 70);
	      range.setValue(newValue);
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();

	      var progress;
	      if (range.app.rtl) {
	        progress = ((rangeOffsetLeft + range.rangeWidth) - pageX) / range.rangeWidth;
	      } else {
	        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
	      }

	      var newValue = (progress * (range.max - range.min)) + range.min;
	      if (range.dual) {
	        var leftValue;
	        var rightValue;
	        if (dualValueIndex === 0) {
	          leftValue = newValue;
	          rightValue = range.value[1];
	          if (leftValue > rightValue) {
	            rightValue = leftValue;
	          }
	        } else {
	          leftValue = range.value[0];
	          rightValue = newValue;
	          if (rightValue < leftValue) {
	            leftValue = rightValue;
	          }
	        }
	        newValue = [leftValue, rightValue];
	      }
	      range.setValue(newValue);
	    }
	    function handleTouchEnd() {
	      if (!isTouched) {
	        if (isScrolling) { $touchedKnobEl.removeClass('range-knob-active-state'); }
	        isTouched = false;
	        return;
	      }
	      isTouched = false;
	      $touchedKnobEl.removeClass('range-knob-active-state');
	    }

	    function handleResize() {
	      range.calcSize();
	      range.layout();
	    }
	    range.attachEvents = function attachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	      app.on('tabShow', handleResize);
	      app.on('resize', handleResize);
	    };
	    range.detachEvents = function detachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
	      app.off('touchmove', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	      app.off('tabShow', handleResize);
	      app.off('resize', handleResize);
	    };

	    // Install Modules
	    range.useModules();

	    // Init
	    range.init();

	    return range;
	  }

	  if ( Framework7Class$$1 ) Range.__proto__ = Framework7Class$$1;
	  Range.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Range.prototype.constructor = Range;
	  Range.prototype.calcSize = function calcSize () {
	    var range = this;
	    var width = range.$el.outerWidth();
	    if (width === 0) { return; }
	    range.rangeWidth = width;
	    range.knobWidth = range.knobs[0].outerWidth();
	  };
	  Range.prototype.layout = function layout () {
	    var obj;

	    var range = this;
	    var app = range.app;
	    var knobWidth = range.knobWidth;
	    var rangeWidth = range.rangeWidth;
	    var min = range.min;
	    var max = range.max;
	    var knobs = range.knobs;
	    var $barActiveEl = range.$barActiveEl;
	    var value = range.value;
	    var label = range.label;
	    var labels = range.labels;
	    var positionProperty = app.rtl ? 'right' : 'left';
	    if (range.dual) {
	      var progress = [((value[0] - min) / (max - min)), ((value[1] - min) / (max - min))];
	      $barActiveEl.css(( obj = {}, obj[positionProperty] = ((progress[0] * 100) + "%"), obj.width = (((progress[1] - progress[0]) * 100) + "%"), obj ));
	      knobs.forEach(function ($knobEl, knobIndex) {
	        var leftPos = rangeWidth * progress[knobIndex];
	        var realLeft = (rangeWidth * progress[knobIndex]) - (knobWidth / 2);
	        if (realLeft < 0) { leftPos = knobWidth / 2; }
	        if ((realLeft + knobWidth) > rangeWidth) { leftPos = rangeWidth - (knobWidth / 2); }
	        $knobEl.css(positionProperty, (leftPos + "px"));
	        if (label) { labels[knobIndex].text(value[knobIndex]); }
	      });
	    } else {
	      var progress$1 = ((value - min) / (max - min));
	      $barActiveEl.css('width', ((progress$1 * 100) + "%"));

	      var leftPos = rangeWidth * progress$1;
	      var realLeft = (rangeWidth * progress$1) - (knobWidth / 2);
	      if (realLeft < 0) { leftPos = knobWidth / 2; }
	      if ((realLeft + knobWidth) > rangeWidth) { leftPos = rangeWidth - (knobWidth / 2); }
	      knobs[0].css(positionProperty, (leftPos + "px"));
	      if (label) { labels[0].text(value); }
	    }
	    if ((range.dual && value.indexOf(min) >= 0) || (!range.dual && value === min)) {
	      range.$el.addClass('range-slider-min');
	    } else {
	      range.$el.removeClass('range-slider-min');
	    }
	    if ((range.dual && value.indexOf(max) >= 0) || (!range.dual && value === max)) {
	      range.$el.addClass('range-slider-max');
	    } else {
	      range.$el.removeClass('range-slider-max');
	    }
	  };
	  Range.prototype.setValue = function setValue (newValue) {
	    var range = this;
	    var step = range.step;
	    var min = range.min;
	    var max = range.max;
	    if (range.dual) {
	      var newValues = newValue;
	      if (!Array.isArray(newValues)) { newValues = [newValue, newValue]; }
	      if (newValue[0] > newValue[1]) {
	        newValues = [newValues[0], newValues[0]];
	      }
	      newValues = newValues.map(function (value) { return Math.max(Math.min(Math.round(value / step) * step, max), min); });
	      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
	        return range;
	      }
	      newValues.forEach(function (value, valueIndex) {
	        range.value[valueIndex] = value;
	      });
	      range.layout();
	    } else {
	      var value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
	      range.value = value;
	      range.layout();
	    }
	    // Events
	    range.$el.trigger('range:change', range, range.value);
	    if (range.$inputEl && !range.dual) {
	      range.$inputEl.val(range.value).trigger('input change');
	    }
	    range.emit('local::change rangeChange', range, range.value);
	    return range;
	  };
	  Range.prototype.getValue = function getValue () {
	    return this.value;
	  };
	  Range.prototype.init = function init () {
	    var range = this;
	    range.calcSize();
	    range.layout();
	    range.attachEvents();
	    return range;
	  };
	  Range.prototype.destroy = function destroy () {
	    var range = this;
	    range.$el.trigger('range:beforedestroy', range);
	    range.emit('local::beforeDestroy rangeBeforeDestroy', range);
	    delete range.$el[0].f7Range;
	    range.detachEvents();
	    Utils.deleteProps(range);
	    range = null;
	  };

	  return Range;
	}(Framework7Class));

	var Range = {
	  name: 'range',
	  create: function create() {
	    var app = this;
	    app.range = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.range-slider',
	        constructor: Range$1,
	        app: app,
	        domProp: 'f7Range',
	      }),
	      {
	        getValue: function getValue(el) {
	          if ( el === void 0 ) el = '.range-slider';

	          var range = app.range.get(el);
	          if (range) { return range.getValue(); }
	          return undefined;
	        },
	        setValue: function setValue(el, value) {
	          if ( el === void 0 ) el = '.range-slider';

	          var range = app.range.get(el);
	          if (range) { return range.setValue(value); }
	          return undefined;
	        },
	      }
	    );
	  },
	  static: {
	    Range: Range$1,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.range-slider-init').each(function (index, rangeEl) { return new Range$1(app, {
	        el: rangeEl,
	      }); });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $$1$1(tabEl).find('.range-slider-init').each(function (index, rangeEl) {
	        if (rangeEl.f7Range) { rangeEl.f7Range.destroy(); }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.range-slider-init').each(function (index, rangeEl) { return new Range$1(app, {
	        el: rangeEl,
	      }); });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.range-slider-init').each(function (index, rangeEl) {
	        if (rangeEl.f7Range) { rangeEl.f7Range.destroy(); }
	      });
	    },
	  },
	};

	var SmartSelect$1 = (function (Framework7Class$$1) {
	  function SmartSelect(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var ss = this;
	    ss.app = app;
	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.smartSelect);

	    var $el = $$1$1(params.el).eq(0);
	    if ($el.length === 0) { return ss; }

	    var $selectEl = $el.find('select').eq(0);
	    if ($selectEl.length === 0) { return ss; }

	    var $valueEl = $$1$1(params.valueEl);
	    if ($valueEl.length === 0) {
	      $valueEl = $$1$1('<div class="item-after"></div>');
	      $valueEl.insertAfter($el.find('.item-title'));
	    }

	    // Extend defaults with modules params
	    ss.useModulesParams(defaults);

	    // View
	    var view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
	    if (!view) {
	      throw Error('Smart Select requires initialized View');
	    }

	    // Url
	    var url = params.url;
	    if (!url) {
	      if ($el.attr('href') && $el.attr('href') !== '#') { url = $el.attr('href'); }
	      else { url = ($selectEl.attr('name').toLowerCase()) + "-select/"; }
	    }
	    if (!url) { url = ss.params.url; }

	    var multiple = $selectEl[0].multiple;
	    var inputType = multiple ? 'checkbox' : 'radio';
	    var id = Utils.now();
	    Utils.extend(ss, {
	      params: Utils.extend(defaults, params),
	      $el: $el,
	      el: $el[0],
	      $selectEl: $selectEl,
	      selectEl: $selectEl[0],
	      $valueEl: $valueEl,
	      valueEl: $valueEl[0],
	      url: url,
	      multiple: multiple,
	      inputType: inputType,
	      id: id,
	      view: view,
	      inputName: (inputType + "-" + id),
	      selectName: $selectEl.attr('name'),
	      maxLength: $selectEl.attr('maxlength') || params.maxLength,
	    });
	    $el[0].f7SmartSelect = ss;

	    // Events
	    function onClick() {
	      ss.open();
	    }
	    function onChange() {
	      ss.setValue();
	    }
	    ss.attachEvents = function attachEvents() {
	      $el.on('click', onClick);
	      $el.on('change', 'select', onChange);
	    };
	    ss.detachEvents = function detachEvents() {
	      $el.off('click', onClick);
	      $el.off('change', 'select', onChange);
	    };

	    function handleInputChange() {
	      var optionEl;
	      var text;
	      var inputEl = this;
	      var value = inputEl.value;
	      var optionText = [];
	      var displayAs;
	      if (inputEl.type === 'checkbox') {
	        for (var i = 0; i < ss.selectEl.options.length; i += 1) {
	          optionEl = ss.selectEl.options[i];
	          if (optionEl.value === value) {
	            optionEl.selected = inputEl.checked;
	          }
	          if (optionEl.selected) {
	            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $$1$1(optionEl).data('display-value-as');
	            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	            optionText.push(text.trim());
	          }
	        }
	        if (ss.maxLength) {
	          ss.checkMaxLength();
	        }
	      } else {
	        optionEl = ss.$selectEl.find(("option[value=\"" + value + "\"]"))[0];
	        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $$1$1(optionEl).data('display-as');
	        text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
	        optionText = [text];
	        ss.selectEl.value = value;
	      }

	      ss.$selectEl.trigger('change');
	      ss.$valueEl.text(optionText.join(', '));
	      if (ss.params.closeOnSelect && ss.inputType === 'radio') {
	        ss.close();
	      }
	    }

	    ss.attachInputsEvents = function attachInputsEvents() {
	      ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
	    };
	    ss.detachInputsEvents = function detachInputsEvents() {
	      ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
	    };

	    // Install Modules
	    ss.useModules();

	    // Init
	    ss.init();

	    return ss;
	  }

	  if ( Framework7Class$$1 ) SmartSelect.__proto__ = Framework7Class$$1;
	  SmartSelect.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  SmartSelect.prototype.constructor = SmartSelect;
	  SmartSelect.prototype.checkMaxLength = function checkMaxLength () {
	    var ss = this;
	    var $containerEl = ss.$containerEl;
	    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
	      $containerEl.find('input[type="checkbox"]').each(function (index, inputEl) {
	        if (!inputEl.checked) {
	          $$1$1(inputEl).parents('li').addClass('disabled');
	        } else {
	          $$1$1(inputEl).parents('li').removeClass('disabled');
	        }
	      });
	    } else {
	      $containerEl.find('.disabled').removeClass('disabled');
	    }
	  };
	  SmartSelect.prototype.setValue = function setValue (value) {
	    var ss = this;
	    var valueArray = [];
	    if (typeof value !== 'undefined') {
	      if (Array.isArray(value)) {
	        valueArray = value;
	      } else {
	        valueArray = [value];
	      }
	    } else {
	      ss.$selectEl.find('option').each(function (optionIndex, optionEl) {
	        var $optionEl = $$1$1(optionEl);
	        if (optionEl.selected) {
	          var displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');
	          if (displayAs && typeof displayAs !== 'undefined') {
	            valueArray.push(displayAs);
	          } else {
	            valueArray.push(optionEl.textContent.trim());
	          }
	        }
	      });
	    }
	    ss.$valueEl.text(valueArray.join(', '));
	  };
	  SmartSelect.prototype.getItemsData = function getItemsData () {
	    var ss = this;
	    var items = [];
	    var previousGroupEl;
	    ss.$selectEl.find('option').each(function (index, optionEl) {
	      var $optionEl = $$1$1(optionEl);
	      var optionData = $optionEl.dataset();
	      var optionImage = optionData.optionImage || ss.params.optionImage;
	      var optionIcon = optionData.optionIcon || ss.params.optionIcon;
	      var optionHasMedia = optionImage || optionIcon;
	      // if (material) optionHasMedia = optionImage || optionIcon;
	      var optionColor = optionData.optionColor;

	      var optionClassName = optionData.optionClass || '';
	      if ($optionEl[0].disabled) { optionClassName += ' disabled'; }

	      var optionGroupEl = $optionEl.parent('optgroup')[0];
	      var optionGroupLabel = optionGroupEl && optionGroupEl.label;
	      var optionIsLabel = false;
	      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
	        optionIsLabel = true;
	        previousGroupEl = optionGroupEl;
	        items.push({
	          groupLabel: optionGroupLabel,
	          isLabel: optionIsLabel,
	        });
	      }
	      items.push({
	        value: $optionEl[0].value,
	        text: $optionEl[0].textContent.trim(),
	        selected: $optionEl[0].selected,
	        groupEl: optionGroupEl,
	        groupLabel: optionGroupLabel,
	        image: optionImage,
	        icon: optionIcon,
	        color: optionColor,
	        className: optionClassName,
	        disabled: $optionEl[0].disabled,
	        id: ss.id,
	        hasMedia: optionHasMedia,
	        checkbox: ss.inputType === 'checkbox',
	        radio: ss.inputType === 'radio',
	        inputName: ss.inputName,
	        inputType: ss.inputType,
	      });
	    });
	    ss.items = items;
	    return items;
	  };
	  SmartSelect.prototype.renderSearchbar = function renderSearchbar () {
	    var ss = this;
	    if (ss.params.renderSearchbar) { return ss.params.renderSearchbar.call(ss); }
	    var searchbarHTML = "\n      <form class=\"searchbar\">\n        <div class=\"searchbar-inner\">\n          <div class=\"searchbar-input-wrap\">\n            <input type=\"search\" placeholder=\"" + (ss.params.searchbarPlaceholder) + "\"/>\n            <i class=\"searchbar-icon\"></i>\n            <span class=\"input-clear-button\"></span>\n          </div>\n          <span class=\"searchbar-disable-button\">" + (ss.params.searchbarDisableText) + "</span>\n        </div>\n      </form>\n    ";
	    return searchbarHTML;
	  };
	  SmartSelect.prototype.renderItem = function renderItem (item, index) {
	    var ss = this;
	    if (ss.params.renderItem) { return ss.params.renderItem.call(ss, item, index); }
	    var itemHtml;
	    if (item.isLabel) {
	      itemHtml = "<li class=\"item-divider\">" + (item.groupLabel) + "</li>";
	    } else {
	      itemHtml = "\n        <li class=\"" + (item.className || '') + "\">\n          <label class=\"item-" + (item.inputType) + " item-content\">\n            <input type=\"" + (item.inputType) + "\" name=\"" + (item.inputName) + "\" value=\"" + (item.value) + "\" " + (item.selected ? 'checked' : '') + "/>\n            <i class=\"icon icon-" + (item.inputType) + "\"></i>\n            " + (item.hasMedia ? ("\n              <div class=\"item-media\">\n                " + (item.icon ? ("<i class=\"icon " + (item.icon) + "\"></i>") : '') + "\n                " + (item.image ? ("<img src=\"" + (item.image) + "\">") : '') + "\n              </div>\n            ") : '') + "\n            <div class=\"item-inner\">\n              <div class=\"item-title" + (item.color ? (" color-" + (item.color)) : '') + "\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    }
	    return itemHtml;
	  };
	  SmartSelect.prototype.renderItems = function renderItems () {
	    var ss = this;
	    if (ss.params.renderItems) { return ss.params.renderItems.call(ss, ss.items); }
	    var itemsHtml = "\n      " + (ss.items.map(function (item, index) { return ("" + (ss.renderItem(item, index))); }).join('')) + "\n    ";
	    return itemsHtml;
	  };
	  SmartSelect.prototype.renderPage = function renderPage () {
	    var ss = this;
	    if (ss.params.renderPage) { return ss.params.renderPage.call(ss, ss.items); }
	    var pageTitle = ss.params.pageTitle;
	    if (typeof pageTitle === 'undefined') {
	      pageTitle = ss.$el.find('.item-title').text().trim();
	    }
	    var pageHtml = "\n      <div class=\"page smart-select-page\" data-name=\"smart-select-page\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"navbar " + (ss.params.navbarColorTheme ? ("color-theme-" + (ss.params.navbarColorTheme)) : '') + "\">\n          <div class=\"navbar-inner sliding " + (ss.params.navbarColorTheme ? ("color-theme-" + (ss.params.navbarColorTheme)) : '') + "\">\n            <div class=\"left\">\n              <a href=\"#\" class=\"link back\">\n                <i class=\"icon icon-back\"></i>\n                <span class=\"ios-only\">" + (ss.params.pageBackLinkText) + "</span>\n              </a>\n            </div>\n            " + (pageTitle ? ("<div class=\"title\">" + pageTitle + "</div>") : '') + "\n            " + (ss.params.searchbar ? ("<div class=\"subnavbar\">" + (ss.renderSearchbar()) + "</div>") : '') + "\n          </div>\n        </div>\n        " + (ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : '') + "\n        <div class=\"page-content\">\n          <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + " " + (ss.params.formColorTheme ? ("color-theme-" + (ss.params.formColorTheme)) : '') + "\">\n            <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n          </div>\n        </div>\n      </div>\n    ";
	    return pageHtml;
	  };
	  SmartSelect.prototype.renderPopup = function renderPopup () {
	    var ss = this;
	    if (ss.params.renderPopup) { return ss.params.renderPopup.call(ss, ss.items); }
	    var pageTitle = ss.params.pageTitle;
	    if (typeof pageTitle === 'undefined') {
	      pageTitle = ss.$el.find('.item-title').text().trim();
	    }
	    var popupHtml = "\n      <div class=\"popup smart-select-popup\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"view\">\n          <div class=\"page smart-select-page " + (ss.params.searchbar ? 'page-with-subnavbar' : '') + "\" data-name=\"smart-select-page\">\n            <div class=\"navbar" + (ss.params.navbarColorTheme ? ("theme-" + (ss.params.navbarColorTheme)) : '') + "\">\n              <div class=\"navbar-inner sliding\">\n                <div class=\"left\">\n                  <a href=\"#\" class=\"link popup-close\">\n                    <i class=\"icon icon-back\"></i>\n                    <span class=\"ios-only\">" + (ss.params.popupCloseLinkText) + "</span>\n                  </a>\n                </div>\n                " + (pageTitle ? ("<div class=\"title\">" + pageTitle + "</div>") : '') + "\n                " + (ss.params.searchbar ? ("<div class=\"subnavbar\">" + (ss.renderSearchbar()) + "</div>") : '') + "\n              </div>\n            </div>\n            " + (ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : '') + "\n            <div class=\"page-content\">\n              <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + (ss.params.formColorTheme ? ("theme-" + (ss.params.formColorTheme)) : '') + "\">\n                <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ";
	    return popupHtml;
	  };
	  SmartSelect.prototype.renderSheet = function renderSheet () {
	    var ss = this;
	    if (ss.params.renderSheet) { return ss.params.renderSheet.call(ss, ss.items); }
	    var sheetHtml = "\n      <div class=\"sheet-modal smart-select-sheet\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"toolbar " + (ss.params.toolbarColorTheme ? ("theme-" + (ss.params.toolbarColorTheme)) : '') + "\">\n          <div class=\"toolbar-inner\">\n            <div class=\"left\"></div>\n            <div class=\"right\">\n              <a class=\"link sheet-close\">" + (ss.params.sheetCloseLinkText) + "</a>\n            </div>\n          </div>\n        </div>\n        <div class=\"sheet-modal-inner\">\n          <div class=\"page-content\">\n            <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + (ss.params.formColorTheme ? ("theme-" + (ss.params.formColorTheme)) : '') + "\">\n              <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n            </div>\n          </div>\n        </div>\n      </div>\n    ";
	    return sheetHtml;
	  };
	  SmartSelect.prototype.renderPopover = function renderPopover () {
	    var ss = this;
	    if (ss.params.renderPopover) { return ss.params.renderPopover.call(ss, ss.items); }
	    var popoverHtml = "\n      <div class=\"popover smart-select-popover\" data-select-name=\"" + (ss.selectName) + "\">\n        <div class=\"popover-inner\">\n          <div class=\"list smart-select-list-" + (ss.id) + " " + (ss.params.virtualList ? ' virtual-list' : '') + (ss.params.formColorTheme ? ("theme-" + (ss.params.formColorTheme)) : '') + "\">\n            <ul>" + (!ss.params.virtualList && ss.renderItems(ss.items)) + "</ul>\n          </div>\n        </div>\n      </div>\n    ";
	    return popoverHtml;
	  };
	  SmartSelect.prototype.onOpen = function onOpen (type, containerEl) {
	    var ss = this;
	    var app = ss.app;
	    var $containerEl = $$1$1(containerEl);
	    ss.$containerEl = $containerEl;
	    ss.openedIn = type;
	    ss.opened = true;

	    // Init VL
	    if (ss.params.virtualList) {
	      ss.vl = app.virtualList.create({
	        el: $containerEl.find('.virtual-list'),
	        items: ss.items,
	        renderItem: ss.renderItem.bind(ss),
	        height: ss.params.virtualListHeight,
	        searchByItem: function searchByItem(query, item) {
	          if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) { return true; }
	          return false;
	        },
	      });
	    }

	    // Init SB
	    if (ss.params.searchbar) {
	      ss.searchbar = app.searchbar.create({
	        el: $containerEl.find('.searchbar'),
	        backdropEl: $containerEl.find('.searchbar-backdrop'),
	        searchContainer: (".smart-select-list-" + (ss.id)),
	        searchIn: '.item-title',
	      });
	    }

	    // Check for max length
	    if (ss.maxLength) {
	      ss.checkMaxLength();
	    }

	    // Close on select
	    if (ss.params.closeOnSelect) {
	      ss.$containerEl.find(("input[type=\"radio\"][name=\"" + (ss.inputName) + "\"]:checked")).parents('label').once('click', function () {
	        ss.close();
	      });
	    }

	    // Attach input events
	    ss.attachInputsEvents();

	    ss.$el.trigger('smartselect:open', ss);
	    ss.emit('local::open smartSelectOpen', ss);
	  };
	  SmartSelect.prototype.onOpened = function onOpened () {
	    var ss = this;

	    ss.$el.trigger('smartselect:opened', ss);
	    ss.emit('local::opened smartSelectOpened', ss);
	  };
	  SmartSelect.prototype.onClose = function onClose () {
	    var ss = this;
	    if (ss.destroyed) { return; }

	    // Destroy VL
	    if (ss.vl && ss.vl.destroy) {
	      ss.vl.destroy();
	      ss.vl = null;
	      delete ss.vl;
	    }

	    // Destroy SB
	    if (ss.searchbar && ss.searchbar.destroy) {
	      ss.searchbar.destroy();
	      ss.searchbar = null;
	      delete ss.searchbar;
	    }
	    // Detach events
	    ss.detachInputsEvents();

	    ss.$el.trigger('smartselect:close', ss);
	    ss.emit('local::close smartSelectClose', ss);
	  };
	  SmartSelect.prototype.onClosed = function onClosed () {
	    var ss = this;
	    if (ss.destroyed) { return; }
	    ss.opened = false;
	    ss.$containerEl = null;
	    delete ss.$containerEl;

	    ss.$el.trigger('smartselect:closed', ss);
	    ss.emit('local::closed smartSelectClosed', ss);
	  };
	  SmartSelect.prototype.openPage = function openPage () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var pageHtml = ss.renderPage(ss.items);

	    ss.view.router.navigate({
	      url: ss.url,
	      route: {
	        content: pageHtml,
	        path: ss.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            ss.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            ss.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            ss.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            ss.onClosed('page', page.el);
	          },
	        },
	      },
	    });
	    return ss;
	  };
	  SmartSelect.prototype.openPopup = function openPopup () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var popupHtml = ss.renderPopup(ss.items);

	    var popupParams = {
	      content: popupHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          ss.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          ss.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          ss.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          ss.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (ss.params.routableModals) {
	      ss.view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.popup.create(popupParams).open();
	    }
	    return ss;
	  };
	  SmartSelect.prototype.openSheet = function openSheet () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var sheetHtml = ss.renderSheet(ss.items);

	    var sheetParams = {
	      content: sheetHtml,
	      backdrop: false,
	      scrollToEl: ss.$el,
	      closeByOutsideClick: true,
	      on: {
	        sheetOpen: function sheetOpen(sheet) {
	          ss.onOpen('sheet', sheet.el);
	        },
	        sheetOpened: function sheetOpened(sheet) {
	          ss.onOpened('sheet', sheet.el);
	        },
	        sheetClose: function sheetClose(sheet) {
	          ss.onClose('sheet', sheet.el);
	        },
	        sheetClosed: function sheetClosed(sheet) {
	          ss.onClosed('sheet', sheet.el);
	        },
	      },
	    };

	    if (ss.params.routableModals) {
	      ss.view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          sheet: sheetParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.sheet.create(sheetParams).open();
	    }
	    return ss;
	  };
	  SmartSelect.prototype.openPopover = function openPopover () {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    ss.getItemsData();
	    var popoverHtml = ss.renderPopover(ss.items);
	    var popoverParams = {
	      content: popoverHtml,
	      targetEl: ss.$el,
	      on: {
	        popoverOpen: function popoverOpen(popover) {
	          ss.onOpen('popover', popover.el);
	        },
	        popoverOpened: function popoverOpened(popover) {
	          ss.onOpened('popover', popover.el);
	        },
	        popoverClose: function popoverClose(popover) {
	          ss.onClose('popover', popover.el);
	        },
	        popoverClosed: function popoverClosed(popover) {
	          ss.onClosed('popover', popover.el);
	        },
	      },
	    };
	    if (ss.params.routableModals) {
	      ss.view.router.navigate({
	        url: ss.url,
	        route: {
	          path: ss.url,
	          popover: popoverParams,
	        },
	      });
	    } else {
	      ss.modal = ss.app.popover.create(popoverParams).open();
	    }
	    return ss;
	  };
	  SmartSelect.prototype.open = function open (type) {
	    var ss = this;
	    if (ss.opened) { return ss; }
	    var openIn = type || ss.params.openIn;
	    ss[("open" + (openIn.split('').map(function (el, index) {
	      if (index === 0) { return el.toUpperCase(); }
	      return el;
	    }).join('')))]();
	    return ss;
	  };
	  SmartSelect.prototype.close = function close () {
	    var ss = this;
	    if (!ss.opened) { return ss; }
	    if (ss.params.routableModals || ss.openedIn === 'page') {
	      ss.view.router.back();
	    } else {
	      ss.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          ss.modal.destroy();
	          delete ss.modal;
	        });
	      });
	      ss.modal.close();
	    }
	    return ss;
	  };
	  SmartSelect.prototype.init = function init () {
	    var ss = this;
	    ss.attachEvents();
	    ss.setValue();
	  };
	  SmartSelect.prototype.destroy = function destroy () {
	    var ss = this;
	    ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
	    ss.$el.trigger('smartselect:beforedestroy', ss);
	    ss.detachEvents();
	    delete ss.$el[0].f7SmartSelect;
	    Utils.deleteProps(ss);
	    ss.destroyed = true;
	  };

	  return SmartSelect;
	}(Framework7Class));

	var SmartSelect = {
	  name: 'smartSelect',
	  params: {
	    smartSelect: {
	      el: undefined,
	      valueEl: undefined,
	      openIn: 'page', // or 'popup' or 'sheet' or 'popover'
	      pageTitle: undefined,
	      pageBackLinkText: 'Back',
	      popupCloseLinkText: 'Close',
	      sheetCloseLinkText: 'Done',
	      searchbar: false,
	      searchbarPlaceholder: 'Search',
	      searchbarDisableText: 'Cancel',
	      closeOnSelect: false,
	      virtualList: false,
	      virtualListHeight: undefined,
	      formColorTheme: undefined,
	      navbarColorTheme: undefined,
	      routableModals: true,
	      url: 'select/',
	      /*
	        Custom render functions
	      */
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderSheet: undefined,
	      renderPopover: undefined,
	      renderItems: undefined,
	      renderItem: undefined,
	      renderSearchbar: undefined,
	    },
	  },
	  static: {
	    SmartSelect: SmartSelect$1,
	  },
	  create: function create() {
	    var app = this;
	    app.smartSelect = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.smart-select',
	        constructor: SmartSelect$1,
	        app: app,
	        domProp: 'f7SmartSelect',
	      }),
	      {
	        open: function open(smartSelectEl) {
	          var ss = app.smartSelect.get(smartSelectEl);
	          if (ss && ss.open) { return ss.open(); }
	          return undefined;
	        },
	        close: function close(smartSelectEl) {
	          var ss = app.smartSelect.get(smartSelectEl);
	          if (ss && ss.close) { return ss.close(); }
	          return undefined;
	        },
	      }
	    );
	  },

	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.smart-select-init').each(function (index, smartSelectEl) {
	        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $$1$1(smartSelectEl).dataset()));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $$1$1(tabEl).find('.smart-select-init').each(function (index, smartSelectEl) {
	        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
	          smartSelectEl.f7SmartSelect.destroy();
	        }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.smart-select-init').each(function (index, smartSelectEl) {
	        app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $$1$1(smartSelectEl).dataset()));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      page.$el.find('.smart-select-init').each(function (index, smartSelectEl) {
	        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
	          smartSelectEl.f7SmartSelect.destroy();
	        }
	      });
	    },
	  },
	  clicks: {
	    '.smart-select': function open($clickedEl, data) {
	      var app = this;
	      if (!$clickedEl[0].f7SmartSelect) {
	        var ss = app.smartSelect.create(Utils.extend({ el: $clickedEl }, data));
	        ss.open();
	      }
	    },
	  },
	};

	var Grid = {
	  name: 'grid',
	};

	var Calendar$1 = (function (Framework7Class$$1) {
	  function Calendar(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var calendar = this;
	    calendar.params = Utils.extend({}, app.params.calendar, params);

	    var $containerEl;
	    if (calendar.params.containerEl) {
	      $containerEl = $$1$1(calendar.params.containerEl);
	      if ($containerEl.length === 0) { return calendar; }
	    }

	    var $inputEl;
	    if (calendar.params.inputEl) {
	      $inputEl = $$1$1(calendar.params.inputEl);
	    }

	    var view;
	    if ($inputEl) {
	      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
	    }
	    if (!view) { view = app.views.main; }

	    var isHorizontal = calendar.params.direction === 'horizontal';

	    var inverter = 1;
	    if (isHorizontal) {
	      inverter = app.rtl ? -1 : 1;
	    }

	    Utils.extend(calendar, {
	      app: app,
	      $containerEl: $containerEl,
	      containerEl: $containerEl && $containerEl[0],
	      inline: $containerEl && $containerEl.length > 0,
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      initialized: false,
	      opened: false,
	      url: calendar.params.url,
	      isHorizontal: isHorizontal,
	      inverter: inverter,
	      view: view,
	      animating: false,
	    });

	    function onInputClick() {
	      calendar.open();
	    }
	    function onInputFocus(e) {
	      e.preventDefault();
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $$1$1(e.target);
	      if (calendar.isPopover()) { return; }
	      if (!calendar.opened) { return; }
	      if ($targetEl.closest('[class*="backdrop"]').length) { return; }
	      if ($inputEl && $inputEl.length > 0) {
	        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
	          calendar.close();
	        }
	      } else if ($$1$1(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
	        calendar.close();
	      }
	    }

	    // Events
	    Utils.extend(calendar, {
	      attachInputEvents: function attachInputEvents() {
	        calendar.$inputEl.on('click', onInputClick);
	        if (calendar.params.inputReadOnly) {
	          calendar.$inputEl.on('focus mousedown', onInputFocus);
	        }
	      },
	      detachInputEvents: function detachInputEvents() {
	        calendar.$inputEl.off('click', onInputClick);
	        if (calendar.params.inputReadOnly) {
	          calendar.$inputEl.off('focus mousedown', onInputFocus);
	        }
	      },
	      attachHtmlEvents: function attachHtmlEvents() {
	        app.on('click', onHtmlClick);
	      },
	      detachHtmlEvents: function detachHtmlEvents() {
	        app.off('click', onHtmlClick);
	      },
	    });
	    calendar.attachCalendarEvents = function attachCalendarEvents() {
	      var allowItemClick = true;
	      var isTouched;
	      var isMoved;
	      var touchStartX;
	      var touchStartY;
	      var touchCurrentX;
	      var touchCurrentY;
	      var touchStartTime;
	      var touchEndTime;
	      var currentTranslate;
	      var wrapperWidth;
	      var wrapperHeight;
	      var percentage;
	      var touchesDiff;
	      var isScrolling;

	      var $el = calendar.$el;
	      var $wrapperEl = calendar.$wrapperEl;

	      function handleTouchStart(e) {
	        if (isMoved || isTouched) { return; }
	        isTouched = true;
	        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	        touchCurrentX = touchStartX;
	        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	        touchCurrentY = touchStartY;
	        touchStartTime = (new Date()).getTime();
	        percentage = 0;
	        allowItemClick = true;
	        isScrolling = undefined;
	        currentTranslate = calendar.monthsTranslate;
	      }
	      function handleTouchMove(e) {
	        if (!isTouched) { return; }
	        var isH = calendar.isHorizontal;

	        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	        if (typeof isScrolling === 'undefined') {
	          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
	        }
	        if (isH && isScrolling) {
	          isTouched = false;
	          return;
	        }
	        e.preventDefault();
	        if (calendar.animating) {
	          isTouched = false;
	          return;
	        }
	        allowItemClick = false;
	        if (!isMoved) {
	          // First move
	          isMoved = true;
	          wrapperWidth = $wrapperEl[0].offsetWidth;
	          wrapperHeight = $wrapperEl[0].offsetHeight;
	          $wrapperEl.transition(0);
	        }

	        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
	        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
	        currentTranslate = ((calendar.monthsTranslate * calendar.inverter) + percentage) * 100;

	        // Transform wrapper
	        $wrapperEl.transform(("translate3d(" + (isH ? currentTranslate : 0) + "%, " + (isH ? 0 : currentTranslate) + "%, 0)"));
	      }
	      function handleTouchEnd() {
	        if (!isTouched || !isMoved) {
	          isTouched = false;
	          isMoved = false;
	          return;
	        }
	        isTouched = false;
	        isMoved = false;

	        touchEndTime = new Date().getTime();
	        if (touchEndTime - touchStartTime < 300) {
	          if (Math.abs(touchesDiff) < 10) {
	            calendar.resetMonth();
	          } else if (touchesDiff >= 10) {
	            if (app.rtl) { calendar.nextMonth(); }
	            else { calendar.prevMonth(); }
	          } else if (app.rtl) { calendar.prevMonth(); }
	          else { calendar.nextMonth(); }
	        } else if (percentage <= -0.5) {
	          if (app.rtl) { calendar.prevMonth(); }
	          else { calendar.nextMonth(); }
	        } else if (percentage >= 0.5) {
	          if (app.rtl) { calendar.nextMonth(); }
	          else { calendar.prevMonth(); }
	        } else {
	          calendar.resetMonth();
	        }

	        // Allow click
	        setTimeout(function () {
	          allowItemClick = true;
	        }, 100);
	      }

	      function handleDayClick(e) {
	        if (!allowItemClick) { return; }
	        var $dayEl = $$1$1(e.target).parents('.calendar-day');
	        if ($dayEl.length === 0 && $$1$1(e.target).hasClass('calendar-day')) {
	          $dayEl = $$1$1(e.target);
	        }
	        if ($dayEl.length === 0) { return; }
	        if ($dayEl.hasClass('calendar-day-disabled')) { return; }
	        if (!calendar.params.rangePicker) {
	          if ($dayEl.hasClass('calendar-day-next')) { calendar.nextMonth(); }
	          if ($dayEl.hasClass('calendar-day-prev')) { calendar.prevMonth(); }
	        }
	        var dateYear = $dayEl.attr('data-year');
	        var dateMonth = $dayEl.attr('data-month');
	        var dateDay = $dayEl.attr('data-day');
	        calendar.emit(
	          'local::dayClick calendarDayClick',
	          calendar,
	          $dayEl[0],
	          dateYear,
	          dateMonth,
	          dateDay
	        );
	        if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
	          calendar.addValue(new Date(dateYear, dateMonth, dateDay, 0, 0, 0));
	        }
	        if (calendar.params.closeOnSelect) {
	          if (
	            (calendar.params.rangePicker && calendar.value.length === 2) ||
	            !calendar.params.rangePicker
	          ) {
	            calendar.close();
	          }
	        }
	      }
	      function onNextMonthClick() {
	        calendar.nextMonth();
	      }
	      function onPrevMonthClick() {
	        calendar.prevMonth();
	      }
	      function onNextYearClick() {
	        calendar.nextYear();
	      }
	      function onPrevYearClick() {
	        calendar.prevYear();
	      }

	      var passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;
	      // Selectors clicks
	      $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
	      $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
	      $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
	      $el.find('.calendar-next-year-button').on('click', onNextYearClick);
	      // Day clicks
	      $wrapperEl.on('click', handleDayClick);
	      // Touch events
	      {
	        if (calendar.params.touchMove) {
	          $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
	          app.on('touchmove:active', handleTouchMove);
	          app.on('touchend:passive', handleTouchEnd);
	        }
	      }

	      calendar.detachCalendarEvents = function detachCalendarEvents() {
	        $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
	        $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
	        $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
	        $el.find('.calendar-next-year-button').off('click', onNextYearClick);
	        $wrapperEl.off('click', handleDayClick);
	        {
	          if (calendar.params.touchMove) {
	            $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
	            app.off('touchmove:active', handleTouchMove);
	            app.off('touchend:passive', handleTouchEnd);
	          }
	        }
	      };
	    };

	    calendar.init();

	    return calendar;
	  }

	  if ( Framework7Class$$1 ) Calendar.__proto__ = Framework7Class$$1;
	  Calendar.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Calendar.prototype.constructor = Calendar;
	  Calendar.prototype.initInput = function initInput () {
	    var calendar = this;
	    if (!calendar.$inputEl) { return; }
	    if (calendar.params.inputReadOnly) { calendar.$inputEl.prop('readOnly', true); }
	  };
	  Calendar.prototype.isPopover = function isPopover () {
	    var calendar = this;
	    var app = calendar.app;
	    var modal = calendar.modal;
	    var params = calendar.params;
	    if (params.openIn === 'sheet') { return false; }
	    if (modal && modal.type !== 'popover') { return false; }

	    if (!calendar.inline && calendar.inputEl) {
	      if (params.openIn === 'popover') { return true; }
	      else if (app.device.ios) {
	        return !!app.device.ipad;
	      } else if (app.width >= 768) {
	        return true;
	      }
	    }
	    return false;
	  };
	  Calendar.prototype.formatDate = function formatDate (d) {
	    var calendar = this;
	    var date = new Date(d);
	    var year = date.getFullYear();
	    var month = date.getMonth();
	    var month1 = month + 1;
	    var day = date.getDate();
	    var weekDay = date.getDay();
	    var ref = calendar.params;
	    var dateFormat = ref.dateFormat;
	    var monthNames = ref.monthNames;
	    var monthNamesShort = ref.monthNamesShort;
	    var dayNames = ref.dayNames;
	    var dayNamesShort = ref.dayNamesShort;

	    return dateFormat
	      .replace(/yyyy/g, year)
	      .replace(/yy/g, String(year).substring(2))
	      .replace(/mm/g, month1 < 10 ? ("0" + month1) : month1)
	      .replace(/m(\W+)/g, (month1 + "$1"))
	      .replace(/MM/g, monthNames[month])
	      .replace(/M(\W+)/g, ((monthNamesShort[month]) + "$1"))
	      .replace(/dd/g, day < 10 ? ("0" + day) : day)
	      .replace(/d(\W+)/g, (day + "$1"))
	      .replace(/DD/g, dayNames[weekDay])
	      .replace(/D(\W+)/g, ((dayNamesShort[weekDay]) + "$1"));
	  };
	  Calendar.prototype.formatValue = function formatValue () {
	    var calendar = this;
	    var value = calendar.value;
	    if (calendar.params.formatValue) {
	      return calendar.params.formatValue.call(calendar, value);
	    }
	    return value
	      .map(function (v) { return calendar.formatDate(v); })
	      .join(calendar.params.rangePicker ? ' - ' : ', ');
	  };
	  Calendar.prototype.addValue = function addValue (newValue) {
	    var calendar = this;
	    var ref = calendar.params;
	    var multiple = ref.multiple;
	    var rangePicker = ref.rangePicker;
	    if (multiple) {
	      if (!calendar.value) { calendar.value = []; }
	      var inValuesIndex;
	      for (var i = 0; i < calendar.value.length; i += 1) {
	        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
	          inValuesIndex = i;
	        }
	      }
	      if (typeof inValuesIndex === 'undefined') {
	        calendar.value.push(newValue);
	      } else {
	        calendar.value.splice(inValuesIndex, 1);
	      }
	      calendar.updateValue();
	    } else if (rangePicker) {
	      if (!calendar.value) { calendar.value = []; }
	      if (calendar.value.length === 2 || calendar.value.length === 0) {
	        calendar.value = [];
	      }
	      if (calendar.value[0] !== newValue) { calendar.value.push(newValue); }
	      else { calendar.value = []; }
	      calendar.value.sort(function (a, b) { return a - b; });
	      calendar.updateValue();
	    } else {
	      calendar.value = [newValue];
	      calendar.updateValue();
	    }
	  };
	  Calendar.prototype.setValue = function setValue (values) {
	    var calendar = this;
	    calendar.value = values;
	    calendar.updateValue();
	  };
	  Calendar.prototype.getValue = function getValue () {
	    var calendar = this;
	    return calendar.value;
	  };
	  Calendar.prototype.updateValue = function updateValue (onlyHeader) {
	    var calendar = this;
	    var $el = calendar.$el;
	    var $wrapperEl = calendar.$wrapperEl;
	    var $inputEl = calendar.$inputEl;
	    var value = calendar.value;
	    var params = calendar.params;
	    var i;
	    if ($el && $el.length > 0) {
	      $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected');
	      var valueDate;
	      if (params.rangePicker && value.length === 2) {
	        for (i = new Date(value[0]).getTime(); i <= new Date(value[1]).getTime(); i += 24 * 60 * 60 * 1000) {
	          valueDate = new Date(i);
	          $wrapperEl.find((".calendar-day[data-date=\"" + (valueDate.getFullYear()) + "-" + (valueDate.getMonth()) + "-" + (valueDate.getDate()) + "\"]")).addClass('calendar-day-selected');
	        }
	      } else {
	        for (i = 0; i < calendar.value.length; i += 1) {
	          valueDate = new Date(value[i]);
	          $wrapperEl.find((".calendar-day[data-date=\"" + (valueDate.getFullYear()) + "-" + (valueDate.getMonth()) + "-" + (valueDate.getDate()) + "\"]")).addClass('calendar-day-selected');
	        }
	      }
	    }

	    calendar.emit('local::change calendarChange', calendar, value);

	    if (($inputEl && $inputEl.length) || params.header) {
	      var inputValue = calendar.formatValue(value);
	      if (params.header && $el && $el.length) {
	        $el.find('.calendar-selected-date').text(inputValue);
	      }
	      if ($inputEl && $inputEl.length && !onlyHeader) {
	        $inputEl.val(inputValue);
	        $inputEl.trigger('change');
	      }
	    }
	  };
	  Calendar.prototype.updateCurrentMonthYear = function updateCurrentMonthYear (dir) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var $el = calendar.$el;
	    var params = calendar.params;
	    if (typeof dir === 'undefined') {
	      calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
	      calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
	    } else {
	      calendar.currentMonth = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-month'), 10);
	      calendar.currentYear = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-year'), 10);
	    }
	    $el.find('.current-month-value').text(params.monthNames[calendar.currentMonth]);
	    $el.find('.current-year-value').text(calendar.currentYear);
	  };
	  Calendar.prototype.update = function update () {
	    var calendar = this;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    var $wrapperEl = calendar.$wrapperEl;
	    var currentDate = new Date(currentYear, currentMonth);
	    var prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
	    var currentMonthHtml = calendar.renderMonth(currentDate);
	    var nextMonthHtml = calendar.renderMonth(currentDate, 'next');

	    $wrapperEl
	      .html(("" + prevMonthHtml + currentMonthHtml + nextMonthHtml))
	      .transform('translate3d(0,0,0)');
	    calendar.$months = $wrapperEl.find('.calendar-month');
	    calendar.monthsTranslate = 0;
	    calendar.setMonthsTranslate();
	    calendar.$months.each(function (index, monthEl) {
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        monthEl
	      );
	    });
	  };
	  Calendar.prototype.onMonthChangeStart = function onMonthChangeStart (dir) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    calendar.updateCurrentMonthYear(dir);
	    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
	    var currentIndex = dir === 'next' ? $months.length - 1 : 0;

	    $months.eq(currentIndex).addClass('calendar-month-current');
	    $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');

	    calendar.emit(
	      'local::monthYearChangeStart calendarMonthYearChangeStart',
	      calendar,
	      currentYear,
	      currentMonth
	    );
	  };
	  Calendar.prototype.onMonthChangeEnd = function onMonthChangeEnd (dir, rebuildBoth) {
	    var calendar = this;
	    var currentYear = calendar.currentYear;
	    var currentMonth = calendar.currentMonth;
	    var $wrapperEl = calendar.$wrapperEl;
	    var monthsTranslate = calendar.monthsTranslate;
	    calendar.animating = false;
	    var nextMonthHtml;
	    var prevMonthHtml;
	    var currentMonthHtml;
	    $wrapperEl
	      .find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)')
	      .remove();

	    if (typeof dir === 'undefined') {
	      dir = 'next'; // eslint-disable-line
	      rebuildBoth = true; // eslint-disable-line
	    }
	    if (!rebuildBoth) {
	      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
	    } else {
	      $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
	      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
	      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
	    }
	    if (dir === 'next' || rebuildBoth) {
	      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
	    }
	    if (dir === 'prev' || rebuildBoth) {
	      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
	    }
	    var $months = $wrapperEl.find('.calendar-month');
	    calendar.$months = $months;
	    calendar.setMonthsTranslate(monthsTranslate);
	    calendar.emit(
	      'local::monthAdd calendarMonthAdd',
	      calendar,
	      dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]
	    );
	    calendar.emit(
	      'local::monthYearChangeEnd calendarMonthYearChangeEnd',
	      calendar,
	      currentYear,
	      currentMonth
	    );
	  };
	  Calendar.prototype.setMonthsTranslate = function setMonthsTranslate (translate) {
	    var calendar = this;
	    var $months = calendar.$months;
	    var isH = calendar.isHorizontal;
	    var inverter = calendar.inverter;
	    // eslint-disable-next-line
	    translate = translate || calendar.monthsTranslate || 0;
	    if (typeof calendar.monthsTranslate === 'undefined') {
	      calendar.monthsTranslate = translate;
	    }
	    $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
	    var prevMonthTranslate = -(translate + 1) * 100 * inverter;
	    var currentMonthTranslate = -translate * 100 * inverter;
	    var nextMonthTranslate = -(translate - 1) * 100 * inverter;
	    $months.eq(0)
	      .transform(("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-prev');
	    $months.eq(1)
	      .transform(("translate3d(" + (isH ? currentMonthTranslate : 0) + "%, " + (isH ? 0 : currentMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-current');
	    $months.eq(2)
	      .transform(("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)"))
	      .addClass('calendar-month-next');
	  };
	  Calendar.prototype.nextMonth = function nextMonth (transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      transition = ''; // eslint-disable-line
	      if (!params.animate) { transition = 0; } // eslint-disable-line
	    }
	    var nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
	    var nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
	    var nextDate = new Date(nextYear, nextMonth);
	    var nextDateTime = nextDate.getTime();
	    var transitionEndCallback = !calendar.animating;
	    if (params.maxDate) {
	      if (nextDateTime > new Date(params.maxDate).getTime()) {
	        calendar.resetMonth();
	        return;
	      }
	    }
	    calendar.monthsTranslate -= 1;
	    if (nextMonth === calendar.currentMonth) {
	      var nextMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
	      var nextMonthHtml = $$1$1(calendar.renderMonth(nextDateTime, 'next'))
	        .transform(("translate3d(" + (isH ? nextMonthTranslate : 0) + "%, " + (isH ? 0 : nextMonthTranslate) + "%, 0)"))
	        .addClass('calendar-month-next');
	      $wrapperEl.append(nextMonthHtml[0]);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        calendar.$months.eq(calendar.$months.length - 1)[0]
	      );
	    }
	    calendar.animating = true;
	    calendar.onMonthChangeStart('next');
	    var translate = (calendar.monthsTranslate * 100) * inverter;

	    $wrapperEl.transition(transition).transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd('next');
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd('next');
	    }
	  };
	  Calendar.prototype.prevMonth = function prevMonth (transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      transition = ''; // eslint-disable-line
	      if (!params.animate) { transition = 0; } // eslint-disable-line
	    }
	    var prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
	    var prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
	    var prevDate = new Date(prevYear, prevMonth + 1, -1);
	    var prevDateTime = prevDate.getTime();
	    var transitionEndCallback = !calendar.animating;
	    if (params.minDate) {
	      if (prevDateTime < new Date(params.minDate).getTime()) {
	        calendar.resetMonth();
	        return;
	      }
	    }
	    calendar.monthsTranslate += 1;
	    if (prevMonth === calendar.currentMonth) {
	      var prevMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
	      var prevMonthHtml = $$1$1(calendar.renderMonth(prevDateTime, 'prev'))
	        .transform(("translate3d(" + (isH ? prevMonthTranslate : 0) + "%, " + (isH ? 0 : prevMonthTranslate) + "%, 0)"))
	        .addClass('calendar-month-prev');
	      $wrapperEl.prepend(prevMonthHtml[0]);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      calendar.emit(
	        'local::monthAdd calendarMonthAdd',
	        calendar.$months.eq(0)[0]
	      );
	    }
	    calendar.animating = true;
	    calendar.onMonthChangeStart('prev');
	    var translate = (calendar.monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd('prev');
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd('prev');
	    }
	  };
	  Calendar.prototype.resetMonth = function resetMonth (transition) {
	    if ( transition === void 0 ) transition = '';

	    var calendar = this;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    var isH = calendar.isHorizontal;
	    var monthsTranslate = calendar.monthsTranslate;
	    var translate = (monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? translate : 0) + "%, " + (isH ? 0 : translate) + "%, 0)"));
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.setYearMonth = function setYearMonth (year, month, transition) {
	    var calendar = this;
	    var params = calendar.params;
	    var isH = calendar.isHorizontal;
	    var $wrapperEl = calendar.$wrapperEl;
	    var inverter = calendar.inverter;
	    // eslint-disable-next-line
	    if (typeof year === 'undefined') { year = calendar.currentYear; }
	    // eslint-disable-next-line
	    if (typeof month === 'undefined') { month = calendar.currentMonth; }
	    if (typeof transition === 'undefined' || typeof transition === 'object') {
	      // eslint-disable-next-line
	      transition = '';
	      // eslint-disable-next-line
	      if (!params.animate) { transition = 0; }
	    }
	    var targetDate;
	    if (year < calendar.currentYear) {
	      targetDate = new Date(year, month + 1, -1).getTime();
	    } else {
	      targetDate = new Date(year, month).getTime();
	    }
	    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
	      return false;
	    }
	    if (params.minDate && targetDate < new Date(params.minDate).getTime()) {
	      return false;
	    }
	    var currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
	    var dir = targetDate > currentDate ? 'next' : 'prev';
	    var newMonthHTML = calendar.renderMonth(new Date(year, month));
	    calendar.monthsTranslate = calendar.monthsTranslate || 0;
	    var prevTranslate = calendar.monthsTranslate;
	    var monthTranslate;
	    var transitionEndCallback = !calendar.animating;
	    if (targetDate > currentDate) {
	      // To next
	      calendar.monthsTranslate -= 1;
	      if (!calendar.animating) { calendar.$months.eq(calendar.$months.length - 1).remove(); }
	      $wrapperEl.append(newMonthHTML);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
	      calendar.$months
	        .eq(calendar.$months.length - 1)
	        .transform(("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)"))
	        .addClass('calendar-month-next');
	    } else {
	      // To prev
	      calendar.monthsTranslate += 1;
	      if (!calendar.animating) { calendar.$months.eq(0).remove(); }
	      $wrapperEl.prepend(newMonthHTML);
	      calendar.$months = $wrapperEl.find('.calendar-month');
	      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
	      calendar.$months
	        .eq(0)
	        .transform(("translate3d(" + (isH ? monthTranslate : 0) + "%, " + (isH ? 0 : monthTranslate) + "%, 0)"))
	        .addClass('calendar-month-prev');
	    }
	    calendar.emit(
	      'local::monthAdd calendarMonthAdd',
	      dir === 'next'
	        ? calendar.$months.eq(calendar.$months.length - 1)[0]
	        : calendar.$months.eq(0)[0]
	    );

	    calendar.animating = true;
	    calendar.onMonthChangeStart(dir);
	    var wrapperTranslate = (calendar.monthsTranslate * 100) * inverter;
	    $wrapperEl
	      .transition(transition)
	      .transform(("translate3d(" + (isH ? wrapperTranslate : 0) + "%, " + (isH ? 0 : wrapperTranslate) + "%, 0)"));
	    if (transitionEndCallback) {
	      $wrapperEl.transitionEnd(function () {
	        calendar.onMonthChangeEnd(dir, true);
	      });
	    }
	    if (!params.animate) {
	      calendar.onMonthChangeEnd(dir);
	    }
	  };
	  Calendar.prototype.nextYear = function nextYear () {
	    var calendar = this;
	    calendar.setYearMonth(calendar.currentYear + 1);
	  };
	  Calendar.prototype.prevYear = function prevYear () {
	    var calendar = this;
	    calendar.setYearMonth(calendar.currentYear - 1);
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.dateInRange = function dateInRange (dayDate, range) {
	    var match = false;
	    var i;
	    if (!range) { return false; }
	    if (Array.isArray(range)) {
	      for (i = 0; i < range.length; i += 1) {
	        if (range[i].from || range[i].to) {
	          if (range[i].from && range[i].to) {
	            if ((dayDate <= new Date(range[i].to).getTime()) && (dayDate >= new Date(range[i].from).getTime())) {
	              match = true;
	            }
	          } else if (range[i].from) {
	            if (dayDate >= new Date(range[i].from).getTime()) {
	              match = true;
	            }
	          } else if (range[i].to) {
	            if (dayDate <= new Date(range[i].to).getTime()) {
	              match = true;
	            }
	          }
	        } else if (dayDate === new Date(range[i]).getTime()) {
	          match = true;
	        }
	      }
	    } else if (range.from || range.to) {
	      if (range.from && range.to) {
	        if ((dayDate <= new Date(range.to).getTime()) && (dayDate >= new Date(range.from).getTime())) {
	          match = true;
	        }
	      } else if (range.from) {
	        if (dayDate >= new Date(range.from).getTime()) {
	          match = true;
	        }
	      } else if (range.to) {
	        if (dayDate <= new Date(range.to).getTime()) {
	          match = true;
	        }
	      }
	    } else if (typeof range === 'function') {
	      match = range(new Date(dayDate));
	    }
	    return match;
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.daysInMonth = function daysInMonth (date) {
	    var d = new Date(date);
	    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
	  };
	  Calendar.prototype.renderMonths = function renderMonths (date) {
	    var calendar = this;
	    if (calendar.params.renderMonths) {
	      return calendar.params.renderMonths.call(calendar, date);
	    }
	    return ("\n      <div class=\"calendar-months-wrapper\">\n        " + (calendar.renderMonth(date, 'prev')) + "\n        " + (calendar.renderMonth(date)) + "\n        " + (calendar.renderMonth(date, 'next')) + "\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderMonth = function renderMonth (d, offset) {
	    var calendar = this;
	    var params = calendar.params;
	    var value = calendar.value;
	    if (params.renderMonth) {
	      return params.renderMonth.call(calendar, d, offset);
	    }
	    var date = new Date(d);
	    var year = date.getFullYear();
	    var month = date.getMonth();

	    if (offset === 'next') {
	      if (month === 11) { date = new Date(year + 1, 0); }
	      else { date = new Date(year, month + 1, 1); }
	    }
	    if (offset === 'prev') {
	      if (month === 0) { date = new Date(year - 1, 11); }
	      else { date = new Date(year, month - 1, 1); }
	    }
	    if (offset === 'next' || offset === 'prev') {
	      month = date.getMonth();
	      year = date.getFullYear();
	    }

	    var currentValues = [];
	    var today = new Date().setHours(0, 0, 0, 0);
	    var minDate = params.minDate ? new Date(params.minDate).getTime() : null;
	    var maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
	    var rows = 6;
	    var cols = 7;
	    var daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - (10 * 24 * 60 * 60 * 1000));
	    var daysInMonth = calendar.daysInMonth(date);
	    var minDayNumber = params.firstDay === 6 ? 0 : 1;

	    var monthHtml = '';
	    var dayIndex = 0 + (params.firstDay - 1);
	    var disabled;
	    var hasEvent;
	    var firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
	    if (firstDayOfMonthIndex === 0) { firstDayOfMonthIndex = 7; }

	    if (value && value.length) {
	      for (var i = 0; i < value.length; i += 1) {
	        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
	      }
	    }

	    for (var row = 1; row <= rows; row += 1) {
	      var rowHtml = '';
	      for (var col = 1; col <= cols; col += 1) {
	        dayIndex += 1;
	        var dayDate = (void 0);
	        var dayNumber = dayIndex - firstDayOfMonthIndex;
	        var addClass = '';
	        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
	          dayIndex -= 7;
	          dayNumber = dayIndex - firstDayOfMonthIndex;
	        }

	        var weekDayIndex = ((col - 1) + params.firstDay > 6)
	          ? ((col - 1 - 7) + params.firstDay)
	          : ((col - 1) + params.firstDay);

	        if (dayNumber < 0) {
	          dayNumber = daysInPrevMonth + dayNumber + 1;
	          addClass += ' calendar-day-prev';
	          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
	        } else {
	          dayNumber += 1;
	          if (dayNumber > daysInMonth) {
	            dayNumber -= daysInMonth;
	            addClass += ' calendar-day-next';
	            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
	          } else {
	            dayDate = new Date(year, month, dayNumber).getTime();
	          }
	        }
	        // Today
	        if (dayDate === today) { addClass += ' calendar-day-today'; }

	        // Selected
	        if (params.rangePicker && currentValues.length === 2) {
	          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) { addClass += ' calendar-day-selected'; }
	        } else if (currentValues.indexOf(dayDate) >= 0) { addClass += ' calendar-day-selected'; }
	        // Weekend
	        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
	          addClass += ' calendar-day-weekend';
	        }
	        // Has Events
	        hasEvent = false;
	        if (params.events) {
	          if (calendar.dateInRange(dayDate, params.events)) {
	            hasEvent = true;
	          }
	        }
	        if (hasEvent) {
	          addClass += ' calendar-day-has-events';
	        }
	        // Custom Ranges
	        if (params.rangesClasses) {
	          for (var k = 0; k < params.rangesClasses.length; k += 1) {
	            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
	              addClass += " " + (params.rangesClasses[k].cssClass);
	            }
	          }
	        }
	        // Disabled
	        disabled = false;
	        if ((minDate && dayDate < minDate) || (maxDate && dayDate > maxDate)) {
	          disabled = true;
	        }
	        if (params.disabled) {
	          if (calendar.dateInRange(dayDate, params.disabled)) {
	            disabled = true;
	          }
	        }
	        if (disabled) {
	          addClass += ' calendar-day-disabled';
	        }

	        dayDate = new Date(dayDate);
	        var dayYear = dayDate.getFullYear();
	        var dayMonth = dayDate.getMonth();
	        rowHtml += ("\n          <div data-year=\"" + dayYear + "\" data-month=\"" + dayMonth + "\" data-day=\"" + dayNumber + "\" class=\"calendar-day" + addClass + "\" data-date=\"" + dayYear + "-" + dayMonth + "-" + dayNumber + "\">\n            <span>" + dayNumber + "</span>\n          </div>").trim();
	      }
	      monthHtml += "<div class=\"calendar-row\">" + rowHtml + "</div>";
	    }
	    monthHtml = "<div class=\"calendar-month\" data-year=\"" + year + "\" data-month=\"" + month + "\">" + monthHtml + "</div>";
	    return monthHtml;
	  };
	  Calendar.prototype.renderWeekHeader = function renderWeekHeader () {
	    var calendar = this;
	    if (calendar.params.renderWeekHeader) {
	      return calendar.params.renderWeekHeader.call(calendar);
	    }
	    var params = calendar.params;
	    var weekDaysHtml = '';
	    for (var i = 0; i < 7; i += 1) {
	      var dayIndex = (i + params.firstDay > 6)
	        ? ((i - 7) + params.firstDay)
	        : (i + params.firstDay);
	      var dayName = params.dayNamesShort[dayIndex];
	      weekDaysHtml += "<div class=\"calendar-week-day\">" + dayName + "</div>";
	    }
	    return ("\n      <div class=\"calendar-week-header\">\n        " + weekDaysHtml + "\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderMonthSelector = function renderMonthSelector () {
	    var calendar = this;
	    var app = calendar.app;
	    if (calendar.params.renderMonthSelector) {
	      return calendar.params.renderMonthSelector.call(calendar);
	    }

	    var needsBlackIcon;
	    if (calendar.inline && calendar.$containerEl.closest('.theme-dark').length === 0) {
	      needsBlackIcon = true;
	    } else if (app.root.closest('.theme-dark').length === 0) {
	      needsBlackIcon = true;
	    }

	    var iconColor = app.theme === 'md' && needsBlackIcon ? 'color-black' : '';
	    return ("\n      <div class=\"calendar-month-selector\">\n        <a href=\"#\" class=\"link icon-only calendar-prev-month-button\">\n          <i class=\"icon icon-prev " + iconColor + "\"></i>\n        </a>\n        <span class=\"current-month-value\"></span>\n        <a href=\"#\" class=\"link icon-only calendar-next-month-button\">\n          <i class=\"icon icon-next " + iconColor + "\"></i>\n        </a>\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderYearSelector = function renderYearSelector () {
	    var calendar = this;
	    var app = calendar.app;
	    if (calendar.params.renderYearSelector) {
	      return calendar.params.renderYearSelector.call(calendar);
	    }

	    var needsBlackIcon;
	    if (calendar.inline && calendar.$containerEl.closest('.theme-dark').length === 0) {
	      needsBlackIcon = true;
	    } else if (app.root.closest('.theme-dark').length === 0) {
	      needsBlackIcon = true;
	    }

	    var iconColor = app.theme === 'md' && needsBlackIcon ? 'color-black' : '';
	    return ("\n      <div class=\"calendar-year-selector\">\n        <a href=\"#\" class=\"link icon-only calendar-prev-year-button\">\n          <i class=\"icon icon-prev " + iconColor + "\"></i>\n        </a>\n        <span class=\"current-year-value\"></span>\n        <a href=\"#\" class=\"link icon-only calendar-next-year-button\">\n          <i class=\"icon icon-next " + iconColor + "\"></i>\n        </a>\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderHeader = function renderHeader () {
	    var calendar = this;
	    if (calendar.params.renderHeader) {
	      return calendar.params.renderHeader.call(calendar);
	    }
	    return ("\n      <div class=\"calendar-header\">\n        <div class=\"calendar-selected-date\">" + (calendar.params.headerPlaceholder) + "</div>\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderFooter = function renderFooter () {
	    var calendar = this;
	    var app = calendar.app;
	    if (calendar.params.renderFooter) {
	      return calendar.params.renderFooter.call(calendar);
	    }
	    return ("\n      <div class=\"calendar-footer\">\n        <a href=\"#\" class=\"" + (app.theme === 'md' ? 'button' : 'link') + " calendar-close sheet-close popover-close\">" + (calendar.params.toolbarCloseText) + "</a>\n      </div>\n    ").trim();
	  };
	  Calendar.prototype.renderToolbar = function renderToolbar () {
	    var calendar = this;
	    if (calendar.params.renderToolbar) {
	      return calendar.params.renderToolbar.call(calendar, calendar);
	    }
	    return ("\n      <div class=\"toolbar no-shadow\">\n        <div class=\"toolbar-inner\">\n          " + (calendar.renderMonthSelector()) + "\n          " + (calendar.renderYearSelector()) + "\n        </div>\n      </div>\n    ").trim();
	  };
	  // eslint-disable-next-line
	  Calendar.prototype.renderInline = function renderInline () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
	    var inlineHtml = ("\n      <div class=\"calendar calendar-inline " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n        " + (header ? calendar.renderHeader() : '') + "\n        " + (toolbar ? calendar.renderToolbar() : '') + "\n        " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n        <div class=\"calendar-months\">\n          " + (calendar.renderMonths(date)) + "\n        </div>\n        " + (footer ? calendar.renderFooter() : '') + "\n      </div>\n    ").trim();

	    return inlineHtml;
	  };
	  Calendar.prototype.renderCustomModal = function renderCustomModal () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
	    var sheetHtml = ("\n      <div class=\"calendar calendar-modal " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n        " + (header ? calendar.renderHeader() : '') + "\n        " + (toolbar ? calendar.renderToolbar() : '') + "\n        " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n        <div class=\"calendar-months\">\n          " + (calendar.renderMonths(date)) + "\n        </div>\n        " + (footer ? calendar.renderFooter() : '') + "\n      </div>\n    ").trim();

	    return sheetHtml;
	  };
	  Calendar.prototype.renderSheet = function renderSheet () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
	    var sheetHtml = ("\n      <div class=\"sheet-modal calendar calendar-sheet " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n        " + (header ? calendar.renderHeader() : '') + "\n        " + (toolbar ? calendar.renderToolbar() : '') + "\n        " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n        <div class=\"sheet-modal-inner calendar-months\">\n          " + (calendar.renderMonths(date)) + "\n        </div>\n        " + (footer ? calendar.renderFooter() : '') + "\n      </div>\n    ").trim();

	    return sheetHtml;
	  };
	  Calendar.prototype.renderPopover = function renderPopover () {
	    var calendar = this;
	    var ref = calendar.params;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var header = ref.header;
	    var footer = ref.footer;
	    var rangePicker = ref.rangePicker;
	    var weekHeader = ref.weekHeader;
	    var value = calendar.value;
	    var date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
	    var popoverHtml = ("\n      <div class=\"popover calendar-popover\">\n        <div class=\"popover-inner\">\n          <div class=\"calendar " + (rangePicker ? 'calendar-range' : '') + " " + (cssClass || '') + "\">\n            " + (header ? calendar.renderHeader() : '') + "\n            " + (toolbar ? calendar.renderToolbar() : '') + "\n            " + (weekHeader ? calendar.renderWeekHeader() : '') + "\n            <div class=\"calendar-months\">\n              " + (calendar.renderMonths(date)) + "\n            </div>\n            " + (footer ? calendar.renderFooter() : '') + "\n          </div>\n        </div>\n      </div>\n    ").trim();

	    return popoverHtml;
	  };
	  Calendar.prototype.render = function render () {
	    var calendar = this;
	    var params = calendar.params;
	    if (params.render) { return params.render.call(calendar); }
	    if (!calendar.inline) {
	      var modalType = params.openIn;
	      if (modalType === 'auto') { modalType = calendar.isPopover() ? 'popover' : 'sheet'; }

	      if (modalType === 'popover') { return calendar.renderPopover(); }
	      else if (modalType === 'sheet') { return calendar.renderSheet(); }
	      return calendar.renderCustomModal();
	    }
	    return calendar.renderInline();
	  };
	  Calendar.prototype.onOpen = function onOpen () {
	    var calendar = this;
	    var initialized = calendar.initialized;
	    var $el = calendar.$el;
	    var app = calendar.app;
	    var $inputEl = calendar.$inputEl;
	    var inline = calendar.inline;
	    var value = calendar.value;
	    var params = calendar.params;
	    calendar.opened = true;

	    // Init main events
	    calendar.attachCalendarEvents();

	    var updateValue = !value && params.value;

	    // Set value
	    if (!initialized) {
	      if (value) { calendar.setValue(value, 0); }
	      else if (params.value) {
	        calendar.setValue(params.value, 0);
	      }
	    } else if (value) {
	      calendar.setValue(value, 0);
	    }

	    // Update current month and year
	    calendar.updateCurrentMonthYear();

	    // Set initial translate
	    calendar.monthsTranslate = 0;
	    calendar.setMonthsTranslate();

	    // Update input value
	    if (updateValue) { calendar.updateValue(); }
	    else if (app.theme === 'md' && value) { calendar.updateValue(true); }

	    // Extra focus
	    if (!inline && $inputEl.length && app.theme === 'md') {
	      $inputEl.trigger('focus');
	    }

	    calendar.initialized = true;

	    calendar.$months.each(function (index, monthEl) {
	      calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
	    });

	    // Trigger events
	    if ($el) {
	      $el.trigger('calendar:open', calendar);
	    }
	    if ($inputEl) {
	      $inputEl.trigger('calendar:open', calendar);
	    }
	    calendar.emit('local::open calendarOpen', calendar);
	  };
	  Calendar.prototype.onOpened = function onOpened () {
	    var calendar = this;
	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:opened', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:opened', calendar);
	    }
	    calendar.emit('local::opened calendarOpened', calendar);
	  };
	  Calendar.prototype.onClose = function onClose () {
	    var calendar = this;
	    var app = calendar.app;

	    if (calendar.$inputEl && app.theme === 'md') {
	      calendar.$inputEl.trigger('blur');
	    }
	    if (calendar.detachCalendarEvents) {
	      calendar.detachCalendarEvents();
	    }

	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:close', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:close', calendar);
	    }
	    calendar.emit('local::close calendarClose', calendar);
	  };
	  Calendar.prototype.onClosed = function onClosed () {
	    var calendar = this;
	    calendar.opened = false;

	    if (!calendar.inline) {
	      Utils.nextTick(function () {
	        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
	          if (!calendar.params.routableModals) {
	            calendar.modal.destroy();
	          }
	        }
	        delete calendar.modal;
	      });
	    }
	    if (calendar.$el) {
	      calendar.$el.trigger('calendar:closed', calendar);
	    }
	    if (calendar.$inputEl) {
	      calendar.$inputEl.trigger('calendar:closed', calendar);
	    }
	    calendar.emit('local::closed calendarClosed', calendar);
	  };
	  Calendar.prototype.open = function open () {
	    var obj;

	    var calendar = this;
	    var app = calendar.app;
	    var opened = calendar.opened;
	    var inline = calendar.inline;
	    var $inputEl = calendar.$inputEl;
	    var params = calendar.params;
	    if (opened) { return; }

	    if (inline) {
	      calendar.$el = $$1$1(calendar.render());
	      calendar.$el[0].f7Calendar = calendar;
	      calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
	      calendar.$months = calendar.$wrapperEl.find('.calendar-month');
	      calendar.$containerEl.append(calendar.$el);
	      calendar.onOpen();
	      calendar.onOpened();
	      return;
	    }
	    var modalType = params.openIn;
	    if (modalType === 'auto') {
	      modalType = calendar.isPopover() ? 'popover' : 'sheet';
	    }
	    var modalContent = calendar.render();

	    var modalParams = {
	      targetEl: $inputEl,
	      scrollToEl: calendar.params.scrollToInput ? $inputEl : undefined,
	      content: modalContent,
	      backdrop: modalType !== 'sheet',
	      on: {
	        open: function open() {
	          var modal = this;
	          calendar.modal = modal;
	          calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
	          calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
	          calendar.$months = calendar.$wrapperEl.find('.calendar-month');
	          calendar.$el[0].f7Calendar = calendar;
	          if (modalType === 'customModal') {
	            $$1$1(calendar.$el).find('.calendar-close').once('click', function () {
	              calendar.close();
	            });
	          }
	          calendar.onOpen();
	        },
	        opened: function opened() { calendar.onOpened(); },
	        close: function close() { calendar.onClose(); },
	        closed: function closed() { calendar.onClosed(); },
	      },
	    };
	    if (calendar.params.routableModals) {
	      calendar.view.router.navigate({
	        url: calendar.url,
	        route: ( obj = {
	          path: calendar.url
	        }, obj[modalType] = modalParams, obj ),
	      });
	    } else {
	      calendar.modal = app[modalType].create(modalParams);
	      calendar.modal.open();
	    }
	  };
	  Calendar.prototype.close = function close () {
	    var calendar = this;
	    var opened = calendar.opened;
	    var inline = calendar.inline;
	    if (!opened) { return; }
	    if (inline) {
	      calendar.onClose();
	      calendar.onClosed();
	      return;
	    }
	    if (calendar.params.routableModals) {
	      calendar.view.router.back();
	    } else {
	      calendar.modal.close();
	    }
	  };
	  Calendar.prototype.init = function init () {
	    var calendar = this;

	    calendar.initInput();

	    if (calendar.inline) {
	      calendar.open();
	      calendar.emit('local::init calendarInit', calendar);
	      return;
	    }

	    if (!calendar.initialized && calendar.params.value) {
	      calendar.setValue(calendar.params.value);
	    }

	    // Attach input Events
	    if (calendar.$inputEl) {
	      calendar.attachInputEvents();
	    }
	    if (calendar.params.closeByOutsideClick) {
	      calendar.attachHtmlEvents();
	    }
	    calendar.emit('local::init calendarInit', calendar);
	  };
	  Calendar.prototype.destroy = function destroy () {
	    var calendar = this;
	    if (calendar.destroyed) { return; }
	    var $el = calendar.$el;
	    calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
	    if ($el) { $el.trigger('calendar:beforedestroy', calendar); }

	    calendar.close();

	    // Detach Events
	    if (calendar.$inputEl) {
	      calendar.detachInputEvents();
	    }
	    if (calendar.params.closeByOutsideClick) {
	      calendar.detachHtmlEvents();
	    }

	    if ($el && $el.length) { delete calendar.$el[0].f7Calendar; }
	    Utils.deleteProps(calendar);
	    calendar.destroyed = true;
	  };

	  return Calendar;
	}(Framework7Class));

	var Calendar = {
	  name: 'calendar',
	  static: {
	    Calendar: Calendar$1,
	  },
	  create: function create() {
	    var app = this;
	    app.calendar = ConstructorMethods({
	      defaultSelector: '.calendar',
	      constructor: Calendar$1,
	      app: app,
	      domProp: 'f7Calendar',
	    });
	    app.calendar.close = function close(el) {
	      if ( el === void 0 ) el = '.calendar';

	      var $el = $$1$1(el);
	      if ($el.length === 0) { return; }
	      var calendar = $el[0].f7Calendar;
	      if (!calendar || (calendar && !calendar.opened)) { return; }
	      calendar.close();
	    };
	  },
	  params: {
	    calendar: {
	      // Calendar settings
	      monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	      monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	      dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	      dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	      firstDay: 1, // First day of the week, Monday
	      weekendDays: [0, 6], // Sunday and Saturday
	      multiple: false,
	      rangePicker: false,
	      dateFormat: 'yyyy-mm-dd',
	      direction: 'horizontal', // or 'vertical'
	      minDate: null,
	      maxDate: null,
	      disabled: null, // dates range of disabled days
	      events: null, // dates range of days with events
	      rangesClasses: null, // array with custom classes date ranges
	      touchMove: true,
	      animate: true,
	      closeOnSelect: false,
	      monthSelector: true,
	      yearSelector: true,
	      weekHeader: true,
	      value: null,
	      // Common opener settings
	      containerEl: null,
	      openIn: 'auto', // or 'popover' or 'sheet' or 'customModal'
	      formatValue: null,
	      inputEl: null,
	      inputReadOnly: true,
	      closeByOutsideClick: true,
	      scrollToInput: true,
	      header: false,
	      headerPlaceholder: 'Select date',
	      footer: false,
	      toolbar: true,
	      toolbarCloseText: 'Done',
	      cssClass: null,
	      routableModals: true,
	      view: null,
	      url: 'date/',
	      // Render functions
	      renderWeekHeader: null,
	      renderMonths: null,
	      renderMonth: null,
	      renderMonthSelector: null,
	      renderYearSelector: null,
	      renderHeader: null,
	      renderFooter: null,
	      renderToolbar: null,
	      renderInline: null,
	      renderPopover: null,
	      renderSheet: null,
	      render: null,
	    },
	  },
	};

	var pickerColumn = function (colEl, updateItems) {
	  var picker = this;
	  var app = picker.app;
	  var $colEl = $$1$1(colEl);
	  var colIndex = $colEl.index();
	  var col = picker.cols[colIndex];
	  if (col.divider) { return; }

	  col.$el = $colEl;
	  col.el = $colEl[0];
	  col.$itemsEl = col.$el.find('.picker-items');
	  col.items = col.$itemsEl.find('.picker-item');

	  var itemHeight;
	  var itemsHeight;
	  var minTranslate;
	  var maxTranslate;
	  var animationFrameId;

	  function updateDuringScroll() {
	    animationFrameId = Utils.requestAnimationFrame(function () {
	      col.updateItems(undefined, undefined, 0);
	      updateDuringScroll();
	    });
	  }

	  col.replaceValues = function replaceColValues(values, displayValues) {
	    col.detachEvents();
	    col.values = values;
	    col.displayValues = displayValues;
	    col.$itemsEl.html(picker.renderColumn(col, true));
	    col.items = col.$itemsEl.find('.picker-item');
	    col.calcSize();
	    col.setValue(col.values[0], 0, true);
	    col.attachEvents();
	  };
	  col.calcSize = function calcColSize() {
	    if (picker.params.rotateEffect) {
	      col.$el.removeClass('picker-column-absolute');
	      if (!col.width) { col.$el.css({ width: '' }); }
	    }
	    var colWidth = 0;
	    var colHeight = col.$el[0].offsetHeight;
	    itemHeight = col.items[0].offsetHeight;
	    itemsHeight = itemHeight * col.items.length;
	    minTranslate = ((colHeight / 2) - itemsHeight) + (itemHeight / 2);
	    maxTranslate = (colHeight / 2) - (itemHeight / 2);
	    if (col.width) {
	      colWidth = col.width;
	      if (parseInt(colWidth, 10) === colWidth) { colWidth += 'px'; }
	      col.$el.css({ width: colWidth });
	    }
	    if (picker.params.rotateEffect) {
	      if (!col.width) {
	        col.items.each(function (index, itemEl) {
	          var item = $$1$1(itemEl).children('span');
	          colWidth = Math.max(colWidth, item[0].offsetWidth);
	        });
	        col.$el.css({ width: ((colWidth + 2) + "px") });
	      }
	      col.$el.addClass('picker-column-absolute');
	    }
	  };

	  col.setValue = function setColValue(newValue, transition, valueCallbacks) {
	    if ( transition === void 0 ) transition = '';

	    var newActiveIndex = col.$itemsEl.find((".picker-item[data-picker-value=\"" + newValue + "\"]")).index();
	    if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
	      return;
	    }
	    var newTranslate = (-newActiveIndex * itemHeight) + maxTranslate;
	    // Update wrapper
	    col.$itemsEl.transition(transition);
	    col.$itemsEl.transform(("translate3d(0," + newTranslate + "px,0)"));

	    // Watch items
	    if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
	      Utils.cancelAnimationFrame(animationFrameId);
	      col.$itemsEl.transitionEnd(function () {
	        Utils.cancelAnimationFrame(animationFrameId);
	      });
	      updateDuringScroll();
	    }

	    // Update items
	    col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
	  };

	  col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
	    if (typeof translate === 'undefined') {
	      // eslint-disable-next-line
	      translate = Utils.getTranslate(col.$itemsEl[0], 'y');
	    }
	    // eslint-disable-next-line
	    if (typeof activeIndex === 'undefined') { activeIndex = -Math.round((translate - maxTranslate) / itemHeight); }
	    // eslint-disable-next-line
	    if (activeIndex < 0) { activeIndex = 0; }
	    // eslint-disable-next-line
	    if (activeIndex >= col.items.length) { activeIndex = col.items.length - 1; }
	    var previousActiveIndex = col.activeIndex;
	    col.activeIndex = activeIndex;
	    col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');

	    col.items.transition(transition);

	    var selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform('');

	    // Set 3D rotate effect
	    if (picker.params.rotateEffect) {
	      col.items.each(function (index, itemEl) {
	        var $itemEl = $$1$1(itemEl);
	        var itemOffsetTop = $itemEl.index() * itemHeight;
	        var translateOffset = maxTranslate - translate;
	        var itemOffset = itemOffsetTop - translateOffset;
	        var percentage = itemOffset / itemHeight;
	        var itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;

	        var angle = (-18 * percentage);
	        if (angle > 180) { angle = 180; }
	        if (angle < -180) { angle = -180; }
	        if (Math.abs(percentage) > itemsFit) {
	          $itemEl.addClass('picker-item-far');
	        } else {
	          $itemEl.removeClass('picker-item-far');
	        }
	        $itemEl.transform(("translate3d(0, " + (-translate + maxTranslate) + "px, " + (picker.needsOriginFix ? -110 : 0) + "px) rotateX(" + angle + "deg)"));
	      });
	    }

	    if (valueCallbacks || typeof valueCallbacks === 'undefined') {
	      // Update values
	      col.value = selectedItem.attr('data-picker-value');
	      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
	      // On change callback
	      if (previousActiveIndex !== activeIndex) {
	        if (col.onChange) {
	          col.onChange(picker, col.value, col.displayValue);
	        }
	        picker.updateValue();
	      }
	    }
	  };

	  var allowItemClick = true;
	  var isTouched;
	  var isMoved;
	  var touchStartY;
	  var touchCurrentY;
	  var touchStartTime;
	  var touchEndTime;
	  var startTranslate;
	  var returnTo;
	  var currentTranslate;
	  var prevTranslate;
	  var velocityTranslate;
	  function handleTouchStart(e) {
	    if (isMoved || isTouched) { return; }
	    e.preventDefault();
	    isTouched = true;
	    touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    touchCurrentY = touchStartY;
	    touchStartTime = (new Date()).getTime();

	    allowItemClick = true;
	    startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
	    currentTranslate = startTranslate;
	  }
	  function handleTouchMove(e) {
	    if (!isTouched) { return; }
	    e.preventDefault();
	    allowItemClick = false;
	    touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    if (!isMoved) {
	      // First move
	      Utils.cancelAnimationFrame(animationFrameId);
	      isMoved = true;
	      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
	      currentTranslate = startTranslate;
	      col.$itemsEl.transition(0);
	    }

	    var diff = touchCurrentY - touchStartY;
	    currentTranslate = startTranslate + diff;
	    returnTo = undefined;

	    // Normalize translate
	    if (currentTranslate < minTranslate) {
	      currentTranslate = minTranslate - (Math.pow( (minTranslate - currentTranslate), 0.8 ));
	      returnTo = 'min';
	    }
	    if (currentTranslate > maxTranslate) {
	      currentTranslate = maxTranslate + (Math.pow( (currentTranslate - maxTranslate), 0.8 ));
	      returnTo = 'max';
	    }
	    // Transform wrapper
	    col.$itemsEl.transform(("translate3d(0," + currentTranslate + "px,0)"));

	    // Update items
	    col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove);

	    // Calc velocity
	    velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
	    prevTranslate = currentTranslate;
	  }
	  function handleTouchEnd() {
	    if (!isTouched || !isMoved) {
	      isTouched = false;
	      isMoved = false;
	      return;
	    }
	    isTouched = false;
	    isMoved = false;
	    col.$itemsEl.transition('');
	    if (returnTo) {
	      if (returnTo === 'min') {
	        col.$itemsEl.transform(("translate3d(0," + minTranslate + "px,0)"));
	      } else { col.$itemsEl.transform(("translate3d(0," + maxTranslate + "px,0)")); }
	    }
	    touchEndTime = new Date().getTime();
	    var newTranslate;
	    if (touchEndTime - touchStartTime > 300) {
	      newTranslate = currentTranslate;
	    } else {
	      newTranslate = currentTranslate + (velocityTranslate * picker.params.momentumRatio);
	    }

	    newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

	    // Active Index
	    var activeIndex = -Math.floor((newTranslate - maxTranslate) / itemHeight);

	    // Normalize translate
	    if (!picker.params.freeMode) { newTranslate = (-activeIndex * itemHeight) + maxTranslate; }

	    // Transform wrapper
	    col.$itemsEl.transform(("translate3d(0," + (parseInt(newTranslate, 10)) + "px,0)"));

	    // Update items
	    col.updateItems(activeIndex, newTranslate, '', true);

	    // Watch items
	    if (picker.params.updateValuesOnMomentum) {
	      updateDuringScroll();
	      col.$itemsEl.transitionEnd(function () {
	        Utils.cancelAnimationFrame(animationFrameId);
	      });
	    }

	    // Allow click
	    setTimeout(function () {
	      allowItemClick = true;
	    }, 100);
	  }

	  function handleClick() {
	    if (!allowItemClick) { return; }
	    Utils.cancelAnimationFrame(animationFrameId);
	    var value = $$1$1(this).attr('data-picker-value');
	    col.setValue(value);
	  }

	  var activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;
	  col.attachEvents = function attachColEvents() {
	    col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
	    app.on('touchmove:active', handleTouchMove);
	    app.on('touchend:passive', handleTouchEnd);
	    col.items.on('click', handleClick);
	  };
	  col.detachEvents = function detachColEvents() {
	    col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
	    app.off('touchmove:active', handleTouchMove);
	    app.off('touchend:passive', handleTouchEnd);
	    col.items.off('click', handleClick);
	  };

	  col.init = function initCol() {
	    col.calcSize();
	    col.$itemsEl.transform(("translate3d(0," + maxTranslate + "px,0)")).transition(0);
	    if (colIndex === 0) { col.$el.addClass('picker-column-first'); }
	    if (colIndex === picker.cols.length - 1) { col.$el.addClass('picker-column-last'); }
	    // Update items on init
	    if (updateItems) { col.updateItems(0, maxTranslate, 0); }

	    col.attachEvents();
	  };

	  col.destroy = function destroyCol() {
	    col.detachEvents();
	  };

	  col.init();
	};

	var Picker$1 = (function (Framework7Class$$1) {
	  function Picker(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var picker = this;
	    picker.params = Utils.extend({}, app.params.picker, params);

	    var $containerEl;
	    if (picker.params.containerEl) {
	      $containerEl = $$1$1(picker.params.containerEl);
	      if ($containerEl.length === 0) { return picker; }
	    }

	    var $inputEl;
	    if (picker.params.inputEl) {
	      $inputEl = $$1$1(picker.params.inputEl);
	    }

	    var view;
	    if ($inputEl) {
	      view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
	    }
	    if (!view) { view = app.views.main; }

	    Utils.extend(picker, {
	      app: app,
	      $containerEl: $containerEl,
	      containerEl: $containerEl && $containerEl[0],
	      inline: $containerEl && $containerEl.length > 0,
	      needsOriginFix: app.device.ios || ((window.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && window.navigator.userAgent.toLowerCase().indexOf('chrome') < 0) && !app.device.android),
	      cols: [],
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      initialized: false,
	      opened: false,
	      url: picker.params.url,
	      view: view,
	    });

	    function onResize() {
	      picker.resizeCols();
	    }
	    function onInputClick() {
	      picker.open();
	    }
	    function onInputFocus(e) {
	      e.preventDefault();
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $$1$1(e.target);
	      if (picker.isPopover()) { return; }
	      if (!picker.opened) { return; }
	      if ($targetEl.closest('[class*="backdrop"]').length) { return; }
	      if ($inputEl && $inputEl.length > 0) {
	        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
	          picker.close();
	        }
	      } else if ($$1$1(e.target).closest('.sheet-modal').length === 0) {
	        picker.close();
	      }
	    }

	    // Events
	    Utils.extend(picker, {
	      attachResizeEvent: function attachResizeEvent() {
	        app.on('resize', onResize);
	      },
	      detachResizeEvent: function detachResizeEvent() {
	        app.off('resize', onResize);
	      },
	      attachInputEvents: function attachInputEvents() {
	        picker.$inputEl.on('click', onInputClick);
	        if (picker.params.inputReadOnly) {
	          picker.$inputEl.on('focus mousedown', onInputFocus);
	        }
	      },
	      detachInputEvents: function detachInputEvents() {
	        picker.$inputEl.off('click', onInputClick);
	        if (picker.params.inputReadOnly) {
	          picker.$inputEl.off('focus mousedown', onInputFocus);
	        }
	      },
	      attachHtmlEvents: function attachHtmlEvents() {
	        app.on('click', onHtmlClick);
	      },
	      detachHtmlEvents: function detachHtmlEvents() {
	        app.off('click', onHtmlClick);
	      },
	    });

	    picker.init();

	    return picker;
	  }

	  if ( Framework7Class$$1 ) Picker.__proto__ = Framework7Class$$1;
	  Picker.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Picker.prototype.constructor = Picker;
	  Picker.prototype.initInput = function initInput () {
	    var picker = this;
	    if (!picker.$inputEl) { return; }
	    if (picker.params.inputReadOnly) { picker.$inputEl.prop('readOnly', true); }
	  };
	  Picker.prototype.resizeCols = function resizeCols () {
	    var picker = this;
	    if (!picker.opened) { return; }
	    for (var i = 0; i < picker.cols.length; i += 1) {
	      if (!picker.cols[i].divider) {
	        picker.cols[i].calcSize();
	        picker.cols[i].setValue(picker.cols[i].value, 0, false);
	      }
	    }
	  };
	  Picker.prototype.isPopover = function isPopover () {
	    var picker = this;
	    var app = picker.app;
	    var modal = picker.modal;
	    var params = picker.params;
	    if (params.openIn === 'sheet') { return false; }
	    if (modal && modal.type !== 'popover') { return false; }

	    if (!picker.inline && picker.inputEl) {
	      if (params.openIn === 'popover') { return true; }
	      else if (app.device.ios) {
	        return !!app.device.ipad;
	      } else if (app.width >= 768) {
	        return true;
	      }
	    }
	    return false;
	  };
	  Picker.prototype.formatValue = function formatValue () {
	    var picker = this;
	    var value = picker.value;
	    var displayValue = picker.displayValue;
	    if (picker.params.formatValue) {
	      return picker.params.formatValue.call(picker, value, displayValue);
	    }
	    return value.join(' ');
	  };
	  Picker.prototype.setValue = function setValue (values, transition) {
	    var picker = this;
	    var valueIndex = 0;
	    if (picker.cols.length === 0) {
	      picker.value = values;
	      picker.updateValue(values);
	      return;
	    }
	    for (var i = 0; i < picker.cols.length; i += 1) {
	      if (picker.cols[i] && !picker.cols[i].divider) {
	        picker.cols[i].setValue(values[valueIndex], transition);
	        valueIndex += 1;
	      }
	    }
	  };
	  Picker.prototype.getValue = function getValue () {
	    var picker = this;
	    return picker.value;
	  };
	  Picker.prototype.updateValue = function updateValue (forceValues) {
	    var picker = this;
	    var newValue = forceValues || [];
	    var newDisplayValue = [];
	    var column;
	    if (picker.cols.length === 0) {
	      var noDividerColumns = picker.params.cols.filter(function (c) { return !c.divider; });
	      for (var i = 0; i < noDividerColumns.length; i += 1) {
	        column = noDividerColumns[i];
	        if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
	          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
	        } else {
	          newDisplayValue.push(newValue[i]);
	        }
	      }
	    } else {
	      for (var i$1 = 0; i$1 < picker.cols.length; i$1 += 1) {
	        if (!picker.cols[i$1].divider) {
	          newValue.push(picker.cols[i$1].value);
	          newDisplayValue.push(picker.cols[i$1].displayValue);
	        }
	      }
	    }

	    if (newValue.indexOf(undefined) >= 0) {
	      return;
	    }
	    picker.value = newValue;
	    picker.displayValue = newDisplayValue;
	    picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);
	    if (picker.inputEl) {
	      picker.$inputEl.val(picker.formatValue());
	      picker.$inputEl.trigger('change');
	    }
	  };
	  Picker.prototype.initColumn = function initColumn (colEl, updateItems) {
	    var picker = this;
	    pickerColumn.call(picker, colEl, updateItems);
	  };
	  // eslint-disable-next-line
	  Picker.prototype.destroyColumn = function destroyColumn (colEl) {
	    var picker = this;
	    var $colEl = $$1$1(colEl);
	    var index = $colEl.index();
	    if (picker.cols[index] && picker.cols[index].destroy) {
	      picker.cols[index].destroy();
	    }
	  };
	  Picker.prototype.renderToolbar = function renderToolbar () {
	    var picker = this;
	    if (picker.params.renderToolbar) { return picker.params.renderToolbar.call(picker, picker); }
	    return ("\n      <div class=\"toolbar no-shadow\">\n        <div class=\"toolbar-inner\">\n          <div class=\"left\"></div>\n          <div class=\"right\">\n            <a href=\"#\" class=\"link sheet-close popover-close\">" + (picker.params.toolbarCloseText) + "</a>\n          </div>\n        </div>\n      </div>\n    ").trim();
	  };
	  // eslint-disable-next-line
	  Picker.prototype.renderColumn = function renderColumn (col, onlyItems) {
	    var colClasses = "picker-column " + (col.textAlign ? ("picker-column-" + (col.textAlign)) : '') + " " + (col.cssClass || '');
	    var columnHtml;
	    var columnItemsHtml;

	    if (col.divider) {
	      columnHtml = "\n        <div class=\"" + colClasses + " picker-column-divider\">" + (col.content) + "</div>\n      ";
	    } else {
	      columnItemsHtml = col.values.map(function (value, index) { return ("\n        <div class=\"picker-item\" data-picker-value=\"" + value + "\">\n          <span>" + (col.displayValues ? col.displayValues[index] : value) + "</span>\n        </div>\n      "); }).join('');
	      columnHtml = "\n        <div class=\"" + colClasses + "\">\n          <div class=\"picker-items\">" + columnItemsHtml + "</div>\n        </div>\n      ";
	    }

	    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
	  };
	  Picker.prototype.renderInline = function renderInline () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var inlineHtml = ("\n      <div class=\"picker picker-inline " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n        " + (toolbar ? picker.renderToolbar() : '') + "\n        <div class=\"picker-columns\">\n          " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n          <div class=\"picker-center-highlight\"></div>\n        </div>\n      </div>\n    ").trim();

	    return inlineHtml;
	  };
	  Picker.prototype.renderSheet = function renderSheet () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var sheetHtml = ("\n      <div class=\"sheet-modal picker picker-sheet " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n        " + (toolbar ? picker.renderToolbar() : '') + "\n        <div class=\"sheet-modal-inner picker-columns\">\n          " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n          <div class=\"picker-center-highlight\"></div>\n        </div>\n      </div>\n    ").trim();

	    return sheetHtml;
	  };
	  Picker.prototype.renderPopover = function renderPopover () {
	    var picker = this;
	    var ref = picker.params;
	    var rotateEffect = ref.rotateEffect;
	    var cssClass = ref.cssClass;
	    var toolbar = ref.toolbar;
	    var popoverHtml = ("\n      <div class=\"popover picker-popover\">\n        <div class=\"popover-inner\">\n          <div class=\"picker " + (rotateEffect ? 'picker-3d' : '') + " " + (cssClass || '') + "\">\n            " + (toolbar ? picker.renderToolbar() : '') + "\n            <div class=\"picker-columns\">\n              " + (picker.cols.map(function (col) { return picker.renderColumn(col); }).join('')) + "\n              <div class=\"picker-center-highlight\"></div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ").trim();

	    return popoverHtml;
	  };
	  Picker.prototype.render = function render () {
	    var picker = this;
	    if (picker.params.render) { return picker.params.render.call(picker); }
	    if (!picker.inline) {
	      if (picker.isPopover()) { return picker.renderPopover(); }
	      return picker.renderSheet();
	    }
	    return picker.renderInline();
	  };
	  Picker.prototype.onOpen = function onOpen () {
	    var picker = this;
	    var initialized = picker.initialized;
	    var $el = picker.$el;
	    var app = picker.app;
	    var $inputEl = picker.$inputEl;
	    var inline = picker.inline;
	    var value = picker.value;
	    var params = picker.params;
	    picker.opened = true;

	    // Init main events
	    picker.attachResizeEvent();

	    // Init cols
	    $el.find('.picker-column').each(function (index, colEl) {
	      var updateItems = true;
	      if (
	        (!initialized && params.value) ||
	        (initialized && value)
	      ) {
	        updateItems = false;
	      }
	      picker.initColumn(colEl, updateItems);
	    });

	    // Set value
	    if (!initialized) {
	      if (value) { picker.setValue(value, 0); }
	      else if (params.value) {
	        picker.setValue(params.value, 0);
	      }
	    } else if (value) {
	      picker.setValue(value, 0);
	    }

	    // Extra focus
	    if (!inline && $inputEl.length && app.theme === 'md') {
	      $inputEl.trigger('focus');
	    }

	    picker.initialized = true;

	    // Trigger events
	    if ($el) {
	      $el.trigger('picker:open', picker);
	    }
	    if ($inputEl) {
	      $inputEl.trigger('picker:open', picker);
	    }
	    picker.emit('local::open pickerOpen', picker);
	  };
	  Picker.prototype.onOpened = function onOpened () {
	    var picker = this;

	    if (picker.$el) {
	      picker.$el.trigger('picker:opened', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:opened', picker);
	    }
	    picker.emit('local::opened pickerOpened', picker);
	  };
	  Picker.prototype.onClose = function onClose () {
	    var picker = this;
	    var app = picker.app;

	    // Detach events
	    picker.detachResizeEvent();

	    picker.cols.forEach(function (col) {
	      if (col.destroy) { col.destroy(); }
	    });
	    if (picker.$inputEl && app.theme === 'md') {
	      picker.$inputEl.trigger('blur');
	    }

	    if (picker.$el) {
	      picker.$el.trigger('picker:close', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:close', picker);
	    }
	    picker.emit('local::close pickerClose', picker);
	  };
	  Picker.prototype.onClosed = function onClosed () {
	    var picker = this;
	    picker.opened = false;

	    if (!picker.inline) {
	      Utils.nextTick(function () {
	        if (picker.modal && picker.modal.el && picker.modal.destroy) {
	          if (!picker.params.routableModals) {
	            picker.modal.destroy();
	          }
	        }
	        delete picker.modal;
	      });
	    }

	    if (picker.$el) {
	      picker.$el.trigger('picker:closed', picker);
	    }
	    if (picker.$inputEl) {
	      picker.$inputEl.trigger('picker:closed', picker);
	    }
	    picker.emit('local::closed pickerClosed', picker);
	  };
	  Picker.prototype.open = function open () {
	    var obj;

	    var picker = this;
	    var app = picker.app;
	    var opened = picker.opened;
	    var inline = picker.inline;
	    var $inputEl = picker.$inputEl;
	    if (opened) { return; }
	    if (picker.cols.length === 0 && picker.params.cols.length) {
	      picker.params.cols.forEach(function (col) {
	        picker.cols.push(col);
	      });
	    }
	    if (inline) {
	      picker.$el = $$1$1(picker.render());
	      picker.$el[0].f7Picker = picker;
	      picker.$containerEl.append(picker.$el);
	      picker.onOpen();
	      picker.onOpened();
	      return;
	    }
	    var isPopover = picker.isPopover();
	    var modalType = isPopover ? 'popover' : 'sheet';
	    var modalParams = {
	      targetEl: $inputEl,
	      scrollToEl: picker.params.scrollToInput ? $inputEl : undefined,
	      content: picker.render(),
	      backdrop: isPopover,
	      on: {
	        open: function open() {
	          var modal = this;
	          picker.modal = modal;
	          picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
	          picker.$el[0].f7Picker = picker;
	          picker.onOpen();
	        },
	        opened: function opened() { picker.onOpened(); },
	        close: function close() { picker.onClose(); },
	        closed: function closed() { picker.onClosed(); },
	      },
	    };
	    if (picker.params.routableModals) {
	      picker.view.router.navigate({
	        url: picker.url,
	        route: ( obj = {
	          path: picker.url
	        }, obj[modalType] = modalParams, obj ),
	      });
	    } else {
	      picker.modal = app[modalType].create(modalParams);
	      picker.modal.open();
	    }
	  };
	  Picker.prototype.close = function close () {
	    var picker = this;
	    var opened = picker.opened;
	    var inline = picker.inline;
	    if (!opened) { return; }
	    if (inline) {
	      picker.onClose();
	      picker.onClosed();
	      return;
	    }
	    if (picker.params.routableModals) {
	      picker.view.router.back();
	    } else {
	      picker.modal.close();
	    }
	  };
	  Picker.prototype.init = function init () {
	    var picker = this;

	    picker.initInput();

	    if (picker.inline) {
	      picker.open();
	      picker.emit('local::init pickerInit', picker);
	      return;
	    }

	    if (!picker.initialized && picker.params.value) {
	      picker.setValue(picker.params.value);
	    }

	    // Attach input Events
	    if (picker.$inputEl) {
	      picker.attachInputEvents();
	    }
	    if (picker.params.closeByOutsideClick) {
	      picker.attachHtmlEvents();
	    }
	    picker.emit('local::init pickerInit', picker);
	  };
	  Picker.prototype.destroy = function destroy () {
	    var picker = this;
	    if (picker.destroyed) { return; }
	    var $el = picker.$el;
	    picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
	    if ($el) { $el.trigger('picker:beforedestroy', picker); }

	    picker.close();

	    // Detach Events
	    if (picker.$inputEl) {
	      picker.detachInputEvents();
	    }
	    if (picker.params.closeByOutsideClick) {
	      picker.detachHtmlEvents();
	    }

	    if ($el && $el.length) { delete picker.$el[0].f7Picker; }
	    Utils.deleteProps(picker);
	    picker.destroyed = true;
	  };

	  return Picker;
	}(Framework7Class));

	var Picker = {
	  name: 'picker',
	  static: {
	    Picker: Picker$1,
	  },
	  create: function create() {
	    var app = this;
	    app.picker = ConstructorMethods({
	      defaultSelector: '.picker',
	      constructor: Picker$1,
	      app: app,
	      domProp: 'f7Picker',
	    });
	    app.picker.close = function close(el) {
	      if ( el === void 0 ) el = '.picker';

	      var $el = $$1$1(el);
	      if ($el.length === 0) { return; }
	      var picker = $el[0].f7Picker;
	      if (!picker || (picker && !picker.opened)) { return; }
	      picker.close();
	    };
	  },
	  params: {
	    picker: {
	      // Picker settings
	      updateValuesOnMomentum: false,
	      updateValuesOnTouchmove: true,
	      rotateEffect: false,
	      momentumRatio: 7,
	      freeMode: false,
	      cols: [],
	      // Common opener settings
	      containerEl: null,
	      openIn: 'auto', // or 'popover' or 'sheet'
	      formatValue: null,
	      inputEl: null,
	      inputReadOnly: true,
	      closeByOutsideClick: true,
	      scrollToInput: true,
	      toolbar: true,
	      toolbarCloseText: 'Done',
	      cssClass: null,
	      routableModals: true,
	      view: null,
	      url: 'select/',
	      // Render functions
	      renderToolbar: null,
	      render: null,
	    },
	  },
	};

	var InfiniteScroll = {
	  handleScroll: function handleScroll(el, e) {
	    var app = this;
	    var $el = $$1$1(el);
	    var scrollTop = $el[0].scrollTop;
	    var scrollHeight = $el[0].scrollHeight;
	    var height = $el[0].offsetHeight;
	    var distance = $el[0].getAttribute('data-infinite-distance');

	    var virtualListContainer = $el.find('.virtual-list');
	    var virtualList;

	    var onTop = $el.hasClass('infinite-scroll-top');
	    if (!distance) { distance = 50; }
	    if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
	      distance = (parseInt(distance, 10) / 100) * height;
	    }
	    if (distance > height) { distance = height; }
	    if (onTop) {
	      if (scrollTop < distance) {
	        $el.trigger('infinite', e);
	        app.emit('infinite', $el[0], e);
	      }
	    } else if (scrollTop + height >= scrollHeight - distance) {
	      if (virtualListContainer.length > 0) {
	        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
	        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
	          return;
	        }
	      }
	      $el.trigger('infinite', e);
	      app.emit('infinite', $el[0], e);
	    }
	  },
	  create: function create(el) {
	    var $el = $$1$1(el);
	    var app = this;
	    $el.on('scroll', function handle(e) {
	      app.infiniteScroll.handle(this, e);
	    });
	  },
	  destroy: function destroy(el) {
	    var $el = $$1$1(el);
	    $el.off('scroll');
	  },
	};
	var InfiniteScroll$1 = {
	  name: 'infiniteScroll',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      infiniteScroll: {
	        handle: InfiniteScroll.handleScroll.bind(app),
	        create: InfiniteScroll.create.bind(app),
	        destroy: InfiniteScroll.destroy.bind(app),
	      },
	    });
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $$1$1(tabEl);
	      $tabEl.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.create(el);
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var $tabEl = $$1$1(tabEl);
	      var app = this;
	      $tabEl.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.destroy(el);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.create(el);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.infinite-scroll-content').each(function (index, el) {
	        app.infiniteScroll.destroy(el);
	      });
	    },
	  },
	};

	var PullToRefresh$1 = (function (Framework7Class$$1) {
	  function PullToRefresh(app, el) {
	    Framework7Class$$1.call(this, {}, [app]);
	    var ptr = this;
	    var $el = $$1$1(el);
	    var $preloaderEl = $el.find('.ptr-preloader');

	    ptr.$el = $el;
	    ptr.el = $el[0];
	    ptr.app = app;

	    // Extend defaults with modules params
	    ptr.useModulesParams({});

	    var isMaterial = app.theme === 'md';

	    // Done
	    ptr.done = function done() {
	      var $transitionTarget = isMaterial ? $preloaderEl : $el;
	      $transitionTarget.transitionEnd(function () {
	        $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down');
	        $el.trigger('ptr:done');
	        ptr.emit('local::done ptrDone', $el[0]);
	      });
	      $el.removeClass('ptr-refreshing').addClass('ptr-transitioning');
	      return ptr;
	    };

	    ptr.refresh = function refresh() {
	      if ($el.hasClass('ptr-refreshing')) { return ptr; }
	      $el.addClass('ptr-transitioning ptr-refreshing');
	      $el.trigger('ptr:refresh', ptr.done);
	      ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
	      return ptr;
	    };

	    // Events handling
	    var touchId;
	    var isTouched;
	    var isMoved;
	    var touchesStart = {};
	    var isScrolling;
	    var touchesDiff;
	    var refresh = false;
	    var useTranslate = false;
	    var startTranslate = 0;
	    var translate;
	    var scrollTop;
	    var wasScrolled;
	    var triggerDistance;
	    var dynamicTriggerDistance;
	    var pullStarted;
	    var hasNavbar = false;
	    var $pageEl = $el.parents('.page');

	    if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbar').length > 0) { hasNavbar = true; }
	    if ($pageEl.hasClass('no-navbar')) { hasNavbar = false; }
	    if (!hasNavbar) { $el.addClass('ptr-no-navbar'); }

	    // Define trigger distance
	    if ($el.attr('data-ptr-distance')) {
	      dynamicTriggerDistance = true;
	    } else {
	      triggerDistance = isMaterial ? 66 : 44;
	    }

	    function handleTouchStart(e) {
	      if (isTouched) {
	        if (Device.os === 'android') {
	          if ('targetTouches' in e && e.targetTouches.length > 1) { return; }
	        } else { return; }
	      }

	      if ($el.hasClass('ptr-refreshing')) {
	        return;
	      }
	      if ($$1$1(e.target).closest('.sortable-handler').length) { return; }

	      isMoved = false;
	      pullStarted = false;
	      isTouched = true;
	      isScrolling = undefined;
	      wasScrolled = undefined;
	      if (e.type === 'touchstart') { touchId = e.targetTouches[0].identifier; }
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    }

	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX;
	      var pageY;
	      var touch;
	      if (e.type === 'touchmove') {
	        if (touchId && e.touches) {
	          for (var i = 0; i < e.touches.length; i += 1) {
	            if (e.touches[i].identifier === touchId) {
	              touch = e.touches[i];
	            }
	          }
	        }
	        if (!touch) { touch = e.targetTouches[0]; }
	        pageX = touch.pageX;
	        pageY = touch.pageY;
	      } else {
	        pageX = e.pageX;
	        pageY = e.pageY;
	      }
	      if (!pageX || !pageY) { return; }


	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
	      }
	      if (!isScrolling) {
	        isTouched = false;
	        return;
	      }

	      scrollTop = $el[0].scrollTop;
	      if (typeof wasScrolled === 'undefined' && scrollTop !== 0) { wasScrolled = true; }

	      if (!isMoved) {
	        $el.removeClass('ptr-transitioning');
	        if (scrollTop > $el[0].offsetHeight) {
	          isTouched = false;
	          return;
	        }
	        if (dynamicTriggerDistance) {
	          triggerDistance = $el.attr('data-ptr-distance');
	          if (triggerDistance.indexOf('%') >= 0) { triggerDistance = ($el[0].offsetHeight * parseInt(triggerDistance, 10)) / 100; }
	        }
	        startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;
	        if ($el[0].scrollHeight === $el[0].offsetHeight || Device.os !== 'ios' || isMaterial) {
	          useTranslate = true;
	        } else {
	          useTranslate = false;
	        }
	      }
	      isMoved = true;
	      touchesDiff = pageY - touchesStart.y;

	      if ((touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0) {
	        // iOS 8 fix
	        if (Device.os === 'ios' && parseInt(Device.osVersion.split('.')[0], 10) > 7 && scrollTop === 0 && !wasScrolled) { useTranslate = true; }

	        if (useTranslate) {
	          e.preventDefault();
	          translate = (Math.pow( touchesDiff, 0.85 )) + startTranslate;
	          if (isMaterial) {
	            $preloaderEl.transform(("translate3d(0," + translate + "px,0)"))
	              .find('.ptr-arrow').transform(("rotate(" + ((180 * (touchesDiff / 66)) + 100) + "deg)"));
	          } else {
	            $el.transform(("translate3d(0," + translate + "px,0)"));
	          }
	        }
	        if ((useTranslate && (Math.pow( touchesDiff, 0.85 )) > triggerDistance) || (!useTranslate && touchesDiff >= triggerDistance * 2)) {
	          refresh = true;
	          $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
	        } else {
	          refresh = false;
	          $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
	        }
	        if (!pullStarted) {
	          $el.trigger('ptr:pullstart');
	          ptr.emit('local::pullStart ptrPullStart', $el[0]);
	          pullStarted = true;
	        }
	        $el.trigger('ptr:pullmove', {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	        ptr.emit('local::pullMove ptrPullMove', $el[0], {
	          event: e,
	          scrollTop: scrollTop,
	          translate: translate,
	          touchesDiff: touchesDiff,
	        });
	      } else {
	        pullStarted = false;
	        $el.removeClass('ptr-pull-up ptr-pull-down');
	        refresh = false;
	      }
	    }
	    function handleTouchEnd(e) {
	      if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
	        if (e.changedTouches[0].identifier !== touchId) {
	          isTouched = false;
	          isScrolling = false;
	          isMoved = false;
	          touchId = null;
	          return;
	        }
	      }
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      if (translate) {
	        $el.addClass('ptr-transitioning');
	        translate = 0;
	      }
	      if (isMaterial) {
	        $preloaderEl.transform('')
	          .find('.ptr-arrow').transform('');
	      } else {
	        $el.transform('');
	      }

	      if (refresh) {
	        $el.addClass('ptr-refreshing');
	        $el.trigger('ptr:refresh', ptr.done);
	        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
	      } else {
	        $el.removeClass('ptr-pull-down');
	      }
	      isTouched = false;
	      isMoved = false;
	      if (pullStarted) {
	        $el.trigger('ptr:pullend');
	        ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
	      }
	    }

	    if (!$pageEl.length || !$el.length) { return ptr; }

	    $el[0].f7PullToRefresh = ptr;

	    // Events
	    ptr.attachEvents = function attachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      $el.on(app.touchEvents.start, handleTouchStart, passive);
	      app.on('touchmove', handleTouchMove);
	      app.on('touchend:passive', handleTouchEnd);
	    };
	    ptr.detachEvents = function detachEvents() {
	      var passive = Support.passiveListener ? { passive: true } : false;
	      $el.off(app.touchEvents.start, handleTouchStart, passive);
	      app.off('touchmove', handleTouchMove);
	      app.off('touchend:passive', handleTouchEnd);
	    };

	    // Install Modules
	    ptr.useModules();

	    // Init
	    ptr.init();

	    return ptr;
	  }

	  if ( Framework7Class$$1 ) PullToRefresh.__proto__ = Framework7Class$$1;
	  PullToRefresh.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  PullToRefresh.prototype.constructor = PullToRefresh;
	  PullToRefresh.prototype.init = function init () {
	    var ptr = this;
	    ptr.attachEvents();
	  };
	  PullToRefresh.prototype.destroy = function destroy () {
	    var ptr = this;
	    ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
	    ptr.$el.trigger('ptr:beforedestroy', ptr);
	    delete ptr.el.f7PullToRefresh;
	    ptr.detachEvents();
	    Utils.deleteProps(ptr);
	    ptr = null;
	  };

	  return PullToRefresh;
	}(Framework7Class));

	var PullToRefresh = {
	  name: 'pullToRefresh',
	  create: function create() {
	    var app = this;
	    app.ptr = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: '.ptr-content',
	        constructor: PullToRefresh$1,
	        app: app,
	        domProp: 'f7PullToRefresh',
	      }),
	      {
	        done: function done(el) {
	          var ptr = app.ptr.get(el);
	          if (ptr) { return ptr.done(); }
	          return undefined;
	        },
	        refresh: function refresh(el) {
	          var ptr = app.ptr.get(el);
	          if (ptr) { return ptr.refresh(); }
	          return undefined;
	        },
	      }
	    );
	  },
	  static: {
	    PullToRefresh: PullToRefresh$1,
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $$1$1(tabEl);
	      $tabEl.find('.ptr-content').each(function (index, el) {
	        app.ptr.create(el);
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var $tabEl = $$1$1(tabEl);
	      var app = this;
	      $tabEl.find('.ptr-content').each(function (index, el) {
	        app.ptr.destroy(el);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.ptr-content').each(function (index, el) {
	        app.ptr.create(el);
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.ptr-content').each(function (index, el) {
	        app.ptr.destroy(el);
	      });
	    },
	  },
	};

	var Lazy = {
	  destroy: function destroy(pageEl) {
	    var $pageEl = $$1$1(pageEl).closest('.page');
	    if (!$pageEl.length) { return; }
	    if ($pageEl[0].f7LazyDestroy) {
	      $pageEl[0].f7LazyDestroy();
	    }
	  },
	  create: function create(pageEl) {
	    var app = this;
	    var $pageEl = $$1$1(pageEl).closest('.page').eq(0);

	    // Lazy images
	    var lazyLoadImages = $pageEl.find('.lazy');
	    if (lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) { return; }

	    // Placeholder
	    var placeholderSrc = app.params.lazy.placeholder;

	    if (placeholderSrc !== false) {
	      lazyLoadImages.each(function (index, lazyEl) {
	        if ($$1$1(lazyEl).attr('data-src') && !$$1$1(lazyEl).attr('src')) { $$1$1(lazyEl).attr('src', placeholderSrc); }
	      });
	    }

	    // load image
	    var imagesSequence = [];
	    var imageIsLoading = false;

	    function onImageComplete(lazyEl) {
	      if (imagesSequence.indexOf(lazyEl) >= 0) {
	        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
	      }
	      imageIsLoading = false;
	      if (app.params.lazy.sequential && imagesSequence.length > 0) {
	        imageIsLoading = true;
	        app.lazy.loadImage(imagesSequence[0], onImageComplete);
	      }
	    }

	    function lazyHandler() {
	      app.lazy.load($pageEl, function (lazyEl) {
	        if (app.params.lazy.sequential && imageIsLoading) {
	          if (imagesSequence.indexOf(lazyEl) < 0) { imagesSequence.push(lazyEl); }
	          return;
	        }
	        imageIsLoading = true;
	        app.lazy.loadImage(lazyEl, onImageComplete);
	      });
	    }

	    function attachEvents() {
	      $pageEl[0].f7LazyAttached = true;
	      $pageEl.on('lazy', lazyHandler);
	      $pageEl.on('scroll', lazyHandler, true);
	      $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
	      app.on('resize', lazyHandler);
	    }
	    function detachEvents() {
	      $pageEl[0].f7LazyAttached = false;
	      delete $pageEl[0].f7LazyAttached;
	      $pageEl.off('lazy', lazyHandler);
	      $pageEl.off('scroll', lazyHandler, true);
	      $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
	      app.off('resize', lazyHandler);
	    }

	    // Store detach function
	    if (!$pageEl[0].f7LazyDestroy) {
	      $pageEl[0].f7LazyDestroy = detachEvents;
	    }

	    // Attach events
	    if (!$pageEl[0].f7LazyAttached) {
	      attachEvents();
	    }

	    // Run loader on page load/init
	    lazyHandler();
	  },
	  isInViewport: function isInViewport(lazyEl) {
	    var app = this;
	    var rect = lazyEl.getBoundingClientRect();
	    var threshold = app.params.lazy.threshold || 0;

	    return (
	      rect.top >= (0 - threshold) &&
	      rect.left >= (0 - threshold) &&
	      rect.top <= (app.height + threshold) &&
	      rect.left <= (app.width + threshold)
	    );
	  },
	  loadImage: function loadImage(imageEl, callback) {
	    var app = this;
	    var $imageEl = $$1$1(imageEl);

	    var bg = $imageEl.attr('data-background');
	    var src = bg || $imageEl.attr('data-src');
	    if (!src) { return; }
	    function onLoad() {
	      $imageEl.removeClass('lazy').addClass('lazy-loaded');
	      if (bg) {
	        $imageEl.css('background-image', ("url(" + src + ")"));
	      } else {
	        $imageEl.attr('src', src);
	      }
	      if (callback) { callback(imageEl); }
	      $imageEl.trigger('lazy:loaded');
	      app.emit('lazyLoaded', $imageEl[0]);
	    }

	    function onError() {
	      $imageEl.removeClass('lazy').addClass('lazy-loaded');
	      if (bg) {
	        $imageEl.css('background-image', ("url(" + (app.params.lazy.placeholder || '') + ")"));
	      } else {
	        $imageEl.attr('src', app.params.lazy.placeholder || '');
	      }
	      if (callback) { callback(imageEl); }
	      $imageEl.trigger('lazy:error');
	      app.emit('lazyError', $imageEl[0]);
	    }
	    var image = new window.Image();
	    image.onload = onLoad;
	    image.onerror = onError;
	    image.src = src;

	    $imageEl.removeAttr('data-src').removeAttr('data-background');

	    // Add loaded callback and events
	    $imageEl.trigger('lazy:load');
	    app.emit('lazyLoad', $imageEl[0]);
	  },
	  load: function load(pageEl, callback) {
	    var app = this;
	    var $pageEl = $$1$1(pageEl);
	    if (!$pageEl.hasClass('page')) { $pageEl = $pageEl.parents('.page').eq(0); }
	    if ($pageEl.length === 0) {
	      return;
	    }
	    $pageEl.find('.lazy').each(function (index, lazyEl) {
	      var $lazyEl = $$1$1(lazyEl);
	      if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
	        return;
	      }
	      if (app.lazy.isInViewport(lazyEl)) {
	        if (callback) { callback(lazyEl); }
	        else { app.lazy.loadImage(lazyEl); }
	      }
	    });
	  },

	};
	var Lazy$1 = {
	  name: 'lazy',
	  params: {
	    lazy: {
	      placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
	      threshold: 0,
	      sequential: true,
	    },
	  },
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      lazy: {
	        create: Lazy.create.bind(app),
	        destroy: Lazy.destroy.bind(app),
	        loadImage: Lazy.loadImage.bind(app),
	        load: Lazy.load.bind(app),
	        isInViewport: Lazy.isInViewport.bind(app),
	      },
	    });
	  },
	  on: {
	    pageInit: function pageInit(page) {
	      var app = this;
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.create(page.$el);
	      }
	    },
	    pageAfterIn: function pageAfterIn(page) {
	      var app = this;
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.create(page.$el);
	      }
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
	        app.lazy.destroy(page.$el);
	      }
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      var $tabEl = $$1$1(tabEl);
	      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
	        app.lazy.create($tabEl);
	      }
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      var $tabEl = $$1$1(tabEl);
	      if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
	        app.lazy.destroy($tabEl);
	      }
	    },
	  },
	};

	var DataTable$1 = (function (Framework7Class$$1) {
	  function DataTable(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);

	    var table = this;

	    var defaults = {

	    };

	    // Extend defaults with modules params
	    table.useModulesParams(defaults);

	    table.params = Utils.extend(defaults, params);

	    // El
	    var $el = $$1$1(table.params.el);
	    if ($el.length === 0) { return undefined; }

	    table.$el = $el;
	    table.el = $el[0];

	    if (table.$el[0].f7DataTable) {
	      var instance = table.$el[0].f7DataTable;
	      table.destroy();
	      return instance;
	    }

	    table.$el[0].f7DataTable = table;

	    Utils.extend(table, {
	      collapsible: $el.hasClass('data-table-collapsible'),
	      // Headers
	      $headerEl: $el.find('.data-table-header'),
	      $headerSelectedEl: $el.find('.data-table-header-selected'),
	    });

	    // Events
	    function handleChange(e) {
	      if (e.detail && e.detail.sentByF7DataTable) {
	        // Scripted event, don't do anything
	        return;
	      }
	      var $inputEl = $$1$1(this);
	      var checked = $inputEl[0].checked;
	      var columnIndex = $inputEl.parents('td,th').index();

	      if ($inputEl.parents('thead').length > 0) {
	        if (columnIndex === 0) {
	          $el
	            .find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
	        }
	        $el
	          .find(("tbody tr td:nth-child(" + (columnIndex + 1) + ") input"))
	          .prop('checked', checked)
	          .trigger('change', { sentByF7DataTable: true });
	      } else {
	        if (columnIndex === 0) {
	          $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
	        }

	        if (!checked) {
	          $el.find(("thead .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]")).prop('checked', false);
	        } else if ($el.find(("tbody .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]:checked")).length === $el.find('tbody tr').length) {
	          $el.find(("thead .checkbox-cell:nth-child(" + (columnIndex + 1) + ") input[type=\"checkbox\"]")).prop('checked', true).trigger('change', { sentByF7DataTable: true });
	        }
	      }
	      table.checkSelectedHeader();
	    }
	    function handleSortableClick() {
	      var $cellEl = $$1$1(this);
	      var isActive = $cellEl.hasClass('sortable-cell-active');
	      var currentSort;
	      if (isActive) {
	        currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
	        $cellEl.removeClass('sortable-desc sortable-asc').addClass(("sortable-" + (currentSort === 'desc' ? 'asc' : 'desc')));
	      } else {
	        $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
	        $cellEl.addClass('sortable-cell-active');
	      }
	    }
	    table.attachEvents = function attachEvents() {
	      table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
	      table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
	    };
	    table.detachEvents = function detachEvents() {
	      table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
	      table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
	    };

	    // Install Modules
	    table.useModules();

	    // Init
	    table.init();

	    return table;
	  }

	  if ( Framework7Class$$1 ) DataTable.__proto__ = Framework7Class$$1;
	  DataTable.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  DataTable.prototype.constructor = DataTable;
	  DataTable.prototype.setCollapsibleLabels = function setCollapsibleLabels () {
	    var table = this;
	    if (!table.collapsible) { return; }
	    table.$el.find('tbody td:not(.checkbox-cell)').each(function (index, el) {
	      var $el = $$1$1(el);
	      var elIndex = $el.index();
	      var collpsibleTitle = $el.attr('data-collapsible-title');
	      if (!collpsibleTitle && collpsibleTitle !== '') {
	        $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
	      }
	    });
	  };
	  DataTable.prototype.checkSelectedHeader = function checkSelectedHeader () {
	    var table = this;
	    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
	      var checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
	      table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
	      table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
	    }
	  };
	  DataTable.prototype.init = function init () {
	    var table = this;
	    table.attachEvents();
	    table.setCollapsibleLabels();
	    table.checkSelectedHeader();
	  };
	  DataTable.prototype.destroy = function destroy () {
	    var table = this;

	    table.$el.trigger('datatable:beforedestroy', table);
	    table.emit('local::beforeDestroy datatableBeforeDestroy', table);

	    table.attachEvents();
	    table.$el[0].f7DataTable = null;
	    delete table.$el[0].f7DataTable;
	    Utils.deleteProps(table);
	    table = null;
	  };

	  return DataTable;
	}(Framework7Class));

	var DataTable = {
	  name: 'dataTable',
	  static: {
	    DataTable: DataTable$1,
	  },
	  create: function create() {
	    var app = this;
	    app.dataTable = ConstructorMethods({
	      defaultSelector: '.data-table',
	      constructor: DataTable$1,
	      app: app,
	      domProp: 'f7DataTable',
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.destroy(tableEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.create({ el: tableEl });
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.destroy(tableEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.data-table-init').each(function (index, tableEl) {
	        app.dataTable.create({ el: tableEl });
	      });
	    },
	  },
	  clicks: {

	  },
	};

	var Fab = {
	  morphOpen: function morphOpen(fabEl, targetEl) {
	    var app = this;
	    var $fabEl = $$1$1(fabEl);
	    var $targetEl = $$1$1(targetEl);
	    if ($targetEl.length === 0) { return; }

	    $targetEl.transition(0).addClass('fab-morph-target-visible');
	    var target = {
	      width: $targetEl[0].offsetWidth,
	      height: $targetEl[0].offsetHeight,
	      offset: $targetEl.offset(),
	      borderRadius: $targetEl.css('border-radius'),
	      zIndex: $targetEl.css('z-index'),
	    };
	    var fab = {
	      width: $fabEl[0].offsetWidth,
	      height: $fabEl[0].offsetHeight,
	      offset: $fabEl.offset(),
	      translateX: Utils.getTranslate($fabEl[0], 'x'),
	      translateY: Utils.getTranslate($fabEl[0], 'y'),
	    };

	    $fabEl[0].f7FabMorphData = {
	      $targetEl: $targetEl,
	      target: target,
	      fab: fab,
	    };

	    var diffX = (fab.offset.left + (fab.width / 2)) -
	                  (target.offset.left + (target.width / 2)) -
	                  fab.translateX;
	    var diffY = (fab.offset.top + (fab.height / 2)) -
	                  (target.offset.top + (target.height / 2)) -
	                  fab.translateY;
	    var scaleX = target.width / fab.width;
	    var scaleY = target.height / fab.height;

	    var borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
	    if (borderRadius > 0) { borderRadius += 2; }

	    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
	      $fabEl.transition(0).transform('');
	      $targetEl.transition(0);
	      target.width = $targetEl[0].offsetWidth;
	      target.height = $targetEl[0].offsetHeight;
	      target.offset = $targetEl.offset();
	      fab.offset = $fabEl.offset();

	      var diffXNew = (fab.offset.left + (fab.width / 2)) -
	                      (target.offset.left + (target.width / 2)) -
	                      fab.translateX;
	      var diffYNew = (fab.offset.top + (fab.height / 2)) -
	                      (target.offset.top + (target.height / 2)) -
	                      fab.translateY;
	      var scaleXNew = target.width / fab.width;
	      var scaleYNew = target.height / fab.height;

	      $fabEl.transform(("translate3d(" + (-diffXNew) + "px, " + (-diffYNew) + "px, 0) scale(" + scaleXNew + ", " + scaleYNew + ")"));
	    };

	    $targetEl
	      .css('opacity', 0)
	      .transform(("scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));
	    $fabEl
	      .addClass('fab-opened')
	      .css('z-index', target.zIndex - 1)
	      .transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0)"));
	    $fabEl.transitionEnd(function () {
	      $targetEl.transition('');
	      Utils.nextTick(function () {
	        $targetEl.css('opacity', 1).transform('scale(1,1)');
	      });
	      $fabEl.transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0) scale(" + scaleX + ", " + scaleY + ")"))
	        .css('border-radius', (borderRadius + "px"))
	        .css('box-shadow', 'none');
	      app.on('resize', $fabEl[0].f7FabMorphResizeHandler);
	      if ($targetEl.parents('.page-content').length > 0) {
	        $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
	      }
	    });
	  },
	  morphClose: function morphClose(fabEl) {
	    var app = this;
	    var $fabEl = $$1$1(fabEl);
	    var morphData = $fabEl[0].f7FabMorphData;
	    if (!morphData) { return; }
	    var $targetEl = morphData.$targetEl;
	    var target = morphData.target;
	    var fab = morphData.fab;
	    if ($targetEl.length === 0) { return; }

	    var diffX = (fab.offset.left + (fab.width / 2)) -
	                  (target.offset.left + (target.width / 2)) -
	                  fab.translateX;
	    var diffY = (fab.offset.top + (fab.height / 2)) -
	                  (target.offset.top + (target.height / 2)) -
	                  fab.translateY;
	    var scaleX = target.width / fab.width;
	    var scaleY = target.height / fab.height;

	    app.off('resize', $fabEl[0].f7FabMorphResizeHandler);
	    if ($targetEl.parents('.page-content').length > 0) {
	      $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
	    }

	    $targetEl
	      .css('opacity', 0)
	      .transform(("scale(" + (1 / scaleX) + ", " + (1 / scaleY) + ")"));
	    $fabEl
	      .transition('')
	      .css('box-shadow', '')
	      .css('border-radius', '')
	      .transform(("translate3d(" + (-diffX) + "px, " + (-diffY) + "px, 0)"));
	    $fabEl.transitionEnd(function () {
	      $fabEl
	        .css('z-index', '')
	        .removeClass('fab-opened')
	        .transform('');
	      Utils.nextTick(function () {
	        $fabEl.transitionEnd(function () {
	          $targetEl
	            .removeClass('fab-morph-target-visible')
	            .css('opacity', '')
	            .transform('')
	            .transition('');
	        });
	      });
	    });
	  },
	  open: function open(fabEl, targetEl) {
	    var app = this;
	    var $fabEl = $$1$1(fabEl).eq(0);
	    var $buttonsEl = $fabEl.find('.fab-buttons');
	    if (!$fabEl.length) { return; }
	    if ($fabEl.hasClass('fab-opened')) { return; }
	    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) { return; }

	    if (app.fab.openedEl) {
	      if (app.fab.openedEl === $fabEl[0]) { return; }
	      app.fab.close(app.fab.openedEl);
	    }
	    app.fab.openedEl = $fabEl[0];
	    if ($fabEl.hasClass('fab-morph')) {
	      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
	    } else {
	      $fabEl.addClass('fab-opened');
	    }
	    $fabEl.trigger('fab:open');
	  },
	  close: function close(fabEl) {
	    if ( fabEl === void 0 ) fabEl = '.fab-opened';

	    var app = this;
	    var $fabEl = $$1$1(fabEl).eq(0);
	    var $buttonsEl = $fabEl.find('.fab-buttons');
	    if (!$fabEl.length) { return; }
	    if (!$fabEl.hasClass('fab-opened')) { return; }
	    if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) { return; }
	    app.fab.openedEl = null;
	    if ($fabEl.hasClass('fab-morph')) {
	      app.fab.morphClose($fabEl);
	    } else {
	      $fabEl.removeClass('fab-opened');
	    }
	    $fabEl.trigger('fab:close');
	  },
	  toggle: function toggle(fabEl) {
	    var app = this;
	    var $fabEl = $$1$1(fabEl);
	    if (!$fabEl.hasClass('fab-opened')) { app.fab.open(fabEl); }
	    else { app.fab.close(fabEl); }
	  },
	};

	var Fab$1 = {
	  name: 'fab',
	  create: function create() {
	    var app = this;
	    Utils.extend(app, {
	      fab: {
	        openedEl: null,
	        morphOpen: Fab.morphOpen.bind(app),
	        morphClose: Fab.morphClose.bind(app),
	        open: Fab.open.bind(app),
	        close: Fab.close.bind(app),
	        toggle: Fab.toggle.bind(app),
	      },
	    });
	  },
	  clicks: {
	    '.fab > a': function open($clickedEl) {
	      var app = this;
	      app.fab.toggle($clickedEl.parents('.fab'));
	    },
	    '.fab-open': function open($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.fab.open(data.fab);
	    },
	    '.fab-close': function close($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      app.fab.close(data.fab);
	    },
	  },
	};

	var Searchbar$1 = (function (FrameworkClass) {
	  function Searchbar(app, params) {
	    if ( params === void 0 ) params = {};

	    FrameworkClass.call(this, params, [app]);

	    var sb = this;

	    var defaults = {
	      el: undefined,
	      inputEl: undefined,
	      disableButton: true,
	      disableButtonEl: undefined,
	      backdropEl: undefined,
	      searchContainer: undefined, // container to search, HTMLElement or CSS selector
	      searchItem: 'li', // single item selector, CSS selector
	      searchIn: undefined, // where to search in item, CSS selector
	      ignore: '.searchbar-ignore',
	      foundEl: '.searchbar-found',
	      notFoundEl: '.searchbar-not-found',
	      hideOnEnableEl: '.searchbar-hide-on-enable',
	      hideOnSearchEl: '.searchbar-hide-on-search',
	      backdrop: true,
	      removeDiacritics: true,
	      customSearch: false,
	      hideDividers: true,
	      hideGroups: true,
	      disableOnBackdropClick: true,
	      expandable: false,
	    };

	    // Extend defaults with modules params
	    sb.useModulesParams(defaults);

	    sb.params = Utils.extend(defaults, params);

	    var $el = $$1$1(sb.params.el);
	    if ($el.length === 0) { return sb; }

	    $el[0].f7Searchbar = sb;

	    var $pageEl;
	    var $navbarEl;
	    if ($el.parents('.page').length > 0) {
	      $pageEl = $el.parents('.page');
	    } else {
	      $navbarEl = $el.parents('.navbar-inner');
	      if ($navbarEl.length > 0) {
	        if ($navbarEl[0].f7Page) {
	          $pageEl = $navbarEl[0].f7Page.$el;
	        } else {
	          var $currentPageEl = $el.parents('.view').find('.page-current');
	          if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
	            $pageEl = $currentPageEl;
	          }
	        }
	      }
	    }

	    var $foundEl;
	    if (params.foundEl) {
	      $foundEl = $$1$1(params.foundEl);
	    } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
	      $foundEl = $pageEl.find(sb.params.foundEl);
	    }

	    var $notFoundEl;
	    if (params.notFoundEl) {
	      $notFoundEl = $$1$1(params.notFoundEl);
	    } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
	      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
	    }

	    var $hideOnEnableEl;
	    if (params.hideOnEnableEl) {
	      $hideOnEnableEl = $$1$1(params.hideOnEnableEl);
	    } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
	      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
	    }

	    var $hideOnSearchEl;
	    if (params.hideOnSearchEl) {
	      $hideOnSearchEl = $$1$1(params.hideOnSearchEl);
	    } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
	      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
	    }

	    var $backdropEl;
	    if (sb.params.backdrop) {
	      if (sb.params.backdropEl) {
	        $backdropEl = $$1$1(sb.params.backdropEl);
	      } else if ($pageEl && $pageEl.length > 0) {
	        $backdropEl = $pageEl.find('.searchbar-backdrop');
	      } else {
	        $backdropEl = $el.siblings('.searchbar-backdrop');
	      }
	      if ($backdropEl.length === 0) {
	        $backdropEl = $$1$1('<div class="searchbar-backdrop"></div>');
	        if ($pageEl && $pageEl.length) {
	          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
	            $backdropEl.insertBefore($el);
	          } else {
	            $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
	          }
	        } else {
	          $backdropEl.insertBefore($el);
	        }
	      }
	    }

	    var $searchContainer;
	    if (sb.params.searchContainer) {
	      $searchContainer = $$1$1(sb.params.searchContainer);
	    }

	    var $inputEl;
	    if (sb.params.inputEl) {
	      $inputEl = $$1$1(sb.params.inputEl);
	    } else {
	      $inputEl = $el.find('input[type="search"]').eq(0);
	    }

	    var $disableButtonEl;
	    if (sb.params.disableButton) {
	      if (sb.params.disableButtonEl) {
	        $disableButtonEl = $$1$1(sb.params.disableButtonEl);
	      } else {
	        $disableButtonEl = $el.find('.searchbar-disable-button');
	      }
	    }

	    Utils.extend(sb, {
	      app: app,
	      view: app.views.get($el.parents('.view')),
	      $el: $el,
	      el: $el[0],
	      $backdropEl: $backdropEl,
	      backdropEl: $backdropEl && $backdropEl[0],
	      $searchContainer: $searchContainer,
	      searchContainer: $searchContainer && $searchContainer[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl[0],
	      $disableButtonEl: $disableButtonEl,
	      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
	      disableButtonHasMargin: false,
	      $pageEl: $pageEl,
	      pageEl: $pageEl && $pageEl[0],
	      $navbarEl: $navbarEl,
	      navbarEl: $navbarEl && $navbarEl[0],
	      $foundEl: $foundEl,
	      foundEl: $foundEl && $foundEl[0],
	      $notFoundEl: $notFoundEl,
	      notFoundEl: $notFoundEl && $notFoundEl[0],
	      $hideOnEnableEl: $hideOnEnableEl,
	      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
	      $hideOnSearchEl: $hideOnSearchEl,
	      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
	      previousQuery: '',
	      query: '',
	      isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
	      virtualList: undefined,
	      enabled: false,
	      expandable: sb.params.expandable || $el.hasClass('searchbar-expandable'),
	    });

	    // Events
	    function preventSubmit(e) {
	      e.preventDefault();
	    }
	    function onInputFocus(e) {
	      sb.enable(e);
	      sb.$el.addClass('searchbar-focused');
	    }
	    function onInputBlur() {
	      sb.$el.removeClass('searchbar-focused');
	    }
	    function onInputChange() {
	      var value = sb.$inputEl.val().trim();
	      if (
	        (
	          (sb.$searchContainer && sb.$searchContainer.length > 0) &&
	          (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem)
	        ) ||
	        sb.params.customSearch
	      ) {
	        sb.search(value, true);
	      }
	    }
	    function onInputClear(e, previousValue) {
	      sb.$el.trigger('searchbar:clear', previousValue);
	      sb.emit('local::clear searchbarClear', sb, previousValue);
	    }
	    function disableOnClick(e) {
	      sb.disable(e);
	    }
	    function onPageBeforeOut() {
	      if (!sb || (sb && !sb.$el)) { return; }
	      if (sb.enabled) {
	        sb.$el.removeClass('searchbar-enabled');
	      }
	    }
	    function onPageBeforeIn() {
	      if (!sb || (sb && !sb.$el)) { return; }
	      if (sb.enabled) {
	        sb.$el.addClass('searchbar-enabled');
	      }
	    }
	    sb.attachEvents = function attachEvents() {
	      $el.on('submit', preventSubmit);
	      if (sb.params.disableButton) {
	        sb.$disableButtonEl.on('click', disableOnClick);
	      }
	      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
	        sb.$backdropEl.on('click', disableOnClick);
	      }
	      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl && sb.$pageEl) {
	        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
	        sb.$pageEl.on('page:beforein', onPageBeforeIn);
	      }
	      sb.$inputEl.on('focus', onInputFocus);
	      sb.$inputEl.on('blur', onInputBlur);
	      sb.$inputEl.on('change input compositionend', onInputChange);
	      sb.$inputEl.on('input:clear', onInputClear);
	    };
	    sb.detachEvents = function detachEvents() {
	      $el.off('submit', preventSubmit);
	      if (sb.params.disableButton) {
	        sb.$disableButtonEl.off('click', disableOnClick);
	      }
	      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
	        sb.$backdropEl.off('click', disableOnClick);
	      }
	      if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl && sb.$pageEl) {
	        sb.$pageEl.on('page:beforeout', onPageBeforeOut);
	        sb.$pageEl.on('page:beforein', onPageBeforeIn);
	      }
	      sb.$inputEl.off('focus', onInputFocus);
	      sb.$inputEl.off('blur', onInputBlur);
	      sb.$inputEl.off('change input compositionend', onInputChange);
	      sb.$inputEl.off('input:clear', onInputClear);
	    };

	    // Install Modules
	    sb.useModules();

	    // Init
	    sb.init();

	    return sb;
	  }

	  if ( FrameworkClass ) Searchbar.__proto__ = FrameworkClass;
	  Searchbar.prototype = Object.create( FrameworkClass && FrameworkClass.prototype );
	  Searchbar.prototype.constructor = Searchbar;
	  Searchbar.prototype.clear = function clear (e) {
	    var sb = this;
	    if (!sb.query && e && $$1$1(e.target).hasClass('searchbar-clear')) {
	      sb.disable();
	      return sb;
	    }
	    var previousQuery = sb.value;
	    sb.$inputEl.val('').trigger('change').focus();
	    sb.$el.trigger('searchbar:clear', previousQuery);
	    sb.emit('local::clear searchbarClear', sb, previousQuery);
	    return sb;
	  };
	  Searchbar.prototype.setDisableButtonMargin = function setDisableButtonMargin () {
	    var sb = this;
	    if (sb.expandable) { return; }
	    var app = sb.app;
	    sb.$disableButtonEl.transition(0).show();
	    sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), ((-sb.disableButtonEl.offsetWidth) + "px"));
	    /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
	    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
	    sb.$disableButtonEl.transition('');
	    sb.disableButtonHasMargin = true;
	  };
	  Searchbar.prototype.enable = function enable (setFocus) {
	    var sb = this;
	    if (sb.enabled) { return sb; }
	    var app = sb.app;
	    sb.enabled = true;
	    function enable() {
	      if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
	        sb.backdropShow();
	      }
	      sb.$el.addClass('searchbar-enabled');
	      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme === 'ios') {
	        if (!sb.disableButtonHasMargin) {
	          sb.setDisableButtonMargin();
	        }
	        sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), '0px');
	      }
	      if (sb.$hideOnEnableEl) { sb.$hideOnEnableEl.hide(); }
	      sb.$el.trigger('searchbar:enable');
	      sb.emit('local::enable searchbarEnable', sb);
	    }
	    var needsFocus = false;
	    if (setFocus === true) {
	      if (document.activeElement !== sb.inputEl) {
	        needsFocus = true;
	      }
	    }
	    var isIos = app.device.ios && app.theme === 'ios';
	    if (isIos) {
	      if (sb.expandable) {
	        if (needsFocus) { sb.$inputEl.focus(); }
	        enable();
	      } else {
	        if (needsFocus) { sb.$inputEl.focus(); }
	        if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
	          Utils.nextTick(function () {
	            enable();
	          }, 400);
	        } else {
	          enable();
	        }
	      }
	    } else {
	      if (needsFocus) { sb.$inputEl.focus(); }
	      if (app.theme === 'md' && sb.expandable) {
	        sb.$el.parents('.navbar-inner').scrollLeft(0);
	      }
	      enable();
	    }
	    return sb;
	  };
	  Searchbar.prototype.disable = function disable () {
	    var sb = this;
	    if (!sb.enabled) { return sb; }
	    var app = sb.app;
	    sb.$inputEl.val('').trigger('change');
	    sb.$el.removeClass('searchbar-enabled');
	    sb.$el.removeClass('searchbar-focused');
	    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme === 'ios') {
	      sb.$disableButtonEl.css(("margin-" + (app.rtl ? 'left' : 'right')), ((-sb.disableButtonEl.offsetWidth) + "px"));
	    }

	    if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch)) {
	      sb.backdropHide();
	    }

	    sb.enabled = false;

	    sb.$inputEl.blur();

	    if (sb.$hideOnEnableEl) { sb.$hideOnEnableEl.show(); }

	    sb.$el.trigger('searchbar:disable');
	    sb.emit('local::disable searchbarDisable', sb);
	    return sb;
	  };
	  Searchbar.prototype.toggle = function toggle () {
	    var sb = this;
	    if (sb.enabled) { sb.disable(); }
	    else { sb.enable(true); }
	    return sb;
	  };
	  Searchbar.prototype.backdropShow = function backdropShow () {
	    var sb = this;
	    if (sb.$backdropEl) {
	      sb.$backdropEl.addClass('searchbar-backdrop-in');
	    }
	    return sb;
	  };
	  Searchbar.prototype.backdropHide = function backdropHide () {
	    var sb = this;
	    if (sb.$backdropEl) {
	      sb.$backdropEl.removeClass('searchbar-backdrop-in');
	    }
	    return sb;
	  };
	  Searchbar.prototype.search = function search (query, internal) {
	    var sb = this;
	    if (sb.previousQuery && query.trim() === sb.previousQuery) { return sb; }
	    if (typeof (sb.previousQuery) !== 'undefined' && sb.previousQuery.trim() === '' && query.trim() === '') { return sb; }
	    sb.previousQuery = query.trim();

	    if (!internal) {
	      if (!sb.enabled) {
	        sb.enable();
	      }
	      sb.$inputEl.val(query);
	    }
	    sb.query = query;
	    sb.value = query;

	    var $searchContainer = sb.$searchContainer;
	    var $el = sb.$el;
	    var $backdropEl = sb.$backdropEl;
	    var $foundEl = sb.$foundEl;
	    var $notFoundEl = sb.$notFoundEl;
	    var $hideOnSearchEl = sb.$hideOnSearchEl;
	    var isVirtualList = sb.isVirtualList;

	    // Hide on search element
	    if (query.length > 0 && $hideOnSearchEl) {
	      $hideOnSearchEl.hide();
	    } else if ($hideOnSearchEl) {
	      $hideOnSearchEl.show();
	    }
	    // Add active/inactive classes on overlay
	    if (query.length === 0) {
	      if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled') && $backdropEl) { sb.backdropShow(); }
	    } else if ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled')) {
	      sb.backdropHide();
	    }

	    if (sb.params.customSearch) {
	      $el.trigger('searchbar:search', query, sb.previousQuery);
	      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
	      return sb;
	    }

	    var foundItems = [];
	    var vlQuery;
	    if (isVirtualList) {
	      sb.virtualList = $searchContainer[0].f7VirtualList;
	      if (query.trim() === '') {
	        sb.virtualList.resetFilter();
	        if ($notFoundEl) { $notFoundEl.hide(); }
	        if ($foundEl) { $foundEl.show(); }
	        return sb;
	      }
	      vlQuery = sb.params.removeDiacritics ? Utils.removeDiacritics(query) : query;
	      if (sb.virtualList.params.searchAll) {
	        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
	      } else if (sb.virtualList.params.searchByItem) {
	        for (var i = 0; i < sb.virtualList.items.length; i += 1) {
	          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
	            foundItems.push(i);
	          }
	        }
	      }
	    } else {
	      var values;
	      if (sb.params.removeDiacritics) { values = Utils.removeDiacritics(query.trim().toLowerCase()).split(' '); }
	      else {
	        values = query.trim().toLowerCase().split(' ');
	      }
	      $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each(function (itemIndex, itemEl) {
	        var $itemEl = $$1$1(itemEl);
	        var compareWithText = [];
	        var $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
	        if (sb.params.searchIn === sb.params.searchItem) {
	          $searchIn = $itemEl;
	        }
	        $searchIn.each(function (searchInIndex, searchInEl) {
	          var itemText = $$1$1(searchInEl).text().trim().toLowerCase();
	          if (sb.params.removeDiacritics) { itemText = Utils.removeDiacritics(itemText); }
	          compareWithText.push(itemText);
	        });
	        compareWithText = compareWithText.join(' ');
	        var wordsMatch = 0;
	        for (var i = 0; i < values.length; i += 1) {
	          if (compareWithText.indexOf(values[i]) >= 0) { wordsMatch += 1; }
	        }
	        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
	          $itemEl.addClass('hidden-by-searchbar');
	        } else {
	          foundItems.push($itemEl[0]);
	        }
	      });

	      if (sb.params.hideDividers) {
	        $searchContainer.find('.item-divider, .list-group-title').each(function (titleIndex, titleEl) {
	          var $titleEl = $$1$1(titleEl);
	          var $nextElements = $titleEl.nextAll('li');
	          var hide = true;
	          for (var i = 0; i < $nextElements.length; i += 1) {
	            var $nextEl = $nextElements.eq(i);
	            if ($nextEl.hasClass('list-group-title') || $nextEl.hasClass('item-divider')) { break; }
	            if (!$nextEl.hasClass('hidden-by-searchbar')) {
	              hide = false;
	            }
	          }
	          var ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
	          if (hide && !ignore) { $titleEl.addClass('hidden-by-searchbar'); }
	          else { $titleEl.removeClass('hidden-by-searchbar'); }
	        });
	      }
	      if (sb.params.hideGroups) {
	        $searchContainer.find('.list-group').each(function (groupIndex, groupEl) {
	          var $groupEl = $$1$1(groupEl);
	          var ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
	          var notHidden = $groupEl.find('li:not(.hidden-by-searchbar)');
	          if (notHidden.length === 0 && !ignore) {
	            $groupEl.addClass('hidden-by-searchbar');
	          } else {
	            $groupEl.removeClass('hidden-by-searchbar');
	          }
	        });
	      }
	    }

	    if (foundItems.length === 0) {
	      if ($notFoundEl) { $notFoundEl.show(); }
	      if ($foundEl) { $foundEl.hide(); }
	    } else {
	      if ($notFoundEl) { $notFoundEl.hide(); }
	      if ($foundEl) { $foundEl.show(); }
	    }
	    if (isVirtualList && sb.virtualList) {
	      sb.virtualList.filterItems(foundItems);
	    }

	    $el.trigger('searchbar:search', query, sb.previousQuery, foundItems);
	    sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);

	    return sb;
	  };
	  Searchbar.prototype.init = function init () {
	    var sb = this;
	    sb.attachEvents();
	  };
	  Searchbar.prototype.destroy = function destroy () {
	    var sb = this;
	    sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
	    sb.$el.trigger('searchbar:beforedestroy', sb);
	    sb.detachEvents();
	    delete sb.$el.f7Searchbar;
	    Utils.deleteProps(sb);
	  };

	  return Searchbar;
	}(Framework7Class));

	var Searchbar = {
	  name: 'searchbar',
	  static: {
	    Searchbar: Searchbar$1,
	  },
	  create: function create() {
	    var app = this;
	    app.searchbar = ConstructorMethods({
	      defaultSelector: '.searchbar',
	      constructor: Searchbar$1,
	      app: app,
	      domProp: 'f7Searchbar',
	      addMethods: 'clear enable disable toggle search'.split(' '),
	    });
	  },
	  on: {
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.searchbar-init').each(function (index, searchbarEl) {
	        var $searchbarEl = $$1$1(searchbarEl);
	        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	      });
	    },
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      $$1$1(tabEl).find('.searchbar-init').each(function (index, searchbarEl) {
	        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	          searchbarEl.f7Searchbar.destroy();
	        }
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.searchbar-init').each(function (index, searchbarEl) {
	        var $searchbarEl = $$1$1(searchbarEl);
	        app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.searchbar-init').each(function (index, searchbarEl) {
	          var $searchbarEl = $$1$1(searchbarEl);
	          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
	        });
	      }
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.searchbar-init').each(function (index, searchbarEl) {
	        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	          searchbarEl.f7Searchbar.destroy();
	        }
	      });
	      if (app.theme === 'ios' && page.view && page.view.router.separateNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
	        page.$navbarEl.find('.searchbar-init').each(function (index, searchbarEl) {
	          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
	            searchbarEl.f7Searchbar.destroy();
	          }
	        });
	      }
	    },
	  },
	  clicks: {
	    '.searchbar-clear': function clear($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.clear(); }
	    },
	    '.searchbar-enable': function enable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.enable(true); }
	    },
	    '.searchbar-disable': function disable($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.disable(); }
	    },
	    '.searchbar-toggle': function toggle($clickedEl, data) {
	      if ( data === void 0 ) data = {};

	      var app = this;
	      var sb = app.searchbar.get(data.searchbar);
	      if (sb) { sb.toggle(); }
	    },
	  },
	};

	var Messages$1 = (function (Framework7Class$$1) {
	  function Messages(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);

	    var m = this;

	    var defaults = {
	      autoLayout: true,
	      messages: [],
	      newMessagesFirst: false,
	      scrollMessages: true,
	      scrollMessagesOnEdge: true,
	      firstMessageRule: undefined,
	      lastMessageRule: undefined,
	      tailMessageRule: undefined,
	      sameNameMessageRule: undefined,
	      sameHeaderMessageRule: undefined,
	      sameFooterMessageRule: undefined,
	      sameAvatarMessageRule: undefined,
	      customClassMessageRule: undefined,
	      renderMessage: undefined,
	    };

	    // Extend defaults with modules params
	    m.useModulesParams(defaults);

	    m.params = Utils.extend(defaults, params);

	    var $el = $$1$1(params.el).eq(0);
	    if ($el.length === 0) { return m; }

	    $el[0].f7Messages = m;

	    var $pageContentEl = $el.closest('.page-content').eq(0);

	    Utils.extend(m, {
	      messages: m.params.messages,
	      $el: $el,
	      el: $el[0],
	      $pageContentEl: $pageContentEl,
	      pageContentEl: $pageContentEl[0],

	    });
	    // Install Modules
	    m.useModules();

	    // Init
	    m.init();

	    return m;
	  }

	  if ( Framework7Class$$1 ) Messages.__proto__ = Framework7Class$$1;
	  Messages.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Messages.prototype.constructor = Messages;
	  // eslint-disable-next-line
	  Messages.prototype.getMessageData = function getMessageData (messageEl) {
	    var $messageEl = $$1$1(messageEl);
	    var data = {
	      name: $messageEl.find('.message-name').html(),
	      header: $messageEl.find('.message-header').html(),
	      textHeader: $messageEl.find('.message-text-header').html(),
	      textFooter: $messageEl.find('.message-text-footer').html(),
	      footer: $messageEl.find('.message-footer').html(),
	      isTitle: $messageEl.hasClass('messages-title'),
	      type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
	      text: $messageEl.find('.message-text').html(),
	      image: $messageEl.find('.message-image').html(),
	      imageSrc: $messageEl.find('.message-image img').attr('src'),
	      typing: $messageEl.hasClass('message-typing'),
	    };
	    if (data.isTitle) {
	      data.text = $messageEl.html();
	    }
	    if (data.text && data.textHeader) {
	      data.text = data.text.replace(("<div class=\"message-text-header\">" + (data.textHeader) + "</div>"), '');
	    }
	    if (data.text && data.textFooter) {
	      data.text = data.text.replace(("<div class=\"message-text-footer\">" + (data.textFooter) + "</div>"), '');
	    }
	    var avatar = $messageEl.find('.message-avatar').css('background-image');
	    if (avatar === 'none' || avatar === '') { avatar = undefined; }
	    if (avatar && typeof avatar === 'string') {
	      avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
	    } else {
	      avatar = undefined;
	    }
	    data.avatar = avatar;

	    return data;
	  };
	  Messages.prototype.getMessagesData = function getMessagesData () {
	    var m = this;
	    var data = [];
	    m.$el.find('.message, .messages-title').each(function (index, messageEl) {
	      data.push(m.getMessageData(messageEl));
	    });
	    return data;
	  };
	  Messages.prototype.renderMessage = function renderMessage (messageToRender) {
	    var m = this;
	    var message = Utils.extend({
	      type: 'sent',
	    }, messageToRender);
	    if (m.params.renderMessage) {
	      return m.params.renderMessage.call(m, message);
	    }
	    if (message.isTitle) {
	      return ("<div class=\"messages-title\">" + (message.text) + "</div>");
	    }
	    return ("\n      <div class=\"message message-" + (message.type) + " " + (message.isTyping ? 'message-typing' : '') + "\">\n        " + (message.avatar ? ("\n        <div class=\"message-avatar\" style=\"background-image:url(" + (message.avatar) + ")\"></div>\n        ") : '') + "\n        <div class=\"message-content\">\n          " + (message.name ? ("<div class=\"message-name\">" + (message.name) + "</div>") : '') + "\n          " + (message.header ? ("<div class=\"message-header\">" + (message.header) + "</div>") : '') + "\n          <div class=\"message-bubble\">\n            " + (message.textHeader ? ("<div class=\"message-text-header\">" + (message.textHeader) + "</div>") : '') + "\n            " + (message.image ? ("<div class=\"message-image\">" + (message.image) + "</div>") : '') + "\n            " + (message.imageSrc && !message.image ? ("<div class=\"message-image\"><img src=\"" + (message.imageSrc) + "\"></div>") : '') + "\n            " + (message.text || message.isTyping ? ("<div class=\"message-text\">" + (message.text || '') + (message.isTyping ? '<div class="message-typing-indicator"><div></div><div></div><div></div></div>' : '') + "</div>") : '') + "\n            " + (message.textFooter ? ("<div class=\"message-text-footer\">" + (message.textFooter) + "</div>") : '') + "\n          </div>\n          " + (message.footer ? ("<div class=\"message-footer\">" + (message.footer) + "</div>") : '') + "\n        </div>\n      </div>\n    ");
	  };
	  Messages.prototype.renderMessages = function renderMessages (messagesToRender, method) {
	    if ( messagesToRender === void 0 ) messagesToRender = this.messages;
	    if ( method === void 0 ) method = this.params.newMessagesFirst ? 'prepend' : 'append';

	    var m = this;
	    var html = messagesToRender.map(function (message) { return m.renderMessage(message); }).join('');
	    m.$el[method](html);
	  };
	  Messages.prototype.isFirstMessage = function isFirstMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.firstMessageRule) { return (ref = m.params).firstMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isLastMessage = function isLastMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.lastMessageRule) { return (ref = m.params).lastMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isTailMessage = function isTailMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.tailMessageRule) { return (ref = m.params).tailMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isSameNameMessage = function isSameNameMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.sameNameMessageRule) { return (ref = m.params).sameNameMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isSameHeaderMessage = function isSameHeaderMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.sameHeaderMessageRule) { return (ref = m.params).sameHeaderMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isSameFooterMessage = function isSameFooterMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.sameFooterMessageRule) { return (ref = m.params).sameFooterMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isSameAvatarMessage = function isSameAvatarMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.sameAvatarMessageRule) { return (ref = m.params).sameAvatarMessageRule.apply(ref, args); }
	    return false;
	    var ref;
	  };
	  Messages.prototype.isCustomClassMessage = function isCustomClassMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    if (m.params.customClassMessageRule) { return (ref = m.params).customClassMessageRule.apply(ref, args); }
	    return undefined;
	    var ref;
	  };
	  Messages.prototype.layout = function layout () {
	    var m = this;
	    m.$el.find('.message, .messages-title').each(function (index, messageEl) {
	      var $messageEl = $$1$1(messageEl);
	      if (!m.messages) {
	        m.messages = m.getMessagesData();
	      }
	      var classes = [];
	      var message = m.messages[index];
	      var previousMessage = m.messages[index - 1];
	      var nextMessage = m.messages[index + 1];
	      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-first');
	      }
	      if (m.isLastMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-last');
	      }
	      if (m.isTailMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-tail');
	      }
	      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-name');
	      }
	      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-header');
	      }
	      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-footer');
	      }
	      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
	        classes.push('message-same-avatar');
	      }
	      var customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
	      if (customMessageClasses && customMessageClasses.length) {
	        if (typeof customMessageClasses === 'string') {
	          customMessageClasses = customMessageClasses.split(' ');
	        }
	        customMessageClasses.forEach(function (customClass) {
	          classes.push(customClass);
	        });
	      }
	      $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
	      classes.forEach(function (className) {
	        $messageEl.addClass(className);
	      });
	    });
	  };
	  Messages.prototype.clear = function clear () {
	    var m = this;
	    m.messages = [];
	    m.$el.html('');
	  };
	  Messages.prototype.removeMessage = function removeMessage (messageToRemove, layout) {
	    if ( layout === void 0 ) layout = true;

	    var m = this;
	    // Index or El
	    var index;
	    var $el;
	    if (typeof messageToRemove === 'number') {
	      index = messageToRemove;
	      $el = m.$el.find('.message, .messages-title').eq(index);
	    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
	      index = m.messages.indexOf(messageToRemove);
	      $el = m.$el.children().eq(index);
	    } else {
	      $el = $$1$1(messageToRemove);
	      index = $el.index();
	    }
	    if ($el.length === 0) {
	      return m;
	    }
	    $el.remove();
	    m.messages.splice(index, 1);
	    if (m.params.autoLayout && layout) { m.layout(); }
	    return m;
	  };
	  Messages.prototype.removeMessages = function removeMessages (messagesToRemove, layout) {
	    if ( layout === void 0 ) layout = true;

	    var m = this;
	    if (Array.isArray(messagesToRemove)) {
	      var messagesToRemoveEls = [];
	      messagesToRemove.forEach(function (messageToRemoveIndex) {
	        messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
	      });
	      messagesToRemoveEls.forEach(function (messageToRemove) {
	        m.removeMessage(messageToRemove, false);
	      });
	    } else {
	      $$1$1(messagesToRemove).each(function (index, messageToRemove) {
	        m.removeMessage(messageToRemove, false);
	      });
	    }
	    if (m.params.autoLayout && layout) { m.layout(); }
	    return m;
	  };

	  Messages.prototype.addMessage = function addMessage () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    var messageToAdd;
	    var animate;
	    var method;
	    if (typeof args[1] === 'boolean') {
	      var assign;
	      (assign = args, messageToAdd = assign[0], animate = assign[1], method = assign[2]);
	    } else {
	      var assign$1;
	      (assign$1 = args, messageToAdd = assign$1[0], method = assign$1[1], animate = assign$1[2]);
	    }
	    if (typeof animate === 'undefined') {
	      animate = true;
	    }
	    if (typeof method === 'undefined') {
	      method = m.params.newMessagesFirst ? 'prepend' : 'append';
	    }

	    return m.addMessages([messageToAdd], animate, method);
	  };
	  Messages.prototype.addMessages = function addMessages () {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var m = this;
	    var messagesToAdd;
	    var animate;
	    var method;
	    if (typeof args[1] === 'boolean') {
	      var assign;
	      (assign = args, messagesToAdd = assign[0], animate = assign[1], method = assign[2]);
	    } else {
	      var assign$1;
	      (assign$1 = args, messagesToAdd = assign$1[0], method = assign$1[1], animate = assign$1[2]);
	    }
	    if (typeof animate === 'undefined') {
	      animate = true;
	    }
	    if (typeof method === 'undefined') {
	      method = m.params.newMessagesFirst ? 'prepend' : 'append';
	    }

	    // Define scroll positions before new messages added
	    var scrollHeightBefore = m.pageContentEl.scrollHeight;
	    var heightBefore = m.pageContentEl.offsetHeight;
	    var scrollBefore = m.pageContentEl.scrollTop;

	    // Add message to DOM and data
	    var messagesHTML = '';
	    var typingMessage = m.messages.filter(function (el) { return el.isTyping; })[0];
	    messagesToAdd.forEach(function (messageToAdd) {
	      if (typingMessage) {
	        if (method === 'append') {
	          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
	        } else {
	          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
	        }
	      } else {
	        m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
	      }
	      messagesHTML += m.renderMessage(messageToAdd);
	    });
	    var $messagesEls = $$1$1(messagesHTML);
	    if (animate) {
	      if (method === 'append' && !m.params.newMessagesFirst) {
	        $messagesEls.addClass('message-appear-from-bottom');
	      }
	      if (method === 'prepend' && m.params.newMessagesFirst) {
	        $messagesEls.addClass('message-appear-from-top');
	      }
	    }
	    if (typingMessage) {
	      if (method === 'append') {
	        $messagesEls.insertBefore(m.$el.find('.message-typing'));
	      } else {
	        $messagesEls.insertAfter(m.$el.find('.message-typing'));
	      }
	    } else {
	      m.$el[method]($messagesEls);
	    }

	    // Layout
	    if (m.params.autoLayout) { m.layout(); }

	    if (method === 'prepend' && !typingMessage) {
	      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
	    }

	    if (m.params.scrollMessages && ((method === 'append' && !m.params.newMessagesFirst) || (method === 'prepend' && m.params.newMessagesFirst && !typingMessage))) {
	      if (m.params.scrollMessagesOnEdge) {
	        var onEdge = false;
	        if (m.params.newMessagesFirst && scrollBefore === 0) {
	          onEdge = true;
	        }
	        if (!m.params.newMessagesFirst && (scrollBefore - (scrollHeightBefore - heightBefore) >= -10)) {
	          onEdge = true;
	        }
	        if (onEdge) { m.scroll(animate ? undefined : 0); }
	      } else {
	        m.scroll(animate ? undefined : 0);
	      }
	    }

	    return m;
	  };
	  Messages.prototype.showTyping = function showTyping (message) {
	    if ( message === void 0 ) message = {};

	    var m = this;
	    var typingMessage = m.messages.filter(function (el) { return el.isTyping; })[0];
	    if (typingMessage) {
	      m.removeMessage(m.messages.indexOf(typingMessage));
	    }
	    m.addMessage(Utils.extend({
	      type: 'received',
	      isTyping: true,
	    }, message));
	    return m;
	  };
	  Messages.prototype.hideTyping = function hideTyping () {
	    var m = this;
	    var typingMessageIndex;
	    var typingFound;
	    m.messages.forEach(function (message, index) {
	      if (message.isTyping) { typingMessageIndex = index; }
	    });
	    if (typeof typingMessageIndex !== 'undefined') {
	      if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
	        typingFound = true;
	        m.removeMessage(typingMessageIndex);
	      }
	    }
	    if (!typingFound) {
	      var $typingMessageEl = m.$el.find('.message-typing');
	      if ($typingMessageEl.length) {
	        m.removeMessage($typingMessageEl);
	      }
	    }
	    return m;
	  };
	  Messages.prototype.scroll = function scroll (duration, scrollTop) {
	    if ( duration === void 0 ) duration = 300;

	    var m = this;
	    var currentScroll = m.pageContentEl.scrollTop;
	    var newScrollTop;
	    if (typeof scrollTop !== 'undefined') { newScrollTop = scrollTop; }
	    else {
	      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
	      if (newScrollTop === currentScroll) { return m; }
	    }
	    m.$pageContentEl.scrollTop(newScrollTop, duration);
	    return m;
	  };
	  Messages.prototype.init = function init () {
	    var m = this;
	    if (!m.messages || m.messages.length === 0) {
	      m.messages = m.getMessagesData();
	    }
	    if (m.params.messages && m.params.messages.length) {
	      m.renderMessages();
	    }
	    if (m.params.autoLayout) { m.layout(); }
	    if (m.params.scrollMessages) { m.scroll(0); }
	  };
	  Messages.prototype.destroy = function destroy () {
	    var m = this;
	    m.emit('local::beforeDestroy messagesBeforeDestroy', m);
	    m.$el.trigger('messages:beforedestroy', m);
	    m.$el[0].f7Messages = null;
	    delete m.$el[0].f7Messages;
	    Utils.deleteProps(m);
	  };

	  return Messages;
	}(Framework7Class));

	var Messages = {
	  name: 'messages',
	  static: {
	    Messages: Messages$1,
	  },
	  create: function create() {
	    var app = this;
	    app.messages = ConstructorMethods({
	      defaultSelector: '.messages',
	      constructor: Messages$1,
	      app: app,
	      domProp: 'f7Messages',
	      addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' '),
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.messages-init').each(function (index, messagesEl) {
	        app.messages.destroy(messagesEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.messages-init').each(function (index, messagesEl) {
	        app.messages.create({ el: messagesEl });
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.messages-init').each(function (index, messagesEl) {
	        app.messages.destroy(messagesEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.messages-init').each(function (index, messagesEl) {
	        app.messages.create({ el: messagesEl });
	      });
	    },
	  },
	  clicks: {

	  },
	};

	var Messagebar$1 = (function (Framework7Class$$1) {
	  function Messagebar(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);

	    var messagebar = this;

	    var defaults = {
	      top: false,
	      topOffset: 0,
	      bottomOffset: 0,
	      attachments: [],
	      renderAttachments: undefined,
	      renderAttachment: undefined,
	      maxHeight: null,
	      resizePage: true,
	    };

	    // Extend defaults with modules params
	    messagebar.useModulesParams(defaults);

	    messagebar.params = Utils.extend(defaults, params);

	    // El
	    var $el = $$1$1(messagebar.params.el);
	    if ($el.length === 0) { return messagebar; }

	    $el[0].f7Messagebar = messagebar;

	    // Page and PageContent
	    var $pageEl = $el.parents('.page').eq(0);
	    var $pageContentEl = $pageEl.find('.page-content').eq(0);

	    // Area
	    var $areaEl = $el.find('.messagebar-area');

	    // Textarea
	    var $textareaEl;
	    if (messagebar.params.textareaEl) {
	      $textareaEl = $$1$1(messagebar.params.textareaEl);
	    } else {
	      $textareaEl = $el.find('textarea');
	    }

	    // Attachments & Library
	    var $attachmentsEl = $el.find('.messagebar-attachments');
	    var $sheetEl = $el.find('.messagebar-sheet');

	    if (messagebar.params.top) {
	      $el.addClass('messagebar-top');
	    }

	    Utils.extend(messagebar, {
	      $el: $el,
	      el: $el[0],
	      $areaEl: $areaEl,
	      areaEl: $areaEl[0],
	      $textareaEl: $textareaEl,
	      textareaEl: $textareaEl[0],
	      $attachmentsEl: $attachmentsEl,
	      attachmentsEl: $attachmentsEl[0],
	      attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
	      $sheetEl: $sheetEl,
	      sheetEl: $sheetEl[0],
	      sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
	      $pageEl: $pageEl,
	      pageEl: $pageEl[0],
	      $pageContentEl: $pageContentEl,
	      pageContentEl: $pageContentEl,
	      top: $el.hasClass('messagebar-top') || messagebar.params.top,
	      attachments: [],
	    });

	    // Events
	    function onAppResize() {
	      if (messagebar.params.resizePage) {
	        messagebar.resizePage();
	      }
	    }
	    function onSubmit(e) {
	      e.preventDefault();
	    }
	    function onAttachmentClick(e) {
	      var index = $$1$1(this).index();
	      if ($$1$1(e.target).closest('.messagebar-attachment-delete').length) {
	        $$1$1(this).trigger('messagebar:attachmentdelete', index);
	        messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
	      } else {
	        $$1$1(this).trigger('messagebar:attachmentclick', index);
	        messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
	      }
	    }
	    function onTextareaChange() {
	      messagebar.checkEmptyState();
	      messagebar.$el.trigger('messagebar:change');
	      messagebar.emit('local::change messagebarChange', messagebar);
	    }
	    function onTextareaFocus() {
	      messagebar.sheetHide();
	      messagebar.$el.trigger('messagebar:focus');
	      messagebar.emit('local::focus messagebarFocus', messagebar);
	    }
	    function onTextareaBlur() {
	      messagebar.$el.trigger('messagebar:blur');
	      messagebar.emit('local::blur messagebarBlur', messagebar);
	    }

	    messagebar.attachEvents = function attachEvents() {
	      $el.on('textarea:resize', onAppResize);
	      $el.on('submit', onSubmit);
	      $el.on('click', '.messagebar-attachment', onAttachmentClick);
	      $textareaEl.on('change input', onTextareaChange);
	      $textareaEl.on('focus', onTextareaFocus);
	      $textareaEl.on('blur', onTextareaBlur);
	      app.on('resize', onAppResize);
	    };
	    messagebar.detachEvents = function detachEvents() {
	      $el.off('textarea:resize', onAppResize);
	      $el.off('submit', onSubmit);
	      $el.off('click', '.messagebar-attachment', onAttachmentClick);
	      $textareaEl.off('change input', onTextareaChange);
	      $textareaEl.off('focus', onTextareaFocus);
	      $textareaEl.off('blur', onTextareaBlur);
	      app.off('resize', onAppResize);
	    };


	    // Install Modules
	    messagebar.useModules();

	    // Init
	    messagebar.init();

	    return messagebar;
	  }

	  if ( Framework7Class$$1 ) Messagebar.__proto__ = Framework7Class$$1;
	  Messagebar.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Messagebar.prototype.constructor = Messagebar;
	  Messagebar.prototype.focus = function focus () {
	    var messagebar = this;
	    messagebar.$textareaEl.focus();
	    return messagebar;
	  };
	  Messagebar.prototype.blur = function blur () {
	    var messagebar = this;
	    messagebar.$textareaEl.blur();
	    return messagebar;
	  };
	  Messagebar.prototype.clear = function clear () {
	    var messagebar = this;
	    messagebar.$textareaEl.val('').trigger('change');
	    return messagebar;
	  };
	  Messagebar.prototype.getValue = function getValue () {
	    var messagebar = this;
	    return messagebar.$textareaEl.val().trim();
	  };
	  Messagebar.prototype.setValue = function setValue (value) {
	    var messagebar = this;
	    messagebar.$textareaEl.val(value).trigger('change');
	    return messagebar;
	  };
	  Messagebar.prototype.setPlaceholder = function setPlaceholder (placeholder) {
	    var messagebar = this;
	    messagebar.$textareaEl.attr('placeholder', placeholder);
	    return messagebar;
	  };
	  Messagebar.prototype.resizePage = function resizePage () {
	    var messagebar = this;
	    var params = messagebar.params;
	    var $el = messagebar.$el;
	    var top = messagebar.top;
	    var $pageEl = messagebar.$pageEl;
	    var $pageContentEl = messagebar.$pageContentEl;
	    var $areaEl = messagebar.$areaEl;
	    var $textareaEl = messagebar.$textareaEl;
	    var $sheetEl = messagebar.$sheetEl;
	    var $attachmentsEl = messagebar.$attachmentsEl;
	    var elHeight = $el[0].offsetHeight;
	    var maxHeight = params.maxHeight;
	    if (top) {
	      /*
	      Disable at the moment
	      const requiredPaddingTop = elHeight + params.topOffset;
	      const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	      if (requiredPaddingTop !== currentPaddingTop) {
	        if (!maxHeight) {
	          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
	        }
	        $textareaEl.css('max-height', `${maxHeight}px`);
	        $pageContentEl.css('padding-top', `${requiredPaddingTop}px`);
	        $el.trigger('messagebar:resizePage');
	        messagebar.emit('local::resizepage messagebarResizePage');
	      }
	      */
	    } else {
	      var currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
	      var requiredPaddingBottom = elHeight + params.bottomOffset;
	      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
	        var currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
	        var pageScrollHeight = $pageContentEl[0].scrollHeight;
	        var pageOffsetHeight = $pageContentEl[0].offsetHeight;
	        var pageScrollTop = $pageContentEl[0].scrollTop;
	        var scrollOnBottom = (pageScrollTop === pageScrollHeight - pageOffsetHeight);
	        if (!maxHeight) {
	          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
	        }
	        $textareaEl.css('max-height', (maxHeight + "px"));
	        $pageContentEl.css('padding-bottom', (requiredPaddingBottom + "px"));
	        if (scrollOnBottom) {
	          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
	        }
	        $el.trigger('messagebar:resizepage');
	        messagebar.emit('local::resizePage messagebarResizePage', messagebar);
	      }
	    }
	  };
	  Messagebar.prototype.checkEmptyState = function checkEmptyState () {
	    var messagebar = this;
	    var $el = messagebar.$el;
	    var $textareaEl = messagebar.$textareaEl;
	    var value = $textareaEl.val().trim();
	    if (value && value.length) {
	      $el.addClass('messagebar-with-value');
	    } else {
	      $el.removeClass('messagebar-with-value');
	    }
	  };
	  Messagebar.prototype.attachmentsCreate = function attachmentsCreate (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    var $attachmentsEl = $$1$1(("<div class=\"messagebar-attachments\">" + innerHTML + "</div>"));
	    $attachmentsEl.insertBefore(messagebar.$textareaEl);
	    Utils.extend(messagebar, {
	      $attachmentsEl: $attachmentsEl,
	      attachmentsEl: $attachmentsEl[0],
	    });
	    return messagebar;
	  };
	  Messagebar.prototype.attachmentsShow = function attachmentsShow (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');
	    if (messagebar.$attachmentsEl.length === 0) {
	      messagebar.attachmentsCreate(innerHTML);
	    }
	    messagebar.$el.addClass('messagebar-attachments-visible');
	    messagebar.attachmentsVisible = true;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.attachmentsHide = function attachmentsHide () {
	    var messagebar = this;
	    messagebar.$el.removeClass('messagebar-attachments-visible');
	    messagebar.attachmentsVisible = false;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.attachmentsToggle = function attachmentsToggle () {
	    var messagebar = this;
	    if (messagebar.attachmentsVisible) {
	      messagebar.attachmentsHide();
	    } else {
	      messagebar.attachmentsShow();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.renderAttachment = function renderAttachment (attachment) {
	    var messagebar = this;
	    if (messagebar.params.renderAttachment) {
	      return messagebar.params.renderAttachment.call(messagebar, attachment);
	    }
	    return ("\n      <div class=\"messagebar-attachment\">\n        <img src=\"" + attachment + "\">\n        <span class=\"messagebar-attachment-delete\"></span>\n      </div>\n    ");
	  };
	  Messagebar.prototype.renderAttachments = function renderAttachments () {
	    var messagebar = this;
	    var html;
	    if (messagebar.params.renderAttachments) {
	      html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
	    } else {
	      html = "" + (messagebar.attachments.map(function (attachment) { return messagebar.renderAttachment(attachment); }).join(''));
	    }
	    if (messagebar.$attachmentsEl.length === 0) {
	      messagebar.attachmentsCreate(html);
	    } else {
	      messagebar.$attachmentsEl.html(html);
	    }
	  };
	  Messagebar.prototype.sheetCreate = function sheetCreate (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    var $sheetEl = $$1$1(("<div class=\"messagebar-sheet\">" + innerHTML + "</div>"));
	    messagebar.$el.append($sheetEl);
	    Utils.extend(messagebar, {
	      $sheetEl: $sheetEl,
	      sheetEl: $sheetEl[0],
	    });
	    return messagebar;
	  };
	  Messagebar.prototype.sheetShow = function sheetShow (innerHTML) {
	    if ( innerHTML === void 0 ) innerHTML = '';

	    var messagebar = this;
	    messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');
	    if (messagebar.$sheetEl.length === 0) {
	      messagebar.sheetCreate(innerHTML);
	    }
	    messagebar.$el.addClass('messagebar-sheet-visible');
	    messagebar.sheetVisible = true;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.sheetHide = function sheetHide () {
	    var messagebar = this;
	    messagebar.$el.removeClass('messagebar-sheet-visible');
	    messagebar.sheetVisible = false;
	    if (messagebar.params.resizePage) {
	      messagebar.resizePage();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.sheetToggle = function sheetToggle () {
	    var messagebar = this;
	    if (messagebar.sheetVisible) {
	      messagebar.sheetHide();
	    } else {
	      messagebar.sheetShow();
	    }
	    return messagebar;
	  };
	  Messagebar.prototype.init = function init () {
	    var messagebar = this;
	    messagebar.attachEvents();
	    messagebar.checkEmptyState();
	    return messagebar;
	  };
	  Messagebar.prototype.destroy = function destroy () {
	    var messagebar = this;
	    messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
	    messagebar.$el.trigger('messagebar:beforedestroy', messagebar);
	    messagebar.detachEvents();
	    messagebar.$el[0].f7Messagebar = null;
	    delete messagebar.$el[0].f7Messagebar;
	    Utils.deleteProps(messagebar);
	  };

	  return Messagebar;
	}(Framework7Class));

	var Messagebar = {
	  name: 'messagebar',
	  static: {
	    Messagebar: Messagebar$1,
	  },
	  create: function create() {
	    var app = this;
	    app.messagebar = ConstructorMethods({
	      defaultSelector: '.messagebar',
	      constructor: Messagebar$1,
	      app: app,
	      domProp: 'f7Messagebar',
	      addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' '),
	    });
	  },
	  on: {
	    tabBeforeRemove: function tabBeforeRemove(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.destroy(messagebarEl);
	      });
	    },
	    tabMounted: function tabMounted(tabEl) {
	      var app = this;
	      $$1$1(tabEl).find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.create(Utils.extend({ el: messagebarEl }, $$1$1(messagebarEl).dataset()));
	      });
	    },
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.destroy(messagebarEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.messagebar-init').each(function (index, messagebarEl) {
	        app.messagebar.create(Utils.extend({ el: messagebarEl }, $$1$1(messagebarEl).dataset()));
	      });
	    },
	  },
	};

	var updateSize = function () {
	  var swiper = this;
	  var width;
	  var height;
	  var $el = swiper.$el;
	  if (typeof swiper.params.width !== 'undefined') {
	    width = swiper.params.width;
	  } else {
	    width = $el[0].clientWidth;
	  }
	  if (typeof swiper.params.height !== 'undefined') {
	    height = swiper.params.height;
	  } else {
	    height = $el[0].clientHeight;
	  }
	  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
	    return;
	  }

	  // Subtract paddings
	  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
	  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

	  Utils.extend(swiper, {
	    width: width,
	    height: height,
	    size: swiper.isHorizontal() ? width : height,
	  });
	};

	var updateSlides = function () {
	  var swiper = this;
	  var params = swiper.params;

	  var $wrapperEl = swiper.$wrapperEl;
	  var swiperSize = swiper.size;
	  var rtl = swiper.rtl;
	  var wrongRTL = swiper.wrongRTL;
	  var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));
	  var isVirtual = swiper.virtual && params.virtual.enabled;
	  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
	  var snapGrid = [];
	  var slidesGrid = [];
	  var slidesSizesGrid = [];

	  var offsetBefore = params.slidesOffsetBefore;
	  if (typeof offsetBefore === 'function') {
	    offsetBefore = params.slidesOffsetBefore.call(swiper);
	  }

	  var offsetAfter = params.slidesOffsetAfter;
	  if (typeof offsetAfter === 'function') {
	    offsetAfter = params.slidesOffsetAfter.call(swiper);
	  }

	  var previousSlidesLength = slidesLength;
	  var previousSnapGridLength = swiper.snapGrid.length;
	  var previousSlidesGridLength = swiper.snapGrid.length;

	  var spaceBetween = params.spaceBetween;
	  var slidePosition = -offsetBefore;
	  var prevSlideSize = 0;
	  var index = 0;
	  if (typeof swiperSize === 'undefined') {
	    return;
	  }
	  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
	  }

	  swiper.virtualSize = -spaceBetween;

	  // reset margins
	  if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }
	  else { slides.css({ marginRight: '', marginBottom: '' }); }

	  var slidesNumberEvenToRows;
	  if (params.slidesPerColumn > 1) {
	    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
	      slidesNumberEvenToRows = slidesLength;
	    } else {
	      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
	    }
	    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
	      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
	    }
	  }

	  // Calc slides
	  var slideSize;
	  var slidesPerColumn = params.slidesPerColumn;
	  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	  var numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);
	  for (var i = 0; i < slidesLength; i += 1) {
	    slideSize = 0;
	    var slide = slides.eq(i);
	    if (params.slidesPerColumn > 1) {
	      // Set slides order
	      var newSlideOrderIndex = (void 0);
	      var column = (void 0);
	      var row = (void 0);
	      if (params.slidesPerColumnFill === 'column') {
	        column = Math.floor(i / slidesPerColumn);
	        row = i - (column * slidesPerColumn);
	        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
	          row += 1;
	          if (row >= slidesPerColumn) {
	            row = 0;
	            column += 1;
	          }
	        }
	        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
	        slide
	          .css({
	            '-webkit-box-ordinal-group': newSlideOrderIndex,
	            '-moz-box-ordinal-group': newSlideOrderIndex,
	            '-ms-flex-order': newSlideOrderIndex,
	            '-webkit-order': newSlideOrderIndex,
	            order: newSlideOrderIndex,
	          });
	      } else {
	        row = Math.floor(i / slidesPerRow);
	        column = i - (row * slidesPerRow);
	      }
	      slide
	        .css(
	          ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),
	          (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))
	        )
	        .attr('data-swiper-column', column)
	        .attr('data-swiper-row', row);
	    }
	    if (slide.css('display') === 'none') { continue; } // eslint-disable-line
	    if (params.slidesPerView === 'auto') {
	      slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
	      if (params.roundLengths) { slideSize = Math.floor(slideSize); }
	    } else {
	      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
	      if (params.roundLengths) { slideSize = Math.floor(slideSize); }

	      if (slides[i]) {
	        if (swiper.isHorizontal()) {
	          slides[i].style.width = slideSize + "px";
	        } else {
	          slides[i].style.height = slideSize + "px";
	        }
	      }
	    }
	    if (slides[i]) {
	      slides[i].swiperSlideSize = slideSize;
	    }
	    slidesSizesGrid.push(slideSize);


	    if (params.centeredSlides) {
	      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
	      if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	      if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }
	      if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }
	      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	      slidesGrid.push(slidePosition);
	    } else {
	      if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }
	      slidesGrid.push(slidePosition);
	      slidePosition = slidePosition + slideSize + spaceBetween;
	    }

	    swiper.virtualSize += slideSize + spaceBetween;

	    prevSlideSize = slideSize;

	    index += 1;
	  }
	  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
	  var newSlidesGrid;

	  if (
	    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
	    $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });
	  }
	  if (!Support.flexbox || params.setWrapperSize) {
	    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	  }

	  if (params.slidesPerColumn > 1) {
	    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
	    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
	    if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }
	    if (params.centeredSlides) {
	      newSlidesGrid = [];
	      for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
	        if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(snapGrid[i$1]); }
	      }
	      snapGrid = newSlidesGrid;
	    }
	  }

	  // Remove last grid elements depending on width
	  if (!params.centeredSlides) {
	    newSlidesGrid = [];
	    for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
	      if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
	        newSlidesGrid.push(snapGrid[i$2]);
	      }
	    }
	    snapGrid = newSlidesGrid;
	    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
	      snapGrid.push(swiper.virtualSize - swiperSize);
	    }
	  }
	  if (snapGrid.length === 0) { snapGrid = [0]; }

	  if (params.spaceBetween !== 0) {
	    if (swiper.isHorizontal()) {
	      if (rtl) { slides.css({ marginLeft: (spaceBetween + "px") }); }
	      else { slides.css({ marginRight: (spaceBetween + "px") }); }
	    } else { slides.css({ marginBottom: (spaceBetween + "px") }); }
	  }

	  Utils.extend(swiper, {
	    slides: slides,
	    snapGrid: snapGrid,
	    slidesGrid: slidesGrid,
	    slidesSizesGrid: slidesSizesGrid,
	  });

	  if (slidesLength !== previousSlidesLength) {
	    swiper.emit('slidesLengthChange');
	  }
	  if (snapGrid.length !== previousSnapGridLength) {
	    swiper.emit('snapGridLengthChange');
	  }
	  if (slidesGrid.length !== previousSlidesGridLength) {
	    swiper.emit('slidesGridLengthChange');
	  }

	  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateSlidesOffset();
	  }
	};

	var updateAutoHeight = function () {
	  var swiper = this;
	  var activeSlides = [];
	  var newHeight = 0;
	  var i;

	  // Find slides currently in view
	  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
	    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
	      var index = swiper.activeIndex + i;
	      if (index > swiper.slides.length) { break; }
	      activeSlides.push(swiper.slides.eq(index)[0]);
	    }
	  } else {
	    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
	  }

	  // Find new height from highest slide in view
	  for (i = 0; i < activeSlides.length; i += 1) {
	    if (typeof activeSlides[i] !== 'undefined') {
	      var height = activeSlides[i].offsetHeight;
	      newHeight = height > newHeight ? height : newHeight;
	    }
	  }

	  // Update Height
	  if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }
	};

	var updateSlidesOffset = function () {
	  var swiper = this;
	  var slides = swiper.slides;
	  for (var i = 0; i < slides.length; i += 1) {
	    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
	  }
	};

	var updateSlidesProgress = function (translate) {
	  if ( translate === void 0 ) translate = this.translate || 0;

	  var swiper = this;
	  var params = swiper.params;

	  var slides = swiper.slides;
	  var rtl = swiper.rtl;

	  if (slides.length === 0) { return; }
	  if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }

	  var offsetCenter = -translate;
	  if (rtl) { offsetCenter = translate; }

	  // Visible Slides
	  slides.removeClass(params.slideVisibleClass);

	  for (var i = 0; i < slides.length; i += 1) {
	    var slide = slides[i];
	    var slideProgress =
	      (
	        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
	      ) / (slide.swiperSlideSize + params.spaceBetween);
	    if (params.watchSlidesVisibility) {
	      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
	      var isVisible =
	                (slideBefore >= 0 && slideBefore < swiper.size) ||
	                (slideAfter > 0 && slideAfter <= swiper.size) ||
	                (slideBefore <= 0 && slideAfter >= swiper.size);
	      if (isVisible) {
	        slides.eq(i).addClass(params.slideVisibleClass);
	      }
	    }
	    slide.progress = rtl ? -slideProgress : slideProgress;
	  }
	};

	var updateProgress = function (translate) {
	  if ( translate === void 0 ) translate = this.translate || 0;

	  var swiper = this;
	  var params = swiper.params;

	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  var progress = swiper.progress;
	  var isBeginning = swiper.isBeginning;
	  var isEnd = swiper.isEnd;
	  var wasBeginning = isBeginning;
	  var wasEnd = isEnd;
	  if (translatesDiff === 0) {
	    progress = 0;
	    isBeginning = true;
	    isEnd = true;
	  } else {
	    progress = (translate - swiper.minTranslate()) / (translatesDiff);
	    isBeginning = progress <= 0;
	    isEnd = progress >= 1;
	  }
	  Utils.extend(swiper, {
	    progress: progress,
	    isBeginning: isBeginning,
	    isEnd: isEnd,
	  });

	  if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }

	  if (isBeginning && !wasBeginning) {
	    swiper.emit('reachBeginning toEdge');
	  }
	  if (isEnd && !wasEnd) {
	    swiper.emit('reachEnd toEdge');
	  }
	  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
	    swiper.emit('fromEdge');
	  }

	  swiper.emit('progress', progress);
	};

	var updateSlidesClasses = function () {
	  var swiper = this;

	  var slides = swiper.slides;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;
	  var realIndex = swiper.realIndex;
	  var isVirtual = swiper.virtual && params.virtual.enabled;

	  slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));

	  var activeSlide;
	  if (isVirtual) {
	    activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));
	  } else {
	    activeSlide = slides.eq(activeIndex);
	  }

	  // Active classes
	  activeSlide.addClass(params.slideActiveClass);

	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (activeSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))
	        .addClass(params.slideDuplicateActiveClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))
	        .addClass(params.slideDuplicateActiveClass);
	    }
	  }
	  // Next Slide
	  var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);
	  if (params.loop && nextSlide.length === 0) {
	    nextSlide = slides.eq(0);
	    nextSlide.addClass(params.slideNextClass);
	  }
	  // Prev Slide
	  var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);
	  if (params.loop && prevSlide.length === 0) {
	    prevSlide = slides.eq(-1);
	    prevSlide.addClass(params.slidePrevClass);
	  }
	  if (params.loop) {
	    // Duplicate to all looped slides
	    if (nextSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicateNextClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicateNextClass);
	    }
	    if (prevSlide.hasClass(params.slideDuplicateClass)) {
	      $wrapperEl
	        .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicatePrevClass);
	    } else {
	      $wrapperEl
	        .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))
	        .addClass(params.slideDuplicatePrevClass);
	    }
	  }
	};

	var updateActiveIndex = function (newActiveIndex) {
	  var swiper = this;
	  var translate = swiper.rtl ? swiper.translate : -swiper.translate;
	  var slidesGrid = swiper.slidesGrid;
	  var snapGrid = swiper.snapGrid;
	  var params = swiper.params;
	  var previousIndex = swiper.activeIndex;
	  var previousRealIndex = swiper.realIndex;
	  var previousSnapIndex = swiper.snapIndex;
	  var activeIndex = newActiveIndex;
	  var snapIndex;
	  if (typeof activeIndex === 'undefined') {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (typeof slidesGrid[i + 1] !== 'undefined') {
	        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
	          activeIndex = i;
	        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
	          activeIndex = i + 1;
	        }
	      } else if (translate >= slidesGrid[i]) {
	        activeIndex = i;
	      }
	    }
	    // Normalize slideIndex
	    if (params.normalizeSlideIndex) {
	      if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }
	    }
	  }
	  if (snapGrid.indexOf(translate) >= 0) {
	    snapIndex = snapGrid.indexOf(translate);
	  } else {
	    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
	  }
	  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }
	  if (activeIndex === previousIndex) {
	    if (snapIndex !== previousSnapIndex) {
	      swiper.snapIndex = snapIndex;
	      swiper.emit('snapIndexChange');
	    }
	    return;
	  }

	  // Get real index
	  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

	  Utils.extend(swiper, {
	    snapIndex: snapIndex,
	    realIndex: realIndex,
	    previousIndex: previousIndex,
	    activeIndex: activeIndex,
	  });
	  swiper.emit('activeIndexChange');
	  swiper.emit('snapIndexChange');
	  if (previousRealIndex !== realIndex) {
	    swiper.emit('realIndexChange');
	  }
	  swiper.emit('slideChange');
	};

	var updateClickedSlide = function (e) {
	  var swiper = this;
	  var params = swiper.params;
	  var slide = $$1$1(e.target).closest(("." + (params.slideClass)))[0];
	  var slideFound = false;
	  if (slide) {
	    for (var i = 0; i < swiper.slides.length; i += 1) {
	      if (swiper.slides[i] === slide) { slideFound = true; }
	    }
	  }

	  if (slide && slideFound) {
	    swiper.clickedSlide = slide;
	    if (swiper.virtual && swiper.params.virtual.enabled) {
	      swiper.clickedIndex = parseInt($$1$1(slide).attr('data-swiper-slide-index'), 10);
	    } else {
	      swiper.clickedIndex = $$1$1(slide).index();
	    }
	  } else {
	    swiper.clickedSlide = undefined;
	    swiper.clickedIndex = undefined;
	    return;
	  }
	  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
	    swiper.slideToClickedSlide();
	  }
	};

	var update = {
	  updateSize: updateSize,
	  updateSlides: updateSlides,
	  updateAutoHeight: updateAutoHeight,
	  updateSlidesOffset: updateSlidesOffset,
	  updateSlidesProgress: updateSlidesProgress,
	  updateProgress: updateProgress,
	  updateSlidesClasses: updateSlidesClasses,
	  updateActiveIndex: updateActiveIndex,
	  updateClickedSlide: updateClickedSlide,
	};

	var getTranslate = function (axis) {
	  if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';

	  var swiper = this;

	  var params = swiper.params;
	  var rtl = swiper.rtl;
	  var translate = swiper.translate;
	  var $wrapperEl = swiper.$wrapperEl;

	  if (params.virtualTranslate) {
	    return rtl ? -translate : translate;
	  }

	  var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
	  if (rtl) { currentTranslate = -currentTranslate; }

	  return currentTranslate || 0;
	};

	var setTranslate = function (translate, byController) {
	  var swiper = this;
	  var rtl = swiper.rtl;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var progress = swiper.progress;
	  var x = 0;
	  var y = 0;
	  var z = 0;

	  if (swiper.isHorizontal()) {
	    x = rtl ? -translate : translate;
	  } else {
	    y = translate;
	  }

	  if (params.roundLengths) {
	    x = Math.floor(x);
	    y = Math.floor(y);
	  }

	  if (!params.virtualTranslate) {
	    if (Support.transforms3d) { $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)")); }
	    else { $wrapperEl.transform(("translate(" + x + "px, " + y + "px)")); }
	  }

	  swiper.translate = swiper.isHorizontal() ? x : y;

	  // Check if we need to update progress
	  var newProgress;
	  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
	  if (translatesDiff === 0) {
	    newProgress = 0;
	  } else {
	    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
	  }
	  if (newProgress !== progress) {
	    swiper.updateProgress(translate);
	  }

	  swiper.emit('setTranslate', swiper.translate, byController);
	};

	var minTranslate = function () {
	  return (-this.snapGrid[0]);
	};

	var maxTranslate = function () {
	  return (-this.snapGrid[this.snapGrid.length - 1]);
	};

	var translate = {
	  getTranslate: getTranslate,
	  setTranslate: setTranslate,
	  minTranslate: minTranslate,
	  maxTranslate: maxTranslate,
	};

	var setTransition = function (duration, byController) {
	  var swiper = this;

	  swiper.$wrapperEl.transition(duration);

	  swiper.emit('setTransition', duration, byController);
	};

	var transitionStart = function (runCallbacks) {
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var params = swiper.params;
	  var previousIndex = swiper.previousIndex;
	  if (params.autoHeight) {
	    swiper.updateAutoHeight();
	  }
	  swiper.emit('transitionStart');

	  if (!runCallbacks) { return; }
	  if (activeIndex !== previousIndex) {
	    swiper.emit('slideChangeTransitionStart');
	    if (activeIndex > previousIndex) {
	      swiper.emit('slideNextTransitionStart');
	    } else {
	      swiper.emit('slidePrevTransitionStart');
	    }
	  }
	};

	var transitionEnd$1 = function (runCallbacks) {
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var previousIndex = swiper.previousIndex;
	  swiper.animating = false;
	  swiper.setTransition(0);

	  swiper.emit('transitionEnd');
	  if (runCallbacks) {
	    if (activeIndex !== previousIndex) {
	      swiper.emit('slideChangeTransitionEnd');
	      if (activeIndex > previousIndex) {
	        swiper.emit('slideNextTransitionEnd');
	      } else {
	        swiper.emit('slidePrevTransitionEnd');
	      }
	    }
	  }
	};

	var transition$1 = {
	  setTransition: setTransition,
	  transitionStart: transitionStart,
	  transitionEnd: transitionEnd$1,
	};

	var Browser = (function Browser() {
	  function isIE9() {
	    // create temporary DIV
	    var div = document.createElement('div');
	    // add content to tmp DIV which is wrapped into the IE HTML conditional statement
	    div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
	    // return true / false value based on what will browser render
	    return div.getElementsByTagName('i').length === 1;
	  }
	  function isSafari() {
	    var ua = window.navigator.userAgent.toLowerCase();
	    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
	  }
	  return {
	    isSafari: isSafari(),
	    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
	    ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
	    ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) ||
	             (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1),
	    lteIE9: isIE9(),
	  };
	}());

	var slideTo = function (index, speed, runCallbacks, internal) {
	  if ( index === void 0 ) index = 0;
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var slideIndex = index;
	  if (slideIndex < 0) { slideIndex = 0; }

	  var params = swiper.params;
	  var snapGrid = swiper.snapGrid;
	  var slidesGrid = swiper.slidesGrid;
	  var previousIndex = swiper.previousIndex;
	  var activeIndex = swiper.activeIndex;
	  var rtl = swiper.rtl;
	  var $wrapperEl = swiper.$wrapperEl;

	  var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
	  if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }

	  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
	    swiper.emit('beforeSlideChangeStart');
	  }

	  var translate = -snapGrid[snapIndex];

	  // Update progress
	  swiper.updateProgress(translate);

	  // Normalize slideIndex
	  if (params.normalizeSlideIndex) {
	    for (var i = 0; i < slidesGrid.length; i += 1) {
	      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
	        slideIndex = i;
	      }
	    }
	  }

	  // Directions locks
	  if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
	    return false;
	  }
	  if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
	    if ((activeIndex || 0) !== slideIndex) { return false; }
	  }

	  // Update Index
	  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
	    swiper.updateActiveIndex(slideIndex);
	    // Update Height
	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	    swiper.updateSlidesClasses();
	    if (params.effect !== 'slide') {
	      swiper.setTranslate(translate);
	    }
	    return false;
	  }

	  if (speed === 0 || Browser.lteIE9) {
	    swiper.setTransition(0);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks);
	    swiper.transitionEnd(runCallbacks);
	  } else {
	    swiper.setTransition(speed);
	    swiper.setTranslate(translate);
	    swiper.updateActiveIndex(slideIndex);
	    swiper.updateSlidesClasses();
	    swiper.emit('beforeTransitionStart', speed, internal);
	    swiper.transitionStart(runCallbacks);
	    if (!swiper.animating) {
	      swiper.animating = true;
	      $wrapperEl.transitionEnd(function () {
	        if (!swiper || swiper.destroyed) { return; }
	        swiper.transitionEnd(runCallbacks);
	      });
	    }
	  }

	  return true;
	};

	/* eslint no-unused-vars: "off" */
	var slideNext = function (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var params = swiper.params;
	  var animating = swiper.animating;
	  if (params.loop) {
	    if (animating) { return false; }
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	  }
	  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
	};

	/* eslint no-unused-vars: "off" */
	var slidePrev = function (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  var params = swiper.params;
	  var animating = swiper.animating;

	  if (params.loop) {
	    if (animating) { return false; }
	    swiper.loopFix();
	    // eslint-disable-next-line
	    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
	    return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);
	  }
	  return swiper.slideTo(swiper.activeIndex - 1, speed, runCallbacks, internal);
	};

	/* eslint no-unused-vars: "off" */
	var slideReset = function (speed, runCallbacks, internal) {
	  if ( speed === void 0 ) speed = this.params.speed;
	  if ( runCallbacks === void 0 ) runCallbacks = true;

	  var swiper = this;
	  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
	};

	var slideToClickedSlide = function () {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;

	  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
	  var slideToIndex = swiper.clickedIndex;
	  var realIndex;
	  if (params.loop) {
	    if (swiper.animating) { return; }
	    realIndex = parseInt($$1$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
	    if (params.centeredSlides) {
	      if (
	        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2)) ||
	        (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
	      ) {
	        swiper.loopFix();
	        slideToIndex = $wrapperEl
	          .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	          .eq(0)
	          .index();

	        Utils.nextTick(function () {
	          swiper.slideTo(slideToIndex);
	        });
	      } else {
	        swiper.slideTo(slideToIndex);
	      }
	    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
	      swiper.loopFix();
	      slideToIndex = $wrapperEl
	        .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))
	        .eq(0)
	        .index();

	      Utils.nextTick(function () {
	        swiper.slideTo(slideToIndex);
	      });
	    } else {
	      swiper.slideTo(slideToIndex);
	    }
	  } else {
	    swiper.slideTo(slideToIndex);
	  }
	};

	var slide = {
	  slideTo: slideTo,
	  slideNext: slideNext,
	  slidePrev: slidePrev,
	  slideReset: slideReset,
	  slideToClickedSlide: slideToClickedSlide,
	};

	var loopCreate = function () {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  // Remove duplicated slides
	  $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();

	  var slides = $wrapperEl.children(("." + (params.slideClass)));

	  if (params.loopFillGroupWithBlank) {
	    var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
	    if (blankSlidesNum !== params.slidesPerGroup) {
	      for (var i = 0; i < blankSlidesNum; i += 1) {
	        var blankNode = $$1$1(document.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));
	        $wrapperEl.append(blankNode);
	      }
	      slides = $wrapperEl.children(("." + (params.slideClass)));
	    }
	  }

	  if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }

	  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
	  swiper.loopedSlides += params.loopAdditionalSlides;
	  if (swiper.loopedSlides > slides.length) {
	    swiper.loopedSlides = slides.length;
	  }

	  var prependSlides = [];
	  var appendSlides = [];
	  slides.each(function (index, el) {
	    var slide = $$1$1(el);
	    if (index < swiper.loopedSlides) { appendSlides.push(el); }
	    if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }
	    slide.attr('data-swiper-slide-index', index);
	  });
	  for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
	    $wrapperEl.append($$1$1(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	  for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
	    $wrapperEl.prepend($$1$1(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
	  }
	};

	var loopFix = function () {
	  var swiper = this;
	  var params = swiper.params;
	  var activeIndex = swiper.activeIndex;
	  var slides = swiper.slides;
	  var loopedSlides = swiper.loopedSlides;
	  var allowSlidePrev = swiper.allowSlidePrev;
	  var allowSlideNext = swiper.allowSlideNext;
	  var newIndex;
	  swiper.allowSlidePrev = true;
	  swiper.allowSlideNext = true;
	  // Fix For Negative Oversliding
	  if (activeIndex < loopedSlides) {
	    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
	    newIndex += loopedSlides;
	    swiper.slideTo(newIndex, 0, false, true);
	  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex > slides.length - (params.slidesPerView * 2))) {
	    // Fix For Positive Oversliding
	    newIndex = -slides.length + activeIndex + loopedSlides;
	    newIndex += loopedSlides;
	    swiper.slideTo(newIndex, 0, false, true);
	  }
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	};

	var loopDestroy = function () {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl;
	  var params = swiper.params;
	  var slides = swiper.slides;
	  $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();
	  slides.removeAttr('data-swiper-slide-index');
	};

	var loop = {
	  loopCreate: loopCreate,
	  loopFix: loopFix,
	  loopDestroy: loopDestroy,
	};

	var setGrabCursor = function (moving) {
	  var swiper = this;
	  if (Support.touch || !swiper.params.simulateTouch) { return; }
	  var el = swiper.el;
	  el.style.cursor = 'move';
	  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
	  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
	  el.style.cursor = moving ? 'grabbing' : 'grab';
	};

	var unsetGrabCursor = function () {
	  var swiper = this;
	  if (Support.touch) { return; }
	  swiper.el.style.cursor = '';
	};

	var grabCursor = {
	  setGrabCursor: setGrabCursor,
	  unsetGrabCursor: unsetGrabCursor,
	};

	var appendSlide = function (slides) {
	  var swiper = this;
	  var $wrapperEl = swiper.$wrapperEl;
	  var params = swiper.params;
	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) { $wrapperEl.append(slides[i]); }
	    }
	  } else {
	    $wrapperEl.append(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	};

	var prependSlide = function (slides) {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;

	  if (params.loop) {
	    swiper.loopDestroy();
	  }
	  var newActiveIndex = activeIndex + 1;
	  if (typeof slides === 'object' && 'length' in slides) {
	    for (var i = 0; i < slides.length; i += 1) {
	      if (slides[i]) { $wrapperEl.prepend(slides[i]); }
	    }
	    newActiveIndex = activeIndex + slides.length;
	  } else {
	    $wrapperEl.prepend(slides);
	  }
	  if (params.loop) {
	    swiper.loopCreate();
	  }
	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  swiper.slideTo(newActiveIndex, 0, false);
	};

	var removeSlide = function (slidesIndexes) {
	  var swiper = this;
	  var params = swiper.params;
	  var $wrapperEl = swiper.$wrapperEl;
	  var activeIndex = swiper.activeIndex;

	  if (params.loop) {
	    swiper.loopDestroy();
	    swiper.slides = $wrapperEl.children(("." + (params.slideClass)));
	  }
	  var newActiveIndex = activeIndex;
	  var indexToRemove;

	  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
	    for (var i = 0; i < slidesIndexes.length; i += 1) {
	      indexToRemove = slidesIndexes[i];
	      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	    }
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  } else {
	    indexToRemove = slidesIndexes;
	    if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }
	    if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }
	    newActiveIndex = Math.max(newActiveIndex, 0);
	  }

	  if (params.loop) {
	    swiper.loopCreate();
	  }

	  if (!(params.observer && Support.observer)) {
	    swiper.update();
	  }
	  if (params.loop) {
	    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
	  } else {
	    swiper.slideTo(newActiveIndex, 0, false);
	  }
	};

	var removeAllSlides = function () {
	  var swiper = this;

	  var slidesIndexes = [];
	  for (var i = 0; i < swiper.slides.length; i += 1) {
	    slidesIndexes.push(i);
	  }
	  swiper.removeSlide(slidesIndexes);
	};

	var manipulation = {
	  appendSlide: appendSlide,
	  prependSlide: prependSlide,
	  removeSlide: removeSlide,
	  removeAllSlides: removeAllSlides,
	};

	var onTouchStart = function (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params;
	  var touches = swiper.touches;
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  data.isTouchEvent = e.type === 'touchstart';
	  if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }
	  if (data.isTouched && data.isMoved) { return; }
	  if (params.noSwiping && $$1$1(e.target).closest(("." + (params.noSwipingClass)))[0]) {
	    swiper.allowClick = true;
	    return;
	  }
	  if (params.swipeHandler) {
	    if (!$$1$1(e).closest(params.swipeHandler)[0]) { return; }
	  }

	  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  var startX = touches.currentX;
	  var startY = touches.currentY;

	  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

	  if (
	    Device.ios &&
	    !Device.cordova &&
	    params.iOSEdgeSwipeDetection &&
	    (startX <= params.iOSEdgeSwipeThreshold) &&
	    (startX >= window.screen.width - params.iOSEdgeSwipeThreshold)
	  ) {
	    return;
	  }

	  Utils.extend(data, {
	    isTouched: true,
	    isMoved: false,
	    allowTouchCallbacks: true,
	    isScrolling: undefined,
	    startMoving: undefined,
	  });

	  touches.startX = startX;
	  touches.startY = startY;
	  data.touchStartTime = Utils.now();
	  swiper.allowClick = true;
	  swiper.updateSize();
	  swiper.swipeDirection = undefined;
	  if (params.threshold > 0) { data.allowThresholdMove = false; }
	  if (e.type !== 'touchstart') {
	    var preventDefault = true;
	    if ($$1$1(e.target).is(data.formElements)) { preventDefault = false; }
	    if (document.activeElement && $$1$1(document.activeElement).is(data.formElements)) {
	      document.activeElement.blur();
	    }
	    if (preventDefault && swiper.allowTouchMove) {
	      e.preventDefault();
	    }
	  }
	  swiper.emit('touchStart', e);
	};

	var onTouchMove = function (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;
	  var params = swiper.params;
	  var touches = swiper.touches;
	  var rtl = swiper.rtl;
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  if (data.isTouchEvent && e.type === 'mousemove') { return; }
	  var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	  var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	  if (e.preventedByNestedSwiper) {
	    touches.startX = pageX;
	    touches.startY = pageY;
	    return;
	  }
	  if (!swiper.allowTouchMove) {
	    // isMoved = true;
	    swiper.allowClick = false;
	    if (data.isTouched) {
	      Utils.extend(touches, {
	        startX: pageX,
	        startY: pageY,
	        currentX: pageX,
	        currentY: pageY,
	      });
	      data.touchStartTime = Utils.now();
	    }
	    return;
	  }
	  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
	    if (swiper.isVertical()) {
	      // Vertical
	      if (
	        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||
	        (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
	      ) {
	        data.isTouched = false;
	        data.isMoved = false;
	        return;
	      }
	    } else if (
	      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||
	      (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
	    ) {
	      return;
	    }
	  }
	  if (data.isTouchEvent && document.activeElement) {
	    if (e.target === document.activeElement && $$1$1(e.target).is(data.formElements)) {
	      data.isMoved = true;
	      swiper.allowClick = false;
	      return;
	    }
	  }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchMove', e);
	  }
	  if (e.targetTouches && e.targetTouches.length > 1) { return; }

	  touches.currentX = pageX;
	  touches.currentY = pageY;

	  var diffX = touches.currentX - touches.startX;
	  var diffY = touches.currentY - touches.startY;

	  if (typeof data.isScrolling === 'undefined') {
	    var touchAngle;
	    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
	      data.isScrolling = false;
	    } else {
	      // eslint-disable-next-line
	      if ((diffX * diffX) + (diffY * diffY) >= 25) {
	        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
	        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
	      }
	    }
	  }
	  if (data.isScrolling) {
	    swiper.emit('touchMoveOpposite', e);
	  }
	  if (typeof startMoving === 'undefined') {
	    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
	      data.startMoving = true;
	    }
	  }
	  if (!data.isTouched) { return; }
	  if (data.isScrolling) {
	    data.isTouched = false;
	    return;
	  }
	  if (!data.startMoving) {
	    return;
	  }
	  swiper.allowClick = false;
	  e.preventDefault();
	  if (params.touchMoveStopPropagation && !params.nested) {
	    e.stopPropagation();
	  }

	  if (!data.isMoved) {
	    if (params.loop) {
	      swiper.loopFix();
	    }
	    data.startTranslate = swiper.getTranslate();
	    swiper.setTransition(0);
	    if (swiper.animating) {
	      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
	    }
	    data.allowMomentumBounce = false;
	    // Grab Cursor
	    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	      swiper.setGrabCursor(true);
	    }
	    swiper.emit('sliderFirstMove', e);
	  }
	  swiper.emit('sliderMove', e);
	  data.isMoved = true;

	  var diff = swiper.isHorizontal() ? diffX : diffY;
	  touches.diff = diff;

	  diff *= params.touchRatio;
	  if (rtl) { diff = -diff; }

	  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
	  data.currentTranslate = diff + data.startTranslate;

	  var disableParentSwiper = true;
	  var resistanceRatio = params.resistanceRatio;
	  if (params.touchReleaseOnEdges) {
	    resistanceRatio = 0;
	  }
	  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
	    disableParentSwiper = false;
	    if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }
	  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
	    disableParentSwiper = false;
	    if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }
	  }

	  if (disableParentSwiper) {
	    e.preventedByNestedSwiper = true;
	  }

	  // Directions locks
	  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }
	  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
	    data.currentTranslate = data.startTranslate;
	  }


	  // Threshold
	  if (params.threshold > 0) {
	    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
	      if (!data.allowThresholdMove) {
	        data.allowThresholdMove = true;
	        touches.startX = touches.currentX;
	        touches.startY = touches.currentY;
	        data.currentTranslate = data.startTranslate;
	        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
	        return;
	      }
	    } else {
	      data.currentTranslate = data.startTranslate;
	      return;
	    }
	  }

	  if (!params.followFinger) { return; }

	  // Update active index in free mode
	  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  }
	  if (params.freeMode) {
	    // Velocity
	    if (data.velocities.length === 0) {
	      data.velocities.push({
	        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
	        time: data.touchStartTime,
	      });
	    }
	    data.velocities.push({
	      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
	      time: Utils.now(),
	    });
	  }
	  // Update progress
	  swiper.updateProgress(data.currentTranslate);
	  // Update translate
	  swiper.setTranslate(data.currentTranslate);
	};

	var onTouchEnd = function (event) {
	  var swiper = this;
	  var data = swiper.touchEventsData;

	  var params = swiper.params;
	  var touches = swiper.touches;
	  var rtl = swiper.rtl;
	  var $wrapperEl = swiper.$wrapperEl;
	  var slidesGrid = swiper.slidesGrid;
	  var snapGrid = swiper.snapGrid;
	  var e = event;
	  if (e.originalEvent) { e = e.originalEvent; }
	  if (data.allowTouchCallbacks) {
	    swiper.emit('touchEnd', e);
	  }
	  data.allowTouchCallbacks = false;
	  if (!data.isTouched) { return; }
	  // Return Grab Cursor
	  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
	    swiper.setGrabCursor(false);
	  }

	  // Time diff
	  var touchEndTime = Utils.now();
	  var timeDiff = touchEndTime - data.touchStartTime;

	  // Tap, doubleTap, Click
	  if (swiper.allowClick) {
	    swiper.updateClickedSlide(e);
	    swiper.emit('tap', e);
	    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
	      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	      data.clickTimeout = Utils.nextTick(function () {
	        if (!swiper || swiper.destroyed) { return; }
	        swiper.emit('click', e);
	      }, 300);
	    }
	    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
	      if (data.clickTimeout) { clearTimeout(data.clickTimeout); }
	      swiper.emit('doubleTap', e);
	    }
	  }

	  data.lastClickTime = Utils.now();
	  Utils.nextTick(function () {
	    if (!swiper.destroyed) { swiper.allowClick = true; }
	  });

	  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
	    data.isTouched = false;
	    data.isMoved = false;
	    return;
	  }
	  data.isTouched = false;
	  data.isMoved = false;

	  var currentPos;
	  if (params.followFinger) {
	    currentPos = rtl ? swiper.translate : -swiper.translate;
	  } else {
	    currentPos = -data.currentTranslate;
	  }
	  if (params.freeMode) {
	    if (currentPos < -swiper.minTranslate()) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    } else if (currentPos > -swiper.maxTranslate()) {
	      if (swiper.slides.length < snapGrid.length) {
	        swiper.slideTo(snapGrid.length - 1);
	      } else {
	        swiper.slideTo(swiper.slides.length - 1);
	      }
	      return;
	    }

	    if (params.freeModeMomentum) {
	      if (data.velocities.length > 1) {
	        var lastMoveEvent = data.velocities.pop();
	        var velocityEvent = data.velocities.pop();

	        var distance = lastMoveEvent.position - velocityEvent.position;
	        var time = lastMoveEvent.time - velocityEvent.time;
	        swiper.velocity = distance / time;
	        swiper.velocity /= 2;
	        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
	          swiper.velocity = 0;
	        }
	        // this implies that the user stopped moving a finger then released.
	        // There would be no events with distance zero, so the last event is stale.
	        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
	          swiper.velocity = 0;
	        }
	      } else {
	        swiper.velocity = 0;
	      }
	      swiper.velocity *= params.freeModeMomentumVelocityRatio;

	      data.velocities.length = 0;
	      var momentumDuration = 1000 * params.freeModeMomentumRatio;
	      var momentumDistance = swiper.velocity * momentumDuration;

	      var newPosition = swiper.translate + momentumDistance;
	      if (rtl) { newPosition = -newPosition; }
	      var doBounce = false;
	      var afterBouncePosition;
	      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
	      if (newPosition < swiper.maxTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
	            newPosition = swiper.maxTranslate() - bounceAmount;
	          }
	          afterBouncePosition = swiper.maxTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.maxTranslate();
	        }
	      } else if (newPosition > swiper.minTranslate()) {
	        if (params.freeModeMomentumBounce) {
	          if (newPosition - swiper.minTranslate() > bounceAmount) {
	            newPosition = swiper.minTranslate() + bounceAmount;
	          }
	          afterBouncePosition = swiper.minTranslate();
	          doBounce = true;
	          data.allowMomentumBounce = true;
	        } else {
	          newPosition = swiper.minTranslate();
	        }
	      } else if (params.freeModeSticky) {
	        var nextSlide;
	        for (var j = 0; j < snapGrid.length; j += 1) {
	          if (snapGrid[j] > -newPosition) {
	            nextSlide = j;
	            break;
	          }
	        }
	        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
	          newPosition = snapGrid[nextSlide];
	        } else {
	          newPosition = snapGrid[nextSlide - 1];
	        }
	        newPosition = -newPosition;
	      }
	      // Fix duration
	      if (swiper.velocity !== 0) {
	        if (rtl) {
	          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
	        } else {
	          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
	        }
	      } else if (params.freeModeSticky) {
	        swiper.slideReset();
	        return;
	      }

	      if (params.freeModeMomentumBounce && doBounce) {
	        swiper.updateProgress(afterBouncePosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart();
	        swiper.animating = true;
	        $wrapperEl.transitionEnd(function () {
	          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }
	          swiper.emit('momentumBounce');

	          swiper.setTransition(params.speed);
	          swiper.setTranslate(afterBouncePosition);
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed) { return; }
	            swiper.transitionEnd();
	          });
	        });
	      } else if (swiper.velocity) {
	        swiper.updateProgress(newPosition);
	        swiper.setTransition(momentumDuration);
	        swiper.setTranslate(newPosition);
	        swiper.transitionStart();
	        if (!swiper.animating) {
	          swiper.animating = true;
	          $wrapperEl.transitionEnd(function () {
	            if (!swiper || swiper.destroyed) { return; }
	            swiper.transitionEnd();
	          });
	        }
	      } else {
	        swiper.updateProgress(newPosition);
	      }

	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
	      swiper.updateProgress();
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    return;
	  }

	  // Find current slide
	  var stopIndex = 0;
	  var groupSize = swiper.slidesSizesGrid[0];
	  for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
	    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
	      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
	        stopIndex = i;
	        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
	      }
	    } else if (currentPos >= slidesGrid[i]) {
	      stopIndex = i;
	      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
	    }
	  }

	  // Find current slide size
	  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

	  if (timeDiff > params.longSwipesMs) {
	    // Long touches
	    if (!params.longSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	      else { swiper.slideTo(stopIndex); }
	    }
	    if (swiper.swipeDirection === 'prev') {
	      if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }
	      else { swiper.slideTo(stopIndex); }
	    }
	  } else {
	    // Short swipes
	    if (!params.shortSwipes) {
	      swiper.slideTo(swiper.activeIndex);
	      return;
	    }
	    if (swiper.swipeDirection === 'next') {
	      swiper.slideTo(stopIndex + params.slidesPerGroup);
	    }
	    if (swiper.swipeDirection === 'prev') {
	      swiper.slideTo(stopIndex);
	    }
	  }
	};

	var onResize = function () {
	  var swiper = this;

	  var params = swiper.params;
	  var el = swiper.el;

	  if (el && el.offsetWidth === 0) { return; }

	  // Breakpoints
	  if (params.breakpoints) {
	    swiper.setBreakpoint();
	  }

	  // Save locks
	  var allowSlideNext = swiper.allowSlideNext;
	  var allowSlidePrev = swiper.allowSlidePrev;

	  // Disable locks on resize
	  swiper.allowSlideNext = true;
	  swiper.allowSlidePrev = true;

	  swiper.updateSize();
	  swiper.updateSlides();

	  if (params.freeMode) {
	    var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
	    swiper.setTranslate(newTranslate);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();

	    if (params.autoHeight) {
	      swiper.updateAutoHeight();
	    }
	  } else {
	    swiper.updateSlidesClasses();
	    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	    } else {
	      swiper.slideTo(swiper.activeIndex, 0, false, true);
	    }
	  }
	  // Return locks after resize
	  swiper.allowSlidePrev = allowSlidePrev;
	  swiper.allowSlideNext = allowSlideNext;
	};

	var onClick = function (e) {
	  var swiper = this;
	  if (!swiper.allowClick) {
	    if (swiper.params.preventClicks) { e.preventDefault(); }
	    if (swiper.params.preventClicksPropagation && swiper.animating) {
	      e.stopPropagation();
	      e.stopImmediatePropagation();
	    }
	  }
	};

	function attachEvents() {
	  var swiper = this;

	  var params = swiper.params;
	  var touchEvents = swiper.touchEvents;
	  var el = swiper.el;
	  var wrapperEl = swiper.wrapperEl;

	  {
	    swiper.onTouchStart = onTouchStart.bind(swiper);
	    swiper.onTouchMove = onTouchMove.bind(swiper);
	    swiper.onTouchEnd = onTouchEnd.bind(swiper);
	  }

	  swiper.onClick = onClick.bind(swiper);

	  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  var capture = !!params.nested;

	  // Touch Events
	  {
	    if (Browser.ie) {
	      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
	      (Support.touch ? target : document).addEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      (Support.touch ? target : document).addEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);
	        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	        target.addEventListener('mousedown', swiper.onTouchStart, false);
	        document.addEventListener('mousemove', swiper.onTouchMove, capture);
	        document.addEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.addEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.on('resize observerUpdate', onResize);
	}

	function detachEvents() {
	  var swiper = this;

	  var params = swiper.params;
	  var touchEvents = swiper.touchEvents;
	  var el = swiper.el;
	  var wrapperEl = swiper.wrapperEl;

	  var target = params.touchEventsTarget === 'container' ? el : wrapperEl;
	  var capture = !!params.nested;

	  // Touch Events
	  {
	    if (Browser.ie) {
	      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
	      (Support.touch ? target : document).removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	      (Support.touch ? target : document).removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
	    } else {
	      if (Support.touch) {
	        var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
	        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
	        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
	        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
	      }
	      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
	        target.removeEventListener('mousedown', swiper.onTouchStart, false);
	        document.removeEventListener('mousemove', swiper.onTouchMove, capture);
	        document.removeEventListener('mouseup', swiper.onTouchEnd, false);
	      }
	    }
	    // Prevent Links Clicks
	    if (params.preventClicks || params.preventClicksPropagation) {
	      target.removeEventListener('click', swiper.onClick, true);
	    }
	  }

	  // Resize handler
	  swiper.off('resize observerUpdate', onResize);
	}

	var events = {
	  attachEvents: attachEvents,
	  detachEvents: detachEvents,
	};

	var setBreakpoint = function () {
	  var swiper = this;
	  var activeIndex = swiper.activeIndex;
	  var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;
	  var params = swiper.params;
	  var breakpoints = params.breakpoints;
	  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }
	  // Set breakpoint for window width and update parameters
	  var breakpoint = swiper.getBreakpoint(breakpoints);
	  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
	    var breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;
	    var needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);

	    Utils.extend(swiper.params, breakPointsParams);

	    Utils.extend(swiper, {
	      allowTouchMove: swiper.params.allowTouchMove,
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,
	    });

	    swiper.currentBreakpoint = breakpoint;

	    if (needsReLoop) {
	      swiper.loopDestroy();
	      swiper.loopCreate();
	      swiper.updateSlides();
	      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
	    }
	    swiper.emit('breakpoint', breakPointsParams);
	  }
	};

	var getBreakpoint = function (breakpoints) {
	  // Get breakpoint for window width
	  if (!breakpoints) { return undefined; }
	  var breakpoint = false;
	  var points = [];
	  Object.keys(breakpoints).forEach(function (point) {
	    points.push(point);
	  });
	  points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });
	  for (var i = 0; i < points.length; i += 1) {
	    var point = points[i];
	    if (point >= window.innerWidth && !breakpoint) {
	      breakpoint = point;
	    }
	  }
	  return breakpoint || 'max';
	};

	var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };

	var addClasses = function () {
	  var swiper = this;
	  var classNames = swiper.classNames;
	  var params = swiper.params;
	  var rtl = swiper.rtl;
	  var $el = swiper.$el;
	  var suffixes = [];

	  suffixes.push(params.direction);

	  if (params.freeMode) {
	    suffixes.push('free-mode');
	  }
	  if (!Support.flexbox) {
	    suffixes.push('no-flexbox');
	  }
	  if (params.autoHeight) {
	    suffixes.push('autoheight');
	  }
	  if (rtl) {
	    suffixes.push('rtl');
	  }
	  if (params.slidesPerColumn > 1) {
	    suffixes.push('multirow');
	  }
	  if (Device.android) {
	    suffixes.push('android');
	  }
	  if (Device.ios) {
	    suffixes.push('ios');
	  }
	  // WP8 Touch Events Fix
	  if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
	    suffixes.push(("wp8-" + (params.direction)));
	  }

	  suffixes.forEach(function (suffix) {
	    classNames.push(params.containerModifierClass + suffix);
	  });

	  $el.addClass(classNames.join(' '));
	};

	var removeClasses = function () {
	  var swiper = this;
	  var $el = swiper.$el;
	  var classNames = swiper.classNames;

	  $el.removeClass(classNames.join(' '));
	};

	var classes = { addClasses: addClasses, removeClasses: removeClasses };

	var loadImage = function (imageEl, src, srcset, sizes, checkForComplete, callback) {
	  var image;
	  function onReady() {
	    if (callback) { callback(); }
	  }
	  if (!imageEl.complete || !checkForComplete) {
	    if (src) {
	      image = new window.Image();
	      image.onload = onReady;
	      image.onerror = onReady;
	      if (sizes) {
	        image.sizes = sizes;
	      }
	      if (srcset) {
	        image.srcset = srcset;
	      }
	      if (src) {
	        image.src = src;
	      }
	    } else {
	      onReady();
	    }
	  } else {
	    // image already loaded...
	    onReady();
	  }
	};

	var preloadImages = function () {
	  var swiper = this;
	  swiper.imagesToLoad = swiper.$el.find('img');
	  function onReady() {
	    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }
	    if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }
	    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
	      if (swiper.params.updateOnImagesReady) { swiper.update(); }
	      swiper.emit('imagesReady');
	    }
	  }
	  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
	    var imageEl = swiper.imagesToLoad[i];
	    swiper.loadImage(
	      imageEl,
	      imageEl.currentSrc || imageEl.getAttribute('src'),
	      imageEl.srcset || imageEl.getAttribute('srcset'),
	      imageEl.sizes || imageEl.getAttribute('sizes'),
	      true,
	      onReady
	    );
	  }
	};

	var images = {
	  loadImage: loadImage,
	  preloadImages: preloadImages,
	};

	var defaults = {
	  init: true,
	  direction: 'horizontal',
	  touchEventsTarget: 'container',
	  initialSlide: 0,
	  speed: 300,

	  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	  iOSEdgeSwipeDetection: false,
	  iOSEdgeSwipeThreshold: 20,

	  // Free mode
	  freeMode: false,
	  freeModeMomentum: true,
	  freeModeMomentumRatio: 1,
	  freeModeMomentumBounce: true,
	  freeModeMomentumBounceRatio: 1,
	  freeModeMomentumVelocityRatio: 1,
	  freeModeSticky: false,
	  freeModeMinimumVelocity: 0.02,

	  // Autoheight
	  autoHeight: false,

	  // Set wrapper width
	  setWrapperSize: false,

	  // Virtual Translate
	  virtualTranslate: false,

	  // Effects
	  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

	  // Breakpoints
	  breakpoints: undefined,

	  // Slides grid
	  spaceBetween: 0,
	  slidesPerView: 1,
	  slidesPerColumn: 1,
	  slidesPerColumnFill: 'column',
	  slidesPerGroup: 1,
	  centeredSlides: false,
	  slidesOffsetBefore: 0, // in px
	  slidesOffsetAfter: 0, // in px
	  normalizeSlideIndex: true,

	  // Round length
	  roundLengths: false,

	  // Touches
	  touchRatio: 1,
	  touchAngle: 45,
	  simulateTouch: true,
	  shortSwipes: true,
	  longSwipes: true,
	  longSwipesRatio: 0.5,
	  longSwipesMs: 300,
	  followFinger: true,
	  allowTouchMove: true,
	  threshold: 0,
	  touchMoveStopPropagation: true,
	  touchReleaseOnEdges: false,

	  // Unique Navigation Elements
	  uniqueNavElements: true,

	  // Resistance
	  resistance: true,
	  resistanceRatio: 0.85,

	  // Progress
	  watchSlidesProgress: false,
	  watchSlidesVisibility: false,

	  // Cursor
	  grabCursor: false,

	  // Clicks
	  preventClicks: true,
	  preventClicksPropagation: true,
	  slideToClickedSlide: false,

	  // Images
	  preloadImages: true,
	  updateOnImagesReady: true,

	  // loop
	  loop: false,
	  loopAdditionalSlides: 0,
	  loopedSlides: null,
	  loopFillGroupWithBlank: false,

	  // Swiping/no swiping
	  allowSlidePrev: true,
	  allowSlideNext: true,
	  swipeHandler: null, // '.swipe-handler',
	  noSwiping: true,
	  noSwipingClass: 'swiper-no-swiping',

	  // Passive Listeners
	  passiveListeners: true,

	  // NS
	  containerModifierClass: 'swiper-container-', // NEW
	  slideClass: 'swiper-slide',
	  slideBlankClass: 'swiper-slide-invisible-blank',
	  slideActiveClass: 'swiper-slide-active',
	  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
	  slideVisibleClass: 'swiper-slide-visible',
	  slideDuplicateClass: 'swiper-slide-duplicate',
	  slideNextClass: 'swiper-slide-next',
	  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
	  slidePrevClass: 'swiper-slide-prev',
	  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
	  wrapperClass: 'swiper-wrapper',

	  // Callbacks
	  runCallbacksOnInit: true,
	};

	var prototypes = {
	  update: update,
	  translate: translate,
	  transition: transition$1,
	  slide: slide,
	  loop: loop,
	  grabCursor: grabCursor,
	  manipulation: manipulation,
	  events: events,
	  breakpoints: breakpoints,
	  classes: classes,
	  images: images,
	};

	var extendedDefaults = {};

	var Swiper$2 = (function (SwiperClass$$1) {
	  function Swiper() {
	    var args = [], len = arguments.length;
	    while ( len-- ) args[ len ] = arguments[ len ];

	    var el;
	    var params;
	    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
	      params = args[0];
	    } else {
	      var assign;
	      (assign = args, el = assign[0], params = assign[1]);
	    }
	    if (!params) { params = {}; }

	    params = Utils.extend({}, params);
	    if (el && !params.el) { params.el = el; }

	    SwiperClass$$1.call(this, params);

	    Object.keys(prototypes).forEach(function (prototypeGroup) {
	      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
	        if (!Swiper.prototype[protoMethod]) {
	          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
	        }
	      });
	    });

	    // Swiper Instance
	    var swiper = this;
	    if (typeof swiper.modules === 'undefined') {
	      swiper.modules = {};
	    }
	    Object.keys(swiper.modules).forEach(function (moduleName) {
	      var module = swiper.modules[moduleName];
	      if (module.params) {
	        var moduleParamName = Object.keys(module.params)[0];
	        var moduleParams = module.params[moduleParamName];
	        if (typeof moduleParams !== 'object') { return; }
	        if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }
	        if (params[moduleParamName] === true) {
	          params[moduleParamName] = { enabled: true };
	        }
	        if (
	          typeof params[moduleParamName] === 'object' &&
	          !('enabled' in params[moduleParamName])
	        ) {
	          params[moduleParamName].enabled = true;
	        }
	        if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }
	      }
	    });

	    // Extend defaults with modules params
	    var swiperParams = Utils.extend({}, defaults);
	    swiper.useModulesParams(swiperParams);

	    // Extend defaults with passed params
	    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
	    swiper.originalParams = Utils.extend({}, swiper.params);
	    swiper.passedParams = Utils.extend({}, params);

	    // Find el
	    var $el = $$1$1(swiper.params.el);
	    el = $el[0];

	    if (!el) {
	      return undefined;
	    }

	    if ($el.length > 1) {
	      var swipers = [];
	      $el.each(function (index, containerEl) {
	        var newParams = Utils.extend({}, params, { el: containerEl });
	        swipers.push(new Swiper(newParams));
	      });
	      return swipers;
	    }

	    el.swiper = swiper;
	    $el.data('swiper', swiper);

	    // Find Wrapper
	    var $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));

	    // Extend Swiper
	    Utils.extend(swiper, {
	      $el: $el,
	      el: el,
	      $wrapperEl: $wrapperEl,
	      wrapperEl: $wrapperEl[0],

	      // Classes
	      classNames: [],

	      // Slides
	      slides: $$1$1(),
	      slidesGrid: [],
	      snapGrid: [],
	      slidesSizesGrid: [],

	      // isDirection
	      isHorizontal: function isHorizontal() {
	        return swiper.params.direction === 'horizontal';
	      },
	      isVertical: function isVertical() {
	        return swiper.params.direction === 'vertical';
	      },
	      // RTL
	      rtl: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
	      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

	      // Indexes
	      activeIndex: 0,
	      realIndex: 0,

	      //
	      isBeginning: true,
	      isEnd: false,

	      // Props
	      translate: 0,
	      progress: 0,
	      velocity: 0,
	      animating: false,

	      // Locks
	      allowSlideNext: swiper.params.allowSlideNext,
	      allowSlidePrev: swiper.params.allowSlidePrev,

	      // Touch Events
	      touchEvents: (function touchEvents() {
	        var touch = ['touchstart', 'touchmove', 'touchend'];
	        var desktop = ['mousedown', 'mousemove', 'mouseup'];
	        if (window.navigator.pointerEnabled) {
	          desktop = ['pointerdown', 'pointermove', 'pointerup'];
	        } else if (window.navigator.msPointerEnabled) {
	          desktop = ['MSPointerDown', 'MsPointerMove', 'MsPointerUp'];
	        }

	        return {
	          start: Support.touch || !swiper.params.simulateTouch ? touch[0] : desktop[0],
	          move: Support.touch || !swiper.params.simulateTouch ? touch[1] : desktop[1],
	          end: Support.touch || !swiper.params.simulateTouch ? touch[2] : desktop[2],
	        };
	      }()),
	      touchEventsData: {
	        isTouched: undefined,
	        isMoved: undefined,
	        allowTouchCallbacks: undefined,
	        touchStartTime: undefined,
	        isScrolling: undefined,
	        currentTranslate: undefined,
	        startTranslate: undefined,
	        allowThresholdMove: undefined,
	        // Form elements to match
	        formElements: 'input, select, option, textarea, button, video',
	        // Last click time
	        lastClickTime: Utils.now(),
	        clickTimeout: undefined,
	        // Velocities
	        velocities: [],
	        allowMomentumBounce: undefined,
	        isTouchEvent: undefined,
	        startMoving: undefined,
	      },

	      // Clicks
	      allowClick: true,

	      // Touches
	      allowTouchMove: swiper.params.allowTouchMove,

	      touches: {
	        startX: 0,
	        startY: 0,
	        currentX: 0,
	        currentY: 0,
	        diff: 0,
	      },

	      // Images
	      imagesToLoad: [],
	      imagesLoaded: 0,

	    });

	    // Install Modules
	    swiper.useModules();

	    // Init
	    if (swiper.params.init) {
	      swiper.init();
	    }

	    // Return app instance
	    return swiper;
	  }

	  if ( SwiperClass$$1 ) Swiper.__proto__ = SwiperClass$$1;
	  Swiper.prototype = Object.create( SwiperClass$$1 && SwiperClass$$1.prototype );
	  Swiper.prototype.constructor = Swiper;

	  var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };
	  Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {
	    var swiper = this;
	    var params = swiper.params;
	    var slides = swiper.slides;
	    var slidesGrid = swiper.slidesGrid;
	    var swiperSize = swiper.size;
	    var activeIndex = swiper.activeIndex;
	    var spv = 1;
	    if (params.centeredSlides) {
	      var slideSize = slides[activeIndex].swiperSlideSize;
	      var breakLoop;
	      for (var i = activeIndex + 1; i < slides.length; i += 1) {
	        if (slides[i] && !breakLoop) {
	          slideSize += slides[i].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) { breakLoop = true; }
	        }
	      }
	      for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
	        if (slides[i$1] && !breakLoop) {
	          slideSize += slides[i$1].swiperSlideSize;
	          spv += 1;
	          if (slideSize > swiperSize) { breakLoop = true; }
	        }
	      }
	    } else {
	      for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
	        if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
	          spv += 1;
	        }
	      }
	    }
	    return spv;
	  };
	  Swiper.prototype.update = function update$$1 () {
	    var swiper = this;
	    if (!swiper || swiper.destroyed) { return; }
	    swiper.updateSize();
	    swiper.updateSlides();
	    swiper.updateProgress();
	    swiper.updateSlidesClasses();

	    var newTranslate;
	    function setTranslate() {
	      newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
	      swiper.setTranslate(newTranslate);
	      swiper.updateActiveIndex();
	      swiper.updateSlidesClasses();
	    }
	    var translated;
	    if (swiper.params.freeMode) {
	      setTranslate();
	      if (swiper.params.autoHeight) {
	        swiper.updateAutoHeight();
	      }
	    } else {
	      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
	        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
	      } else {
	        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
	      }
	      if (!translated) {
	        setTranslate();
	      }
	    }
	    swiper.emit('update');
	  };
	  Swiper.prototype.init = function init () {
	    var swiper = this;
	    if (swiper.initialized) { return; }

	    swiper.emit('beforeInit');

	    // Set breakpoint
	    if (swiper.params.breakpoints) {
	      swiper.setBreakpoint();
	    }

	    // Add Classes
	    swiper.addClasses();

	    // Create loop
	    if (swiper.params.loop) {
	      swiper.loopCreate();
	    }

	    // Update size
	    swiper.updateSize();

	    // Update slides
	    swiper.updateSlides();

	    // Set Grab Cursor
	    if (swiper.params.grabCursor) {
	      swiper.setGrabCursor();
	    }

	    if (swiper.params.preloadImages) {
	      swiper.preloadImages();
	    }

	    // Slide To Initial Slide
	    if (swiper.params.loop) {
	      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
	    } else {
	      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
	    }

	    // Attach events
	    swiper.attachEvents();

	    // Init Flag
	    swiper.initialized = true;

	    // Emit
	    swiper.emit('init');
	  };
	  Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {
	    if ( deleteInstance === void 0 ) deleteInstance = true;
	    if ( cleanStyles === void 0 ) cleanStyles = true;

	    var swiper = this;
	    var params = swiper.params;
	    var $el = swiper.$el;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slides = swiper.slides;
	    swiper.emit('beforeDestroy');

	    // Init Flag
	    swiper.initialized = false;

	    // Detach events
	    swiper.detachEvents();

	    // Destroy loop
	    if (params.loop) {
	      swiper.loopDestroy();
	    }

	    // Cleanup styles
	    if (cleanStyles) {
	      swiper.removeClasses();
	      $el.removeAttr('style');
	      $wrapperEl.removeAttr('style');
	      if (slides && slides.length) {
	        slides
	          .removeClass([
	            params.slideVisibleClass,
	            params.slideActiveClass,
	            params.slideNextClass,
	            params.slidePrevClass ].join(' '))
	          .removeAttr('style')
	          .removeAttr('data-swiper-slide-index')
	          .removeAttr('data-swiper-column')
	          .removeAttr('data-swiper-row');
	      }
	    }

	    swiper.emit('destroy');

	    // Detach emitter events
	    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
	      swiper.off(eventName);
	    });

	    if (deleteInstance !== false) {
	      swiper.$el[0].swiper = null;
	      swiper.$el.data('swiper', null);
	      Utils.deleteProps(swiper);
	    }
	    swiper.destroyed = true;
	  };
	  Swiper.extendDefaults = function extendDefaults (newDefaults) {
	    Utils.extend(extendedDefaults, newDefaults);
	  };
	  staticAccessors.extendedDefaults.get = function () {
	    return extendedDefaults;
	  };
	  staticAccessors.defaults.get = function () {
	    return defaults;
	  };
	  staticAccessors.Class.get = function () {
	    return SwiperClass$$1;
	  };
	  staticAccessors.$.get = function () {
	    return $$1$1;
	  };

	  Object.defineProperties( Swiper, staticAccessors );

	  return Swiper;
	}(Framework7Class));

	var Device$3 = {
	  name: 'device',
	  proto: {
	    device: Device,
	  },
	  static: {
	    device: Device,
	  },
	};

	var Support$3 = {
	  name: 'support',
	  proto: {
	    support: Support,
	  },
	  static: {
	    support: Support,
	  },
	};

	var Browser$2 = {
	  name: 'browser',
	  proto: {
	    browser: Browser,
	  },
	  static: {
	    browser: Browser,
	  },
	};

	var Resize = {
	  name: 'resize',
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      resize: {
	        resizeHandler: function resizeHandler() {
	          if (!swiper || !swiper.initialized) { return; }
	          swiper.emit('resize');
	        },
	        orientationChangeHandler: function orientationChangeHandler() {
	          if (!swiper || !swiper.initialized) { return; }
	          swiper.emit('orientationchange');
	        },
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      // Emit resize
	      window.addEventListener('resize', swiper.resize.resizeHandler);

	      // Emit orientationchange
	      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      window.removeEventListener('resize', swiper.resize.resizeHandler);
	      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
	    },
	  },
	};

	var Observer = {
	  func: window.MutationObserver || window.WebkitMutationObserver,
	  attach: function attach(target, options) {
	    if ( options === void 0 ) options = {};

	    var swiper = this;

	    var ObserverFunc = Observer.func;
	    var observer = new ObserverFunc(function (mutations) {
	      mutations.forEach(function (mutation) {
	        swiper.emit('observerUpdate', mutation);
	      });
	    });

	    observer.observe(target, {
	      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	      childList: typeof options.childList === 'undefined' ? true : options.childList,
	      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
	    });

	    swiper.observer.observers.push(observer);
	  },
	  init: function init() {
	    var swiper = this;
	    if (!Support.observer || !swiper.params.observer) { return; }
	    if (swiper.params.observeParents) {
	      var containerParents = swiper.$el.parents();
	      for (var i = 0; i < containerParents.length; i += 1) {
	        swiper.observer.attach(containerParents[i]);
	      }
	    }
	    // Observe container
	    swiper.observer.attach(swiper.$el[0], { childList: false });

	    // Observe wrapper
	    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    swiper.observer.observers.forEach(function (observer) {
	      observer.disconnect();
	    });
	    swiper.observer.observers = [];
	  },
	};

	var Observer$1 = {
	  name: 'observer',
	  params: {
	    observer: false,
	    observeParents: false,
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      observer: {
	        init: Observer.init.bind(swiper),
	        attach: Observer.attach.bind(swiper),
	        destroy: Observer.destroy.bind(swiper),
	        observers: [],
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.observer.init();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.observer.destroy();
	    },
	  },
	};

	var Virtual = {
	  update: function update(force) {
	    var swiper = this;
	    var ref = swiper.params;
	    var slidesPerView = ref.slidesPerView;
	    var slidesPerGroup = ref.slidesPerGroup;
	    var centeredSlides = ref.centeredSlides;
	    var ref$1 = swiper.virtual;
	    var previousFrom = ref$1.from;
	    var previousTo = ref$1.to;
	    var slides = ref$1.slides;
	    var previousSlidesGrid = ref$1.slidesGrid;
	    var renderSlide = ref$1.renderSlide;
	    var previousOffset = ref$1.offset;
	    swiper.updateActiveIndex();
	    var activeIndex = swiper.activeIndex || 0;

	    var offsetProp;
	    if (swiper.rtl && swiper.isHorizontal()) { offsetProp = 'right'; }
	    else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }

	    var slidesAfter;
	    var slidesBefore;
	    if (centeredSlides) {
	      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup;
	      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup;
	    } else {
	      slidesAfter = slidesPerView + (slidesPerGroup - 1);
	      slidesBefore = slidesPerGroup;
	    }
	    var from = Math.max((activeIndex || 0) - slidesBefore, 0);
	    var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
	    var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

	    Utils.extend(swiper.virtual, {
	      from: from,
	      to: to,
	      offset: offset,
	      slidesGrid: swiper.slidesGrid,
	    });

	    function onRendered() {
	      swiper.updateSlides();
	      swiper.updateProgress();
	      swiper.updateSlidesClasses();
	      if (swiper.lazy && swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    }

	    if (previousFrom === from && previousTo === to && !force) {
	      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
	        swiper.slides.css(offsetProp, (offset + "px"));
	      }
	      swiper.updateProgress();
	      return;
	    }
	    if (swiper.params.virtual.renderExternal) {
	      swiper.params.virtual.renderExternal.call(swiper, {
	        offset: offset,
	        from: from,
	        to: to,
	        slides: (function getSlides() {
	          var slidesToRender = [];
	          for (var i = from; i <= to; i += 1) {
	            slidesToRender.push(slides[i]);
	          }
	          return slidesToRender;
	        }()),
	      });
	      onRendered();
	      return;
	    }
	    var prependIndexes = [];
	    var appendIndexes = [];
	    if (force) {
	      swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();
	    } else {
	      for (var i = previousFrom; i <= previousTo; i += 1) {
	        if (i < from || i > to) {
	          swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();
	        }
	      }
	    }
	    for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
	      if (i$1 >= from && i$1 <= to) {
	        if (typeof previousTo === 'undefined' || force) {
	          appendIndexes.push(i$1);
	        } else {
	          if (i$1 > previousTo) { appendIndexes.push(i$1); }
	          if (i$1 < previousFrom) { prependIndexes.push(i$1); }
	        }
	      }
	    }
	    appendIndexes.forEach(function (index) {
	      swiper.$wrapperEl.append(renderSlide(slides[index], index));
	    });
	    prependIndexes.sort(function (a, b) { return a < b; }).forEach(function (index) {
	      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
	    });
	    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));
	    onRendered();
	  },
	  renderSlide: function renderSlide(slide, index) {
	    var swiper = this;
	    var params = swiper.params.virtual;
	    if (params.cache && swiper.virtual.cache[index]) {
	      return swiper.virtual.cache[index];
	    }
	    var $slideEl = params.renderSlide
	      ? $$1$1(params.renderSlide.call(swiper, slide, index))
	      : $$1$1(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));
	    if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }
	    if (params.cache) { swiper.virtual.cache[index] = $slideEl; }
	    return $slideEl;
	  },
	  appendSlide: function appendSlide(slide) {
	    var swiper = this;
	    swiper.virtual.slides.push(slide);
	    swiper.virtual.update(true);
	  },
	  prependSlide: function prependSlide(slide) {
	    var swiper = this;
	    swiper.virtual.slides.unshift(slide);
	    if (swiper.params.virtual.cache) {
	      var cache = swiper.virtual.cache;
	      var newCache = {};
	      Object.keys(cache).forEach(function (cachedIndex) {
	        newCache[cachedIndex + 1] = cache[cachedIndex];
	      });
	      swiper.virtual.cache = newCache;
	    }
	    swiper.virtual.update(true);
	    swiper.slideNext(0);
	  },
	};

	var Virtual$1 = {
	  name: 'virtual',
	  params: {
	    virtual: {
	      enabled: false,
	      slides: [],
	      cache: true,
	      renderSlide: null,
	      renderExternal: null,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      virtual: {
	        update: Virtual.update.bind(swiper),
	        appendSlide: Virtual.appendSlide.bind(swiper),
	        prependSlide: Virtual.prependSlide.bind(swiper),
	        renderSlide: Virtual.renderSlide.bind(swiper),
	        slides: swiper.params.virtual.slides,
	        cache: {},
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (!swiper.params.virtual.enabled) { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));
	      var overwriteParams = {
	        watchSlidesProgress: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);

	      swiper.virtual.update();
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (!swiper.params.virtual.enabled) { return; }
	      swiper.virtual.update();
	    },
	  },
	};

	var Navigation = {
	  update: function update() {
	    // Update Navigation Buttons
	    var swiper = this;
	    var params = swiper.params.navigation;

	    if (swiper.params.loop) { return; }
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;

	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        $prevEl.addClass(params.disabledClass);
	      } else {
	        $prevEl.removeClass(params.disabledClass);
	      }
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        $nextEl.addClass(params.disabledClass);
	      } else {
	        $nextEl.removeClass(params.disabledClass);
	      }
	    }
	  },
	  init: function init() {
	    var swiper = this;
	    var params = swiper.params.navigation;
	    if (!(params.nextEl || params.prevEl)) { return; }

	    var $nextEl;
	    var $prevEl;
	    if (params.nextEl) {
	      $nextEl = $$1$1(params.nextEl);
	      if (
	        swiper.params.uniqueNavElements &&
	        typeof params.nextEl === 'string' &&
	        $nextEl.length > 1 &&
	        swiper.$el.find(params.nextEl).length === 1
	      ) {
	        $nextEl = swiper.$el.find(params.nextEl);
	      }
	    }
	    if (params.prevEl) {
	      $prevEl = $$1$1(params.prevEl);
	      if (
	        swiper.params.uniqueNavElements &&
	        typeof params.prevEl === 'string' &&
	        $prevEl.length > 1 &&
	        swiper.$el.find(params.prevEl).length === 1
	      ) {
	        $prevEl = swiper.$el.find(params.prevEl);
	      }
	    }

	    if ($nextEl && $nextEl.length > 0) {
	      $nextEl.on('click', function (e) {
	        e.preventDefault();
	        if (swiper.isEnd && !swiper.params.loop) { return; }
	        swiper.slideNext();
	      });
	    }
	    if ($prevEl && $prevEl.length > 0) {
	      $prevEl.on('click', function (e) {
	        e.preventDefault();
	        if (swiper.isBeginning && !swiper.params.loop) { return; }
	        swiper.slidePrev();
	      });
	    }

	    Utils.extend(swiper.navigation, {
	      $nextEl: $nextEl,
	      nextEl: $nextEl && $nextEl[0],
	      $prevEl: $prevEl,
	      prevEl: $prevEl && $prevEl[0],
	    });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;
	    if ($nextEl && $nextEl.length) {
	      $nextEl.off('click');
	      $nextEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	    if ($prevEl && $prevEl.length) {
	      $prevEl.off('click');
	      $prevEl.removeClass(swiper.params.navigation.disabledClass);
	    }
	  },
	};

	var Navigation$1 = {
	  name: 'navigation',
	  params: {
	    navigation: {
	      nextEl: null,
	      prevEl: null,

	      hideOnClick: false,
	      disabledClass: 'swiper-button-disabled',
	      hiddenClass: 'swiper-button-hidden',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      navigation: {
	        init: Navigation.init.bind(swiper),
	        update: Navigation.update.bind(swiper),
	        destroy: Navigation.destroy.bind(swiper),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.navigation.init();
	      swiper.navigation.update();
	    },
	    toEdge: function toEdge() {
	      var swiper = this;
	      swiper.navigation.update();
	    },
	    fromEdge: function fromEdge() {
	      var swiper = this;
	      swiper.navigation.update();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.navigation.destroy();
	    },
	    click: function click(e) {
	      var swiper = this;
	      var ref = swiper.navigation;
	      var $nextEl = ref.$nextEl;
	      var $prevEl = ref.$prevEl;
	      if (
	        swiper.params.navigation.hideOnClick &&
	        !$$1$1(e.target).is($prevEl) &&
	        !$$1$1(e.target).is($nextEl)
	      ) {
	        if ($nextEl) { $nextEl.toggleClass(swiper.params.navigation.hiddenClass); }
	        if ($prevEl) { $prevEl.toggleClass(swiper.params.navigation.hiddenClass); }
	      }
	    },
	  },
	};

	var Pagination = {
	  update: function update() {
	    // Render || Update Pagination bullets/items
	    var swiper = this;
	    var rtl = swiper.rtl;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
	    var $el = swiper.pagination.$el;
	    // Current/Total
	    var current;
	    var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	    if (swiper.params.loop) {
	      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
	      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
	        current -= (slidesLength - (swiper.loopedSlides * 2));
	      }
	      if (current > total - 1) { current -= total; }
	      if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }
	    } else if (typeof swiper.snapIndex !== 'undefined') {
	      current = swiper.snapIndex;
	    } else {
	      current = swiper.activeIndex || 0;
	    }
	    // Types
	    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
	      var bullets = swiper.pagination.bullets;
	      if (params.dynamicBullets) {
	        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
	        $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * 5) + "px"));
	      }
	      bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev"));
	      if ($el.length > 1) {
	        bullets.each(function (index, bullet) {
	          var $bullet = $$1$1(bullet);
	          if ($bullet.index() === current) {
	            $bullet.addClass(params.bulletActiveClass);
	            if (params.dynamicBullets) {
	              $bullet
	                .prev()
	                .addClass(((params.bulletActiveClass) + "-prev"))
	                .prev()
	                .addClass(((params.bulletActiveClass) + "-prev-prev"));
	              $bullet
	                .next()
	                .addClass(((params.bulletActiveClass) + "-next"))
	                .next()
	                .addClass(((params.bulletActiveClass) + "-next-next"));
	            }
	          }
	        });
	      } else {
	        var $bullet = bullets.eq(current);
	        $bullet.addClass(params.bulletActiveClass);
	        if (params.dynamicBullets) {
	          $bullet
	            .prev()
	            .addClass(((params.bulletActiveClass) + "-prev"))
	            .prev()
	            .addClass(((params.bulletActiveClass) + "-prev-prev"));
	          $bullet
	            .next()
	            .addClass(((params.bulletActiveClass) + "-next"))
	            .next()
	            .addClass(((params.bulletActiveClass) + "-next-next"));
	        }
	      }
	      if (params.dynamicBullets) {
	        var dynamicBulletsLength = Math.min(bullets.length, 5);
	        var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (current * swiper.pagination.bulletSize);
	        var offsetProp = rtl ? 'right' : 'left';
	        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));
	      }
	    }
	    if (params.type === 'fraction') {
	      $el.find(("." + (params.currentClass))).text(current + 1);
	      $el.find(("." + (params.totalClass))).text(total);
	    }
	    if (params.type === 'progressbar') {
	      var scale = (current + 1) / total;
	      var scaleX = scale;
	      var scaleY = 1;
	      if (!swiper.isHorizontal()) {
	        scaleY = scale;
	        scaleX = 1;
	      }
	      $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);
	    }
	    if (params.type === 'custom' && params.renderCustom) {
	      $el.html(params.renderCustom(swiper, current + 1, total));
	      swiper.emit('paginationRender', swiper, $el[0]);
	    } else {
	      swiper.emit('paginationUpdate', swiper, $el[0]);
	    }
	  },
	  render: function render() {
	    // Render Container
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

	    var $el = swiper.pagination.$el;
	    var paginationHTML = '';
	    if (params.type === 'bullets') {
	      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
	      for (var i = 0; i < numberOfBullets; i += 1) {
	        if (params.renderBullet) {
	          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
	        } else {
	          paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";
	        }
	      }
	      $el.html(paginationHTML);
	      swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));
	    }
	    if (params.type === 'fraction') {
	      if (params.renderFraction) {
	        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
	      } else {
	        paginationHTML =
	        "<span class=\"" + (params.currentClass) + "\"></span>" +
	        ' / ' +
	        "<span class=\"" + (params.totalClass) + "\"></span>";
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type === 'progressbar') {
	      if (params.renderProgressbar) {
	        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
	      } else {
	        paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";
	      }
	      $el.html(paginationHTML);
	    }
	    if (params.type !== 'custom') {
	      swiper.emit('paginationRender', swiper.pagination.$el[0]);
	    }
	  },
	  init: function init() {
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el) { return; }

	    var $el = $$1$1(params.el);
	    if ($el.length === 0) { return; }

	    if (
	      swiper.params.uniqueNavElements &&
	      typeof params.el === 'string' &&
	      $el.length > 1 &&
	      swiper.$el.find(params.el).length === 1
	    ) {
	      $el = swiper.$el.find(params.el);
	    }

	    if (params.type === 'bullets' && params.clickable) {
	      $el.addClass(params.clickableClass);
	    }

	    $el.addClass(params.modifierClass + params.type);

	    if (params.type === 'bullets' && params.dynamicBullets) {
	      $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));
	    }

	    if (params.clickable) {
	      $el.on('click', ("." + (params.bulletClass)), function onClick(e) {
	        e.preventDefault();
	        var index = $$1$1(this).index() * swiper.params.slidesPerGroup;
	        if (swiper.params.loop) { index += swiper.loopedSlides; }
	        swiper.slideTo(index);
	      });
	    }

	    Utils.extend(swiper.pagination, {
	      $el: $el,
	      el: $el[0],
	    });
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    var params = swiper.params.pagination;
	    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }
	    var $el = swiper.pagination.$el;

	    $el.removeClass(params.hiddenClass);
	    $el.removeClass(params.modifierClass + params.type);
	    if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }
	    if (params.clickable) {
	      $el.off('click', ("." + (params.bulletClass)));
	    }
	  },
	};

	var Pagination$1 = {
	  name: 'pagination',
	  params: {
	    pagination: {
	      el: null,
	      bulletElement: 'span',
	      clickable: false,
	      hideOnClick: false,
	      renderBullet: null,
	      renderProgressbar: null,
	      renderFraction: null,
	      renderCustom: null,
	      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
	      dynamicBullets: false,

	      bulletClass: 'swiper-pagination-bullet',
	      bulletActiveClass: 'swiper-pagination-bullet-active',
	      modifierClass: 'swiper-pagination-', // NEW
	      currentClass: 'swiper-pagination-current',
	      totalClass: 'swiper-pagination-total',
	      hiddenClass: 'swiper-pagination-hidden',
	      progressbarFillClass: 'swiper-pagination-progressbar-fill',
	      clickableClass: 'swiper-pagination-clickable', // NEW
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      pagination: {
	        init: Pagination.init.bind(swiper),
	        render: Pagination.render.bind(swiper),
	        update: Pagination.update.bind(swiper),
	        destroy: Pagination.destroy.bind(swiper),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.pagination.init();
	      swiper.pagination.render();
	      swiper.pagination.update();
	    },
	    activeIndexChange: function activeIndexChange() {
	      var swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.update();
	      } else if (typeof swiper.snapIndex === 'undefined') {
	        swiper.pagination.update();
	      }
	    },
	    snapIndexChange: function snapIndexChange() {
	      var swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.update();
	      }
	    },
	    slidesLengthChange: function slidesLengthChange() {
	      var swiper = this;
	      if (swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    snapGridLengthChange: function snapGridLengthChange() {
	      var swiper = this;
	      if (!swiper.params.loop) {
	        swiper.pagination.render();
	        swiper.pagination.update();
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.pagination.destroy();
	    },
	    click: function click(e) {
	      var swiper = this;
	      if (
	        swiper.params.pagination.el &&
	        swiper.params.pagination.hideOnClick &&
	        swiper.pagination.$el.length > 0 &&
	        !$$1$1(e.target).hasClass(swiper.params.pagination.bulletClass)
	      ) {
	        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
	      }
	    },
	  },
	};

	var Scrollbar = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var rtl = swiper.rtl;
	    var progress = swiper.progress;
	    var dragSize = scrollbar.dragSize;
	    var trackSize = scrollbar.trackSize;
	    var $dragEl = scrollbar.$dragEl;
	    var $el = scrollbar.$el;
	    var params = swiper.params.scrollbar;

	    var newSize = dragSize;
	    var newPos = (trackSize - dragSize) * progress;
	    if (rtl && swiper.isHorizontal()) {
	      newPos = -newPos;
	      if (newPos > 0) {
	        newSize = dragSize - newPos;
	        newPos = 0;
	      } else if (-newPos + dragSize > trackSize) {
	        newSize = trackSize + newPos;
	      }
	    } else if (newPos < 0) {
	      newSize = dragSize + newPos;
	      newPos = 0;
	    } else if (newPos + dragSize > trackSize) {
	      newSize = trackSize - newPos;
	    }
	    if (swiper.isHorizontal()) {
	      if (Support.transforms3d) {
	        $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));
	      } else {
	        $dragEl.transform(("translateX(" + newPos + "px)"));
	      }
	      $dragEl[0].style.width = newSize + "px";
	    } else {
	      if (Support.transforms3d) {
	        $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));
	      } else {
	        $dragEl.transform(("translateY(" + newPos + "px)"));
	      }
	      $dragEl[0].style.height = newSize + "px";
	    }
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.timeout);
	      $el[0].style.opacity = 1;
	      swiper.scrollbar.timeout = setTimeout(function () {
	        $el[0].style.opacity = 0;
	        $el.transition(400);
	      }, 1000);
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }
	    swiper.scrollbar.$dragEl.transition(duration);
	  },
	  updateSize: function updateSize() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }

	    var scrollbar = swiper.scrollbar;
	    var $dragEl = scrollbar.$dragEl;
	    var $el = scrollbar.$el;

	    $dragEl[0].style.width = '';
	    $dragEl[0].style.height = '';
	    var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

	    var divider = swiper.size / swiper.virtualSize;
	    var moveDivider = divider * (trackSize / swiper.size);
	    var dragSize;
	    if (swiper.params.scrollbar.dragSize === 'auto') {
	      dragSize = trackSize * divider;
	    } else {
	      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
	    }

	    if (swiper.isHorizontal()) {
	      $dragEl[0].style.width = dragSize + "px";
	    } else {
	      $dragEl[0].style.height = dragSize + "px";
	    }

	    if (divider >= 1) {
	      $el[0].style.display = 'none';
	    } else {
	      $el[0].style.display = '';
	    }
	    if (swiper.params.scrollbarHide) {
	      $el[0].style.opacity = 0;
	    }
	    Utils.extend(scrollbar, {
	      trackSize: trackSize,
	      divider: divider,
	      moveDivider: moveDivider,
	      dragSize: dragSize,
	    });
	  },
	  setDragPosition: function setDragPosition(e) {
	    var swiper = this;
	    var scrollbar = swiper.scrollbar;
	    var $el = scrollbar.$el;
	    var dragSize = scrollbar.dragSize;
	    var trackSize = scrollbar.trackSize;

	    var pointerPosition;
	    if (swiper.isHorizontal()) {
	      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
	    } else {
	      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
	    }
	    var positionRatio;
	    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
	    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
	    if (swiper.rtl) {
	      positionRatio = 1 - positionRatio;
	    }

	    var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

	    swiper.updateProgress(position);
	    swiper.setTranslate(position);
	    swiper.updateActiveIndex();
	    swiper.updateSlidesClasses();
	  },
	  onDragStart: function onDragStart(e) {
	    var swiper = this;
	    var params = swiper.params.scrollbar;
	    var scrollbar = swiper.scrollbar;
	    var $wrapperEl = swiper.$wrapperEl;
	    var $el = scrollbar.$el;
	    var $dragEl = scrollbar.$dragEl;
	    swiper.scrollbar.isTouched = true;
	    e.preventDefault();
	    e.stopPropagation();

	    $wrapperEl.transition(100);
	    $dragEl.transition(100);
	    scrollbar.setDragPosition(e);

	    clearTimeout(swiper.scrollbar.dragTimeout);

	    $el.transition(0);
	    if (params.hide) {
	      $el.css('opacity', 1);
	    }
	    swiper.emit('scrollbarDragStart', e);
	  },
	  onDragMove: function onDragMove(e) {
	    var swiper = this;
	    var scrollbar = swiper.scrollbar;
	    var $wrapperEl = swiper.$wrapperEl;
	    var $el = scrollbar.$el;
	    var $dragEl = scrollbar.$dragEl;

	    if (!swiper.scrollbar.isTouched) { return; }
	    if (e.preventDefault) { e.preventDefault(); }
	    else { e.returnValue = false; }
	    scrollbar.setDragPosition(e);
	    $wrapperEl.transition(0);
	    $el.transition(0);
	    $dragEl.transition(0);
	    swiper.emit('scrollbarDragMove', e);
	  },
	  onDragEnd: function onDragEnd(e) {
	    var swiper = this;

	    var params = swiper.params.scrollbar;
	    var scrollbar = swiper.scrollbar;
	    var $el = scrollbar.$el;

	    if (!swiper.scrollbar.isTouched) { return; }
	    swiper.scrollbar.isTouched = false;
	    if (params.hide) {
	      clearTimeout(swiper.scrollbar.dragTimeout);
	      swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
	        $el.css('opacity', 0);
	        $el.transition(400);
	      }, 1000);
	    }
	    swiper.emit('scrollbarDragEnd', e);
	    if (params.snapOnRelease) {
	      swiper.slideReset();
	    }
	  },
	  enableDraggable: function enableDraggable() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var $el = scrollbar.$el;
	    var target = Support.touch ? $el[0] : document;
	    $el.on(swiper.scrollbar.dragEvents.start, swiper.scrollbar.onDragStart);
	    $$1$1(target).on(swiper.scrollbar.dragEvents.move, swiper.scrollbar.onDragMove);
	    $$1$1(target).on(swiper.scrollbar.dragEvents.end, swiper.scrollbar.onDragEnd);
	  },
	  disableDraggable: function disableDraggable() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var $el = scrollbar.$el;
	    var target = Support.touch ? $el[0] : document;
	    $el.off(swiper.scrollbar.dragEvents.start);
	    $$1$1(target).off(swiper.scrollbar.dragEvents.move);
	    $$1$1(target).off(swiper.scrollbar.dragEvents.end);
	  },
	  init: function init() {
	    var swiper = this;
	    if (!swiper.params.scrollbar.el) { return; }
	    var scrollbar = swiper.scrollbar;
	    var $swiperEl = swiper.$el;
	    var touchEvents = swiper.touchEvents;
	    var params = swiper.params.scrollbar;

	    var $el = $$1$1(params.el);
	    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
	      $el = $swiperEl.find(params.el);
	    }

	    var $dragEl = $el.find('.swiper-scrollbar-drag');
	    if ($dragEl.length === 0) {
	      $dragEl = $$1$1('<div class="swiper-scrollbar-drag"></div>');
	      $el.append($dragEl);
	    }

	    swiper.scrollbar.dragEvents = (function dragEvents() {
	      if ((swiper.params.simulateTouch === false && !Support.touch)) {
	        return {
	          start: 'mousedown',
	          move: 'mousemove',
	          end: 'mouseup',
	        };
	      }
	      return touchEvents;
	    }());

	    Utils.extend(scrollbar, {
	      $el: $el,
	      el: $el[0],
	      $dragEl: $dragEl,
	      dragEl: $dragEl[0],
	    });

	    if (params.draggable) {
	      scrollbar.enableDraggable();
	    }
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    swiper.scrollbar.disableDraggable();
	  },
	};

	var Scrollbar$1 = {
	  name: 'scrollbar',
	  params: {
	    scrollbar: {
	      el: null,
	      dragSize: 'auto',
	      hide: false,
	      draggable: false,
	      snapOnRelease: true,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      scrollbar: {
	        init: Scrollbar.init.bind(swiper),
	        destroy: Scrollbar.destroy.bind(swiper),
	        updateSize: Scrollbar.updateSize.bind(swiper),
	        setTranslate: Scrollbar.setTranslate.bind(swiper),
	        setTransition: Scrollbar.setTransition.bind(swiper),
	        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
	        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
	        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
	        onDragStart: Scrollbar.onDragStart.bind(swiper),
	        onDragMove: Scrollbar.onDragMove.bind(swiper),
	        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
	        isTouched: false,
	        timeout: null,
	        dragTimeout: null,
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      swiper.scrollbar.init();
	      swiper.scrollbar.updateSize();
	      swiper.scrollbar.setTranslate();
	    },
	    update: function update() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    resize: function resize() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    observerUpdate: function observerUpdate() {
	      var swiper = this;
	      swiper.scrollbar.updateSize();
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      swiper.scrollbar.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      swiper.scrollbar.setTransition(duration);
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.scrollbar.destroy();
	    },
	  },
	};

	var Parallax = {
	  setTransform: function setTransform(el, progress) {
	    var swiper = this;
	    var rtl = swiper.rtl;

	    var $el = $$1$1(el);
	    var rtlFactor = rtl ? -1 : 1;

	    var p = $el.attr('data-swiper-parallax') || '0';
	    var x = $el.attr('data-swiper-parallax-x');
	    var y = $el.attr('data-swiper-parallax-y');
	    var scale = $el.attr('data-swiper-parallax-scale');
	    var opacity = $el.attr('data-swiper-parallax-opacity');

	    if (x || y) {
	      x = x || '0';
	      y = y || '0';
	    } else if (swiper.isHorizontal()) {
	      x = p;
	      y = '0';
	    } else {
	      y = p;
	      x = '0';
	    }

	    if ((x).indexOf('%') >= 0) {
	      x = (parseInt(x, 10) * progress * rtlFactor) + "%";
	    } else {
	      x = (x * progress * rtlFactor) + "px";
	    }
	    if ((y).indexOf('%') >= 0) {
	      y = (parseInt(y, 10) * progress) + "%";
	    } else {
	      y = (y * progress) + "px";
	    }

	    if (typeof opacity !== 'undefined' && opacity !== null) {
	      var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
	      $el[0].style.opacity = currentOpacity;
	    }
	    if (typeof scale === 'undefined' || scale === null) {
	      $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));
	    } else {
	      var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
	      $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));
	    }
	  },
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var $el = swiper.$el;
	    var slides = swiper.slides;
	    var progress = swiper.progress;
	    var snapGrid = swiper.snapGrid;
	    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	      .each(function (index, el) {
	        swiper.parallax.setTransform(el, progress);
	      });
	    slides.each(function (slideIndex, slideEl) {
	      var slideProgress = slideEl.progress;
	      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
	        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
	      }
	      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
	      $$1$1(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	        .each(function (index, el) {
	          swiper.parallax.setTransform(el, slideProgress);
	        });
	    });
	  },
	  setTransition: function setTransition(duration) {
	    if ( duration === void 0 ) duration = this.params.speed;

	    var swiper = this;
	    var $el = swiper.$el;
	    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
	      .each(function (index, parallaxEl) {
	        var $parallaxEl = $$1$1(parallaxEl);
	        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
	        if (duration === 0) { parallaxDuration = 0; }
	        $parallaxEl.transition(parallaxDuration);
	      });
	  },
	};

	var Parallax$1 = {
	  name: 'parallax',
	  params: {
	    parallax: {
	      enabled: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      parallax: {
	        setTransform: Parallax.setTransform.bind(swiper),
	        setTranslate: Parallax.setTranslate.bind(swiper),
	        setTransition: Parallax.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      swiper.params.watchSlidesProgress = true;
	    },
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.parallax) { return; }
	      swiper.parallax.setTranslate();
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (!swiper.params.parallax) { return; }
	      swiper.parallax.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (!swiper.params.parallax) { return; }
	      swiper.parallax.setTransition(duration);
	    },
	  },
	};

	var Zoom = {
	  // Calc Scale From Multi-touches
	  getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
	    if (e.targetTouches.length < 2) { return 1; }
	    var x1 = e.targetTouches[0].pageX;
	    var y1 = e.targetTouches[0].pageY;
	    var x2 = e.targetTouches[1].pageX;
	    var y2 = e.targetTouches[1].pageY;
	    var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));
	    return distance;
	  },
	  // Events
	  onGestureStart: function onGestureStart(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    zoom.fakeGestureTouched = false;
	    zoom.fakeGestureMoved = false;
	    if (!Support.gestures) {
	      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
	        return;
	      }
	      zoom.fakeGestureTouched = true;
	      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$slideEl || !gesture.$slideEl.length) {
	      gesture.$slideEl = $$1$1(this);
	      if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	      if (gesture.$imageWrapEl.length === 0) {
	        gesture.$imageEl = undefined;
	        return;
	      }
	    }
	    gesture.$imageEl.transition(0);
	    swiper.zoom.isScaling = true;
	  },
	  onGestureChange: function onGestureChange(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (!Support.gestures) {
	      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
	        return;
	      }
	      zoom.fakeGestureMoved = true;
	      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (Support.gestures) {
	      swiper.zoom.scale = e.scale * zoom.currentScale;
	    } else {
	      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
	    }
	    if (zoom.scale > gesture.maxRatio) {
	      zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));
	    }
	    if (zoom.scale < params.minRatio) {
	      zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));
	    }
	    gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	  },
	  onGestureEnd: function onGestureEnd(e) {
	    var swiper = this;
	    var params = swiper.params.zoom;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (!Support.gestures) {
	      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
	        return;
	      }
	      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
	        return;
	      }
	      zoom.fakeGestureTouched = false;
	      zoom.fakeGestureMoved = false;
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
	    gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	    zoom.currentScale = zoom.scale;
	    zoom.isScaling = false;
	    if (zoom.scale === 1) { gesture.$slideEl = undefined; }
	  },
	  onTouchStart: function onTouchStart(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (image.isTouched) { return; }
	    if (Device.android) { e.preventDefault(); }
	    image.isTouched = true;
	    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	  },
	  onTouchMove: function onTouchMove(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    var velocity = zoom.velocity;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    swiper.allowClick = false;
	    if (!image.isTouched || !gesture.$slideEl) { return; }

	    if (!image.isMoved) {
	      image.width = gesture.$imageEl[0].offsetWidth;
	      image.height = gesture.$imageEl[0].offsetHeight;
	      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
	      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
	      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
	      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
	      gesture.$imageWrapEl.transition(0);
	      if (swiper.rtl) { image.startX = -image.startX; }
	      if (swiper.rtl) { image.startY = -image.startY; }
	    }
	    // Define if we need image drag
	    var scaledWidth = image.width * zoom.scale;
	    var scaledHeight = image.height * zoom.scale;

	    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }

	    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	    image.maxY = -image.minY;

	    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

	    if (!image.isMoved && !zoom.isScaling) {
	      if (
	        swiper.isHorizontal() &&
	        (
	          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||
	          (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
	        )
	      ) {
	        image.isTouched = false;
	        return;
	      } else if (
	        !swiper.isHorizontal() &&
	        (
	          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||
	          (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
	        )
	      ) {
	        image.isTouched = false;
	        return;
	      }
	    }
	    e.preventDefault();
	    e.stopPropagation();

	    image.isMoved = true;
	    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
	    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

	    if (image.currentX < image.minX) {
	      image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));
	    }
	    if (image.currentX > image.maxX) {
	      image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));
	    }

	    if (image.currentY < image.minY) {
	      image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));
	    }
	    if (image.currentY > image.maxY) {
	      image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));
	    }

	    // Velocity
	    if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }
	    if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }
	    if (!velocity.prevTime) { velocity.prevTime = Date.now(); }
	    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
	    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
	    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }
	    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }
	    velocity.prevPositionX = image.touchesCurrent.x;
	    velocity.prevPositionY = image.touchesCurrent.y;
	    velocity.prevTime = Date.now();

	    gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	  },
	  onTouchEnd: function onTouchEnd() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;
	    var velocity = zoom.velocity;
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }
	    if (!image.isTouched || !image.isMoved) {
	      image.isTouched = false;
	      image.isMoved = false;
	      return;
	    }
	    image.isTouched = false;
	    image.isMoved = false;
	    var momentumDurationX = 300;
	    var momentumDurationY = 300;
	    var momentumDistanceX = velocity.x * momentumDurationX;
	    var newPositionX = image.currentX + momentumDistanceX;
	    var momentumDistanceY = velocity.y * momentumDurationY;
	    var newPositionY = image.currentY + momentumDistanceY;

	    // Fix duration
	    if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }
	    if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }
	    var momentumDuration = Math.max(momentumDurationX, momentumDurationY);

	    image.currentX = newPositionX;
	    image.currentY = newPositionY;

	    // Define if we need image drag
	    var scaledWidth = image.width * zoom.scale;
	    var scaledHeight = image.height * zoom.scale;
	    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
	    image.maxX = -image.minX;
	    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
	    image.maxY = -image.minY;
	    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
	    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

	    gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));
	  },
	  onTransitionEnd: function onTransitionEnd() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    var gesture = zoom.gesture;
	    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
	      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
	      gesture.$imageWrapEl.transform('translate3d(0,0,0)');
	      gesture.$slideEl = undefined;
	      gesture.$imageEl = undefined;
	      gesture.$imageWrapEl = undefined;

	      zoom.scale = 1;
	      zoom.currentScale = 1;
	    }
	  },
	  // Toggle Zoom
	  toggle: function toggle(e) {
	    var swiper = this;
	    var zoom = swiper.zoom;

	    if (zoom.scale && zoom.scale !== 1) {
	      // Zoom Out
	      zoom.out();
	    } else {
	      // Zoom In
	      zoom.in(e);
	    }
	  },
	  in: function in$1(e) {
	    var swiper = this;

	    var zoom = swiper.zoom;
	    var params = swiper.params.zoom;
	    var gesture = zoom.gesture;
	    var image = zoom.image;

	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $$1$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

	    gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));

	    var touchX;
	    var touchY;
	    var offsetX;
	    var offsetY;
	    var diffX;
	    var diffY;
	    var translateX;
	    var translateY;
	    var imageWidth;
	    var imageHeight;
	    var scaledWidth;
	    var scaledHeight;
	    var translateMinX;
	    var translateMinY;
	    var translateMaxX;
	    var translateMaxY;
	    var slideWidth;
	    var slideHeight;

	    if (typeof image.touchesStart.x === 'undefined' && e) {
	      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
	      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
	    } else {
	      touchX = image.touchesStart.x;
	      touchY = image.touchesStart.y;
	    }

	    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
	    if (e) {
	      slideWidth = gesture.$slideEl[0].offsetWidth;
	      slideHeight = gesture.$slideEl[0].offsetHeight;
	      offsetX = gesture.$slideEl.offset().left;
	      offsetY = gesture.$slideEl.offset().top;
	      diffX = (offsetX + (slideWidth / 2)) - touchX;
	      diffY = (offsetY + (slideHeight / 2)) - touchY;

	      imageWidth = gesture.$imageEl[0].offsetWidth;
	      imageHeight = gesture.$imageEl[0].offsetHeight;
	      scaledWidth = imageWidth * zoom.scale;
	      scaledHeight = imageHeight * zoom.scale;

	      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
	      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
	      translateMaxX = -translateMinX;
	      translateMaxY = -translateMinY;

	      translateX = diffX * zoom.scale;
	      translateY = diffY * zoom.scale;

	      if (translateX < translateMinX) {
	        translateX = translateMinX;
	      }
	      if (translateX > translateMaxX) {
	        translateX = translateMaxX;
	      }

	      if (translateY < translateMinY) {
	        translateY = translateMinY;
	      }
	      if (translateY > translateMaxY) {
	        translateY = translateMaxY;
	      }
	    } else {
	      translateX = 0;
	      translateY = 0;
	    }
	    gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));
	    gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));
	  },
	  out: function out() {
	    var swiper = this;

	    var zoom = swiper.zoom;
	    var params = swiper.params.zoom;
	    var gesture = zoom.gesture;

	    if (!gesture.$slideEl) {
	      gesture.$slideEl = swiper.clickedSlide ? $$1$1(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
	      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
	      gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));
	    }
	    if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }

	    zoom.scale = 1;
	    zoom.currentScale = 1;
	    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
	    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
	    gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));
	    gesture.$slideEl = undefined;
	  },
	  // Attach/Detach Events
	  enable: function enable() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    if (zoom.enabled) { return; }
	    zoom.enabled = true;

	    var slides = swiper.slides;

	    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

	    // Scale image
	    if (Support.gestures) {
	      slides.on('gesturestart', zoom.onGestureStart, passiveListener);
	      slides.on('gesturechange', zoom.onGestureChange, passiveListener);
	      slides.on('gestureend', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      slides.on(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);
	      slides.on(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);
	      slides.on(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.slides.each(function (index, slideEl) {
	      var $slideEl = $$1$1(slideEl);
	      if ($slideEl.find(("." + (swiper.params.zoom.containerClass))).length > 0) {
	        $slideEl.on(swiper.touchEvents.move, zoom.onTouchMove);
	      }
	    });
	  },
	  disable: function disable() {
	    var swiper = this;
	    var zoom = swiper.zoom;
	    if (!zoom.enabled) { return; }

	    swiper.zoom.enabled = false;

	    var slides = swiper.slides;

	    var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

	    // Scale image
	    if (Support.gestures) {
	      slides.off('gesturestart', zoom.onGestureStart, passiveListener);
	      slides.off('gesturechange', zoom.onGestureChange, passiveListener);
	      slides.off('gestureend', zoom.onGestureEnd, passiveListener);
	    } else if (swiper.touchEvents.start === 'touchstart') {
	      slides.off(swiper.touchEvents.start, zoom.onGestureStart, passiveListener);
	      slides.off(swiper.touchEvents.move, zoom.onGestureChange, passiveListener);
	      slides.off(swiper.touchEvents.end, zoom.onGestureEnd, passiveListener);
	    }

	    // Move image
	    swiper.slides.each(function (index, slideEl) {
	      var $slideEl = $$1$1(slideEl);
	      if ($slideEl.find(("." + (swiper.params.zoom.containerClass))).length > 0) {
	        $slideEl.off(swiper.touchEvents.move, zoom.onTouchMove);
	      }
	    });
	  },
	};

	var Zoom$1 = {
	  name: 'zoom',
	  params: {
	    zoom: {
	      enabled: false,
	      maxRatio: 3,
	      minRatio: 1,
	      toggle: true,
	      containerClass: 'swiper-zoom-container',
	      zoomedSlideClass: 'swiper-slide-zoomed',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    var zoom = {
	      enabled: false,
	      scale: 1,
	      currentScale: 1,
	      isScaling: false,
	      gesture: {
	        $slideEl: undefined,
	        slideWidth: undefined,
	        slideHeight: undefined,
	        $imageEl: undefined,
	        $imageWrapEl: undefined,
	        maxRatio: 3,
	      },
	      image: {
	        isTouched: undefined,
	        isMoved: undefined,
	        currentX: undefined,
	        currentY: undefined,
	        minX: undefined,
	        minY: undefined,
	        maxX: undefined,
	        maxY: undefined,
	        width: undefined,
	        height: undefined,
	        startX: undefined,
	        startY: undefined,
	        touchesStart: {},
	        touchesCurrent: {},
	      },
	      velocity: {
	        x: undefined,
	        y: undefined,
	        prevPositionX: undefined,
	        prevPositionY: undefined,
	        prevTime: undefined,
	      },
	    };
	    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {
	      zoom[methodName] = Zoom[methodName].bind(swiper);
	    });
	    Utils.extend(swiper, {
	      zoom: zoom,
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.zoom.enabled) {
	        swiper.zoom.enable();
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      swiper.zoom.disable();
	    },
	    touchStart: function touchStart(e) {
	      var swiper = this;
	      if (!swiper.zoom.enabled) { return; }
	      swiper.zoom.onTouchStart(e);
	    },
	    touchEnd: function touchEnd(e) {
	      var swiper = this;
	      if (!swiper.zoom.enabled) { return; }
	      swiper.zoom.onTouchEnd(e);
	    },
	    doubleTap: function doubleTap(e) {
	      var swiper = this;
	      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
	        swiper.zoom.toggle(e);
	      }
	    },
	    transitionEnd: function transitionEnd() {
	      var swiper = this;
	      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
	        swiper.zoom.onTransitionEnd();
	      }
	    },
	  },
	};

	var Lazy$2 = {
	  loadInSlide: function loadInSlide(index, loadInDuplicate) {
	    if ( loadInDuplicate === void 0 ) loadInDuplicate = true;

	    var swiper = this;
	    var params = swiper.params.lazy;
	    if (typeof index === 'undefined') { return; }
	    if (swiper.slides.length === 0) { return; }
	    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;

	    var $slideEl = isVirtual
	      ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))
	      : swiper.slides.eq(index);

	    var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));
	    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
	      $images = $images.add($slideEl[0]);
	    }
	    if ($images.length === 0) { return; }

	    $images.each(function (imageIndex, imageEl) {
	      var $imageEl = $$1$1(imageEl);
	      $imageEl.addClass(params.loadingClass);

	      var background = $imageEl.attr('data-background');
	      var src = $imageEl.attr('data-src');
	      var srcset = $imageEl.attr('data-srcset');
	      var sizes = $imageEl.attr('data-sizes');

	      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {
	        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }
	        if (background) {
	          $imageEl.css('background-image', ("url(\"" + background + "\")"));
	          $imageEl.removeAttr('data-background');
	        } else {
	          if (srcset) {
	            $imageEl.attr('srcset', srcset);
	            $imageEl.removeAttr('data-srcset');
	          }
	          if (sizes) {
	            $imageEl.attr('sizes', sizes);
	            $imageEl.removeAttr('data-sizes');
	          }
	          if (src) {
	            $imageEl.attr('src', src);
	            $imageEl.removeAttr('data-src');
	          }
	        }

	        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
	        $slideEl.find(("." + (params.preloaderClass))).remove();
	        if (swiper.params.loop && loadInDuplicate) {
	          var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
	          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
	            var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));
	            swiper.lazy.loadInSlide(originalSlide.index(), false);
	          } else {
	            var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));
	            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
	          }
	        }
	        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
	      });

	      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
	    });
	  },
	  load: function load() {
	    var swiper = this;
	    var $wrapperEl = swiper.$wrapperEl;
	    var swiperParams = swiper.params;
	    var slides = swiper.slides;
	    var activeIndex = swiper.activeIndex;
	    var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
	    var params = swiperParams.lazy;

	    var slidesPerView = swiperParams.slidesPerView;
	    if (slidesPerView === 'auto') {
	      slidesPerView = 0;
	    }

	    function slideExist(index) {
	      if (isVirtual) {
	        if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {
	          return true;
	        }
	      } else if (slides[index]) { return true; }
	      return false;
	    }
	    function slideIndex(slideEl) {
	      if (isVirtual) {
	        return $$1$1(slideEl).attr('data-swiper-slide-index');
	      }
	      return $$1$1(slideEl).index();
	    }

	    if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }
	    if (swiper.params.watchSlidesVisibility) {
	      $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {
	        var index = isVirtual ? $$1$1(slideEl).attr('data-swiper-slide-index') : $$1$1(slideEl).index();
	        swiper.lazy.loadInSlide(index);
	      });
	    } else if (slidesPerView > 1) {
	      for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
	        if (slideExist(i)) { swiper.lazy.loadInSlide(i); }
	      }
	    } else {
	      swiper.lazy.loadInSlide(activeIndex);
	    }
	    if (params.loadPrevNext) {
	      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
	        var amount = params.loadPrevNextAmount;
	        var spv = slidesPerView;
	        var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
	        var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
	        // Next Slides
	        for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
	          if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }
	        }
	        // Prev Slides
	        for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
	          if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }
	        }
	      } else {
	        var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));
	        if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }

	        var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));
	        if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }
	      }
	    }
	  },
	};

	var Lazy$3 = {
	  name: 'lazy',
	  params: {
	    lazy: {
	      enabled: false,
	      loadPrevNext: false,
	      loadPrevNextAmount: 1,
	      loadOnTransitionStart: false,

	      elementClass: 'swiper-lazy',
	      loadingClass: 'swiper-lazy-loading',
	      loadedClass: 'swiper-lazy-loaded',
	      preloaderClass: 'swiper-lazy-preloader',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      lazy: {
	        initialImageLoaded: false,
	        load: Lazy$2.load.bind(swiper),
	        loadInSlide: Lazy$2.loadInSlide.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
	        swiper.params.preloadImages = false;
	      }
	    },
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
	        swiper.lazy.load();
	      }
	    },
	    scroll: function scroll() {
	      var swiper = this;
	      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
	        swiper.lazy.load();
	      }
	    },
	    resize: function resize() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    scrollbarDragMove: function scrollbarDragMove() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        swiper.lazy.load();
	      }
	    },
	    transitionStart: function transitionStart() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled) {
	        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
	          swiper.lazy.load();
	        }
	      }
	    },
	    transitionEnd: function transitionEnd() {
	      var swiper = this;
	      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
	        swiper.lazy.load();
	      }
	    },
	  },
	};

	/* eslint no-bitwise: ["error", { "allow": [">>"] }] */
	var Controller = {
	  LinearSpline: function LinearSpline(x, y) {
	    var binarySearch = (function search() {
	      var maxIndex;
	      var minIndex;
	      var guess;
	      return function (array, val) {
	        minIndex = -1;
	        maxIndex = array.length;
	        while (maxIndex - minIndex > 1) {
	          guess = maxIndex + minIndex >> 1;
	          if (array[guess] <= val) {
	            minIndex = guess;
	          } else {
	            maxIndex = guess;
	          }
	        }
	        return maxIndex;
	      };
	    }());
	    this.x = x;
	    this.y = y;
	    this.lastIndex = x.length - 1;
	    // Given an x value (x2), return the expected y2 value:
	    // (x1,y1) is the known point before given value,
	    // (x3,y3) is the known point after given value.
	    var i1;
	    var i3;

	    this.interpolate = function interpolate(x2) {
	      if (!x2) { return 0; }

	      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	      i3 = binarySearch(this.x, x2);
	      i1 = i3 - 1;

	      // We have our indexes i1 & i3, so we can calculate already:
	      // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
	      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
	    };
	    return this;
	  },
	  // xxx: for now i will just save one spline function to to
	  getInterpolateFunction: function getInterpolateFunction(c) {
	    var swiper = this;
	    if (!swiper.controller.spline) {
	      swiper.controller.spline = swiper.params.loop ?
	        new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) :
	        new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
	    }
	  },
	  setTranslate: function setTranslate(setTranslate$1, byController) {
	    var swiper = this;
	    var controlled = swiper.controller.control;
	    var multiplier;
	    var controlledTranslate;
	    function setControlledTranslate(c) {
	      // this will create an Interpolate function based on the snapGrids
	      // x is the Grid of the scrolled scroller and y will be the controlled scroller
	      // it makes sense to create this only once and recall it for the interpolation
	      // the function does a lot of value caching for performance
	      var translate = c.rtl && c.params.direction === 'horizontal' ? -swiper.translate : swiper.translate;
	      if (swiper.params.controller.by === 'slide') {
	        swiper.controller.getInterpolateFunction(c);
	        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	        // but it did not work out
	        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
	      }

	      if (!controlledTranslate || swiper.params.controller.by === 'container') {
	        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
	        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
	      }

	      if (swiper.params.controller.inverse) {
	        controlledTranslate = c.maxTranslate() - controlledTranslate;
	      }
	      c.updateProgress(controlledTranslate);
	      c.setTranslate(controlledTranslate, swiper);
	      c.updateActiveIndex();
	      c.updateSlidesClasses();
	    }
	    if (Array.isArray(controlled)) {
	      for (var i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper$2) {
	          setControlledTranslate(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper$2 && byController !== controlled) {
	      setControlledTranslate(controlled);
	    }
	  },
	  setTransition: function setTransition(duration, byController) {
	    var swiper = this;
	    var controlled = swiper.controller.control;
	    var i;
	    function setControlledTransition(c) {
	      c.setTransition(duration, swiper);
	      if (duration !== 0) {
	        c.transitionStart();
	        c.$wrapperEl.transitionEnd(function () {
	          if (!controlled) { return; }
	          if (c.params.loop && swiper.params.controller.by === 'slide') {
	            c.loopFix();
	          }
	          c.transitionEnd();
	        });
	      }
	    }
	    if (Array.isArray(controlled)) {
	      for (i = 0; i < controlled.length; i += 1) {
	        if (controlled[i] !== byController && controlled[i] instanceof Swiper$2) {
	          setControlledTransition(controlled[i]);
	        }
	      }
	    } else if (controlled instanceof Swiper$2 && byController !== controlled) {
	      setControlledTransition(controlled);
	    }
	  },
	};
	var Controller$1 = {
	  name: 'controller',
	  params: {
	    controller: {
	      control: undefined,
	      inverse: false,
	      by: 'slide', // or 'container'
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      controller: {
	        control: swiper.params.controller.control,
	        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
	        setTranslate: Controller.setTranslate.bind(swiper),
	        setTransition: Controller.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    update: function update() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    resize: function resize() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    observerUpdate: function observerUpdate() {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      if (swiper.controller.spline) {
	        swiper.controller.spline = undefined;
	        delete swiper.controller.spline;
	      }
	    },
	    setTranslate: function setTranslate(translate, byController) {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      swiper.controller.setTranslate(translate, byController);
	    },
	    setTransition: function setTransition(duration, byController) {
	      var swiper = this;
	      if (!swiper.controller.control) { return; }
	      swiper.controller.setTransition(duration, byController);
	    },
	  },
	};

	var a11y = {
	  makeElFocusable: function makeElFocusable($el) {
	    $el.attr('tabIndex', '0');
	    return $el;
	  },
	  addElRole: function addElRole($el, role) {
	    $el.attr('role', role);
	    return $el;
	  },
	  addElLabel: function addElLabel($el, label) {
	    $el.attr('aria-label', label);
	    return $el;
	  },
	  disableEl: function disableEl($el) {
	    $el.attr('aria-disabled', true);
	    return $el;
	  },
	  enableEl: function enableEl($el) {
	    $el.attr('aria-disabled', false);
	    return $el;
	  },
	  onEnterKey: function onEnterKey(e) {
	    var swiper = this;
	    var params = swiper.params.a11y;
	    if (e.keyCode !== 13) { return; }
	    var $targetEl = $$1$1(e.target);
	    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
	      if (!(swiper.isEnd && !swiper.params.loop)) {
	        swiper.slideNext();
	      }
	      if (swiper.isEnd) {
	        swiper.a11y.notify(params.lastSlideMessage);
	      } else {
	        swiper.a11y.notify(params.nextSlideMessage);
	      }
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
	      if (!(swiper.isBeginning && !swiper.params.loop)) {
	        swiper.slidePrev();
	      }
	      if (swiper.isBeginning) {
	        swiper.a11y.notify(params.firstSlideMessage);
	      } else {
	        swiper.a11y.notify(params.prevSlideMessage);
	      }
	    }
	    if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {
	      $targetEl[0].click();
	    }
	  },
	  notify: function notify(message) {
	    var swiper = this;
	    var notification = swiper.a11y.liveRegion;
	    if (notification.length === 0) { return; }
	    notification.html('');
	    notification.html(message);
	  },
	  updateNavigation: function updateNavigation() {
	    var swiper = this;

	    if (swiper.params.loop) { return; }
	    var ref = swiper.navigation;
	    var $nextEl = ref.$nextEl;
	    var $prevEl = ref.$prevEl;

	    if ($prevEl && $prevEl.length > 0) {
	      if (swiper.isBeginning) {
	        swiper.a11y.disableEl($prevEl);
	      } else {
	        swiper.a11y.enableEl($prevEl);
	      }
	    }
	    if ($nextEl && $nextEl.length > 0) {
	      if (swiper.isEnd) {
	        swiper.a11y.disableEl($nextEl);
	      } else {
	        swiper.a11y.enableEl($nextEl);
	      }
	    }
	  },
	  updatePagination: function updatePagination() {
	    var swiper = this;
	    var params = swiper.params.a11y;
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
	        var $bulletEl = $$1$1(bulletEl);
	        swiper.a11y.makeElFocusable($bulletEl);
	        swiper.a11y.addElRole($bulletEl, 'button');
	        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
	      });
	    }
	  },
	  init: function init() {
	    var swiper = this;

	    swiper.$el.append(swiper.a11y.liveRegion);

	    // Navigation
	    var params = swiper.params.a11y;
	    var $nextEl;
	    var $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      swiper.a11y.makeElFocusable($nextEl);
	      swiper.a11y.addElRole($nextEl, 'button');
	      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
	      $nextEl.on('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      swiper.a11y.makeElFocusable($prevEl);
	      swiper.a11y.addElRole($prevEl, 'button');
	      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
	      $prevEl.on('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	    }
	  },
	  destroy: function destroy() {
	    var swiper = this;
	    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }

	    var $nextEl;
	    var $prevEl;
	    if (swiper.navigation && swiper.navigation.$nextEl) {
	      $nextEl = swiper.navigation.$nextEl;
	    }
	    if (swiper.navigation && swiper.navigation.$prevEl) {
	      $prevEl = swiper.navigation.$prevEl;
	    }
	    if ($nextEl) {
	      $nextEl.off('keydown', swiper.a11y.onEnterKey);
	    }
	    if ($prevEl) {
	      $prevEl.off('keydown', swiper.a11y.onEnterKey);
	    }

	    // Pagination
	    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
	      swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);
	    }
	  },
	};
	var A11y = {
	  name: 'a11y',
	  params: {
	    a11y: {
	      enabled: false,
	      notificationClass: 'swiper-notification',
	      prevSlideMessage: 'Previous slide',
	      nextSlideMessage: 'Next slide',
	      firstSlideMessage: 'This is the first slide',
	      lastSlideMessage: 'This is the last slide',
	      paginationBulletMessage: 'Go to slide {{index}}',
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      a11y: {
	        liveRegion: $$1$1(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),
	      },
	    });
	    Object.keys(a11y).forEach(function (methodName) {
	      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.init();
	      swiper.a11y.updateNavigation();
	    },
	    toEdge: function toEdge() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updateNavigation();
	    },
	    fromEdge: function fromEdge() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updateNavigation();
	    },
	    paginationUpdate: function paginationUpdate() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.updatePagination();
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (!swiper.params.a11y.enabled) { return; }
	      swiper.a11y.destroy();
	    },
	  },
	};

	var Autoplay = {
	  run: function run() {
	    var swiper = this;
	    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
	    var delay = swiper.params.autoplay.delay;
	    if ($activeSlideEl.attr('data-swiper-autoplay')) {
	      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
	    }
	    swiper.autoplay.timeout = Utils.nextTick(function () {
	      if (swiper.params.loop) {
	        swiper.loopFix();
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.isEnd) {
	        swiper.slideNext(swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else if (!swiper.params.autoplay.stopOnLastSlide) {
	        swiper.slideTo(0, swiper.params.speed, true, true);
	        swiper.emit('autoplay');
	      } else {
	        swiper.autoplay.stop();
	      }
	    }, delay);
	  },
	  start: function start() {
	    var swiper = this;
	    if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }
	    if (swiper.autoplay.running) { return false; }
	    swiper.autoplay.running = true;
	    swiper.emit('autoplayStart');
	    swiper.autoplay.run();
	    return true;
	  },
	  stop: function stop() {
	    var swiper = this;
	    if (!swiper.autoplay.running) { return false; }
	    if (typeof swiper.autoplay.timeout === 'undefined') { return false; }

	    if (swiper.autoplay.timeout) {
	      clearTimeout(swiper.autoplay.timeout);
	      swiper.autoplay.timeout = undefined;
	    }
	    swiper.autoplay.running = false;
	    swiper.emit('autoplayStop');
	    return true;
	  },
	  pause: function pause(speed) {
	    var swiper = this;
	    if (!swiper.autoplay.running) { return; }
	    if (swiper.autoplay.paused) { return; }
	    if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }
	    swiper.autoplay.paused = true;
	    if (speed === 0) {
	      swiper.autoplay.paused = false;
	      swiper.autoplay.run();
	    } else {
	      swiper.$wrapperEl.transitionEnd(function () {
	        if (!swiper || swiper.destroyed) { return; }
	        swiper.autoplay.paused = false;
	        if (!swiper.autoplay.running) {
	          swiper.autoplay.stop();
	        } else {
	          swiper.autoplay.run();
	        }
	      });
	    }
	  },
	};

	var Autoplay$1 = {
	  name: 'autoplay',
	  params: {
	    autoplay: {
	      enabled: false,
	      delay: 3000,
	      disableOnInteraction: true,
	      stopOnLastSlide: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      autoplay: {
	        running: false,
	        paused: false,
	        run: Autoplay.run.bind(swiper),
	        start: Autoplay.start.bind(swiper),
	        stop: Autoplay.stop.bind(swiper),
	        pause: Autoplay.pause.bind(swiper),
	      },
	    });
	  },
	  on: {
	    init: function init() {
	      var swiper = this;
	      if (swiper.params.autoplay.enabled) {
	        swiper.autoplay.start();
	      }
	    },
	    beforeTransitionStart: function beforeTransitionStart(speed, internal) {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        if (internal || !swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.pause(speed);
	        } else {
	          swiper.autoplay.stop();
	        }
	      }
	    },
	    sliderFirstMove: function sliderFirstMove() {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        if (swiper.params.autoplay.disableOnInteraction) {
	          swiper.autoplay.stop();
	        } else {
	          swiper.autoplay.pause();
	        }
	      }
	    },
	    destroy: function destroy() {
	      var swiper = this;
	      if (swiper.autoplay.running) {
	        swiper.autoplay.stop();
	      }
	    },
	  },
	};

	var Fade = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var slides = swiper.slides;
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = swiper.slides.eq(i);
	      var offset = $slideEl[0].swiperSlideOffset;
	      var tx = -offset;
	      if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }
	      var ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	      }
	      var slideOpacity = swiper.params.fadeEffect.crossFade ?
	        Math.max(1 - Math.abs($slideEl[0].progress), 0) :
	        1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
	      $slideEl
	        .css({
	          opacity: slideOpacity,
	        })
	        .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var slides = swiper.slides;
	    var $wrapperEl = swiper.$wrapperEl;
	    slides.transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      var eventTriggered = false;
	      slides.transitionEnd(function () {
	        if (eventTriggered) { return; }
	        if (!swiper || swiper.destroyed) { return; }
	        eventTriggered = true;
	        swiper.animating = false;
	        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (var i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  },
	};

	var EffectFade = {
	  name: 'effect-fade',
	  params: {
	    fadeEffect: {
	      crossFade: false,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      fadeEffect: {
	        setTranslate: Fade.setTranslate.bind(swiper),
	        setTransition: Fade.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.fadeEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'fade') { return; }
	      swiper.fadeEffect.setTransition(duration);
	    },
	  },
	};

	var Cube = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var $el = swiper.$el;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slides = swiper.slides;
	    var swiperWidth = swiper.width;
	    var swiperHeight = swiper.height;
	    var rtl = swiper.rtl;
	    var swiperSize = swiper.size;
	    var params = swiper.params.cubeEffect;
	    var isHorizontal = swiper.isHorizontal();
	    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
	    var wrapperRotate = 0;
	    var $cubeShadowEl;
	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $$1$1('<div class="swiper-cube-shadow"></div>');
	          $wrapperEl.append($cubeShadowEl);
	        }
	        $cubeShadowEl.css({ height: (swiperWidth + "px") });
	      } else {
	        $cubeShadowEl = $el.find('.swiper-cube-shadow');
	        if ($cubeShadowEl.length === 0) {
	          $cubeShadowEl = $$1$1('<div class="swiper-cube-shadow"></div>');
	          $el.append($cubeShadowEl);
	        }
	      }
	    }
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var slideIndex = i;
	      if (isVirtual) {
	        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
	      }
	      var slideAngle = slideIndex * 90;
	      var round = Math.floor(slideAngle / 360);
	      if (rtl) {
	        slideAngle = -slideAngle;
	        round = Math.floor(-slideAngle / 360);
	      }
	      var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      var tx = 0;
	      var ty = 0;
	      var tz = 0;
	      if (slideIndex % 4 === 0) {
	        tx = -round * 4 * swiperSize;
	        tz = 0;
	      } else if ((slideIndex - 1) % 4 === 0) {
	        tx = 0;
	        tz = -round * 4 * swiperSize;
	      } else if ((slideIndex - 2) % 4 === 0) {
	        tx = swiperSize + (round * 4 * swiperSize);
	        tz = swiperSize;
	      } else if ((slideIndex - 3) % 4 === 0) {
	        tx = -swiperSize;
	        tz = (3 * swiperSize) + (swiperSize * 4 * round);
	      }
	      if (rtl) {
	        tx = -tx;
	      }

	      if (!isHorizontal) {
	        ty = tx;
	        tx = 0;
	      }

	      var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
	      if (progress <= 1 && progress > -1) {
	        wrapperRotate = (slideIndex * 90) + (progress * 90);
	        if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }
	      }
	      $slideEl.transform(transform);
	      if (params.slideShadows) {
	        // Set shadows
	        var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $$1$1(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $$1$1(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	      }
	    }
	    $wrapperEl.css({
	      '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	      'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),
	    });

	    if (params.shadow) {
	      if (isHorizontal) {
	        $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));
	      } else {
	        var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
	        var multiplier = 1.5 - (
	          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2) +
	          (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
	        );
	        var scale1 = params.shadowScale;
	        var scale2 = params.shadowScale / multiplier;
	        var offset = params.shadowOffset;
	        $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));
	      }
	    }
	    var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
	    $wrapperEl
	      .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var $el = swiper.$el;
	    var slides = swiper.slides;
	    slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
	      $el.find('.swiper-cube-shadow').transition(duration);
	    }
	  },
	};

	var EffectCube = {
	  name: 'effect-cube',
	  params: {
	    cubeEffect: {
	      slideShadows: true,
	      shadow: true,
	      shadowOffset: 20,
	      shadowScale: 0.94,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      cubeEffect: {
	        setTranslate: Cube.setTranslate.bind(swiper),
	        setTransition: Cube.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        resistanceRatio: 0,
	        spaceBetween: 0,
	        centeredSlides: false,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.cubeEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'cube') { return; }
	      swiper.cubeEffect.setTransition(duration);
	    },
	  },
	};

	var Flip = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var slides = swiper.slides;
	    for (var i = 0; i < slides.length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var progress = $slideEl[0].progress;
	      if (swiper.params.flipEffect.limitRotation) {
	        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
	      }
	      var offset = $slideEl[0].swiperSlideOffset;
	      var rotate = -180 * progress;
	      var rotateY = rotate;
	      var rotateX = 0;
	      var tx = -offset;
	      var ty = 0;
	      if (!swiper.isHorizontal()) {
	        ty = tx;
	        tx = 0;
	        rotateX = -rotateY;
	        rotateY = 0;
	      } else if (swiper.rtl) {
	        rotateY = -rotateY;
	      }

	      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

	      if (swiper.params.flipEffect.slideShadows) {
	        // Set shadows
	        var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if (shadowBefore.length === 0) {
	          shadowBefore = $$1$1(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append(shadowBefore);
	        }
	        if (shadowAfter.length === 0) {
	          shadowAfter = $$1$1(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append(shadowAfter);
	        }
	        if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }
	        if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }
	      }
	      $slideEl
	        .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    var slides = swiper.slides;
	    var activeIndex = swiper.activeIndex;
	    var $wrapperEl = swiper.$wrapperEl;
	    slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	    if (swiper.params.virtualTranslate && duration !== 0) {
	      var eventTriggered = false;
	      // eslint-disable-next-line
	      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
	        if (eventTriggered) { return; }
	        if (!swiper || swiper.destroyed) { return; }
	        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
	        eventTriggered = true;
	        swiper.animating = false;
	        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];
	        for (var i = 0; i < triggerEvents.length; i += 1) {
	          $wrapperEl.trigger(triggerEvents[i]);
	        }
	      });
	    }
	  },
	};

	var EffectFlip = {
	  name: 'effect-flip',
	  params: {
	    flipEffect: {
	      slideShadows: true,
	      limitRotation: true,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      flipEffect: {
	        setTranslate: Flip.setTranslate.bind(swiper),
	        setTransition: Flip.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));
	      var overwriteParams = {
	        slidesPerView: 1,
	        slidesPerColumn: 1,
	        slidesPerGroup: 1,
	        watchSlidesProgress: true,
	        spaceBetween: 0,
	        virtualTranslate: true,
	      };
	      Utils.extend(swiper.params, overwriteParams);
	      Utils.extend(swiper.originalParams, overwriteParams);
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.flipEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'flip') { return; }
	      swiper.flipEffect.setTransition(duration);
	    },
	  },
	};

	var Coverflow = {
	  setTranslate: function setTranslate() {
	    var swiper = this;
	    var swiperWidth = swiper.width;
	    var swiperHeight = swiper.height;
	    var slides = swiper.slides;
	    var $wrapperEl = swiper.$wrapperEl;
	    var slidesSizesGrid = swiper.slidesSizesGrid;
	    var params = swiper.params.coverflowEffect;
	    var isHorizontal = swiper.isHorizontal();
	    var transform = swiper.translate;
	    var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
	    var rotate = isHorizontal ? params.rotate : -params.rotate;
	    var translate = params.depth;
	    // Each slide offset from center
	    for (var i = 0, length = slides.length; i < length; i += 1) {
	      var $slideEl = slides.eq(i);
	      var slideSize = slidesSizesGrid[i];
	      var slideOffset = $slideEl[0].swiperSlideOffset;
	      var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

	      var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
	      var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
	      // var rotateZ = 0
	      var translateZ = -translate * Math.abs(offsetMultiplier);

	      var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
	      var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

	      // Fix for ultra small values
	      if (Math.abs(translateX) < 0.001) { translateX = 0; }
	      if (Math.abs(translateY) < 0.001) { translateY = 0; }
	      if (Math.abs(translateZ) < 0.001) { translateZ = 0; }
	      if (Math.abs(rotateY) < 0.001) { rotateY = 0; }
	      if (Math.abs(rotateX) < 0.001) { rotateX = 0; }

	      var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";

	      $slideEl.transform(slideTransform);
	      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	      if (params.slideShadows) {
	        // Set shadows
	        var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
	        var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
	        if ($shadowBeforeEl.length === 0) {
	          $shadowBeforeEl = $$1$1(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));
	          $slideEl.append($shadowBeforeEl);
	        }
	        if ($shadowAfterEl.length === 0) {
	          $shadowAfterEl = $$1$1(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));
	          $slideEl.append($shadowAfterEl);
	        }
	        if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }
	        if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }
	      }
	    }

	    // Set correct perspective for IE10
	    if (Browser.ie) {
	      var ws = $wrapperEl[0].style;
	      ws.perspectiveOrigin = center + "px 50%";
	    }
	  },
	  setTransition: function setTransition(duration) {
	    var swiper = this;
	    swiper.slides
	      .transition(duration)
	      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
	      .transition(duration);
	  },
	};

	var EffectCoverflow = {
	  name: 'effect-coverflow',
	  params: {
	    coverflowEffect: {
	      rotate: 50,
	      stretch: 0,
	      depth: 100,
	      modifier: 1,
	      slideShadows: true,
	    },
	  },
	  create: function create() {
	    var swiper = this;
	    Utils.extend(swiper, {
	      coverflowEffect: {
	        setTranslate: Coverflow.setTranslate.bind(swiper),
	        setTransition: Coverflow.setTransition.bind(swiper),
	      },
	    });
	  },
	  on: {
	    beforeInit: function beforeInit() {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }

	      swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));
	      swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));

	      swiper.params.watchSlidesProgress = true;
	      swiper.originalParams.watchSlidesProgress = true;
	    },
	    setTranslate: function setTranslate() {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }
	      swiper.coverflowEffect.setTranslate();
	    },
	    setTransition: function setTransition(duration) {
	      var swiper = this;
	      if (swiper.params.effect !== 'coverflow') { return; }
	      swiper.coverflowEffect.setTransition(duration);
	    },
	  },
	};

	// Swiper Class
	// Core Modules
	// Components
	Swiper$2.use([
	  Device$3,
	  Browser$2,
	  Support$3,
	  Resize,
	  Observer$1,
	  Virtual$1,
	  Navigation$1,
	  Pagination$1,
	  Scrollbar$1,
	  Parallax$1,
	  Zoom$1,
	  Lazy$3,
	  Controller$1,
	  A11y,
	  Autoplay$1,
	  EffectFade,
	  EffectCube,
	  EffectFlip,
	  EffectCoverflow ]);

	{
	  if (!window.Swiper) {
	    window.Swiper = Swiper$2;
	  }
	}

	function initSwipers(swiperEl) {
	  var app = this;
	  var $swiperEl = $$1$1(swiperEl);
	  if ($swiperEl.length === 0) { return; }
	  if ($swiperEl[0].swiper) { return; }
	  var initialSlide;
	  var params = {};
	  var isTabs;
	  var isRoutableTabs;
	  if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
	    $swiperEl
	      .addClass('swiper-container')
	      .children('.tabs')
	      .addClass('swiper-wrapper')
	      .children('.tab')
	      .addClass('swiper-slide');
	    initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
	    isTabs = true;
	    isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
	  }
	  if ($swiperEl.attr('data-swiper')) {
	    params = JSON.parse($swiperEl.attr('data-swiper'));
	  } else {
	    params = $swiperEl.dataset();
	    Object.keys(params).forEach(function (key) {
	      var value = params[key];
	      if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
	        try {
	          params[key] = JSON.parse(value);
	        } catch (e) {
	          // not JSON
	        }
	      }
	    });
	  }
	  if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
	    params.initialSlide = initialSlide;
	  }

	  var swiper = app.swiper.create($swiperEl[0], params);
	  if (isTabs) {
	    swiper.on('slideChange', function () {
	      if (isRoutableTabs) {
	        var view = app.views.get($swiperEl.parents('.view'));
	        if (!view) { view = app.views.main; }
	        var router = view.router;
	        var tabRoute = router.findTabRoute(swiper.slides.eq(swiper.activeIndex)[0]);
	        if (tabRoute) { router.navigate(tabRoute.path); }
	      } else {
	        app.tab.show({
	          tabEl: swiper.slides.eq(swiper.activeIndex),
	        });
	      }
	    });
	  }
	}

	var Swiper = {
	  name: 'swiper',
	  static: {
	    Swiper: Swiper$2,
	  },
	  create: function create() {
	    var app = this;
	    app.swiper = ConstructorMethods({
	      defaultSelector: '.swiper-container',
	      constructor: Swiper$2,
	      domProp: 'swiper',
	    });
	  },
	  on: {
	    pageBeforeRemove: function pageBeforeRemove(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        app.swiper.destroy(swiperEl);
	      });
	    },
	    pageMounted: function pageMounted(page) {
	      var app = this;
	      page.$el.find('.tabs-swipeable-wrap').each(function (index, swiperEl) {
	        initSwipers.call(app, swiperEl);
	      });
	    },
	    pageInit: function pageInit(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        initSwipers.call(app, swiperEl);
	      });
	    },
	    pageReinit: function pageReinit(page) {
	      var app = this;
	      page.$el.find('.swiper-init, .tabs-swipeable-wrap').each(function (index, swiperEl) {
	        var swiper = app.swiper.get(swiperEl);
	        if (swiper && swiper.update) { swiper.update(); }
	      });
	    },
	  },
	};

	/* eslint indent: ["off"] */
	var PhotoBrowser$1 = (function (Framework7Class$$1) {
	  function PhotoBrowser(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);

	    var pb = this;
	    pb.app = app;

	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.photoBrowser);

	    // Extend defaults with modules params
	    pb.useModulesParams(defaults);

	    pb.params = Utils.extend(defaults, params);

	    Utils.extend(pb, {
	      exposed: false,
	      opened: false,
	      activeIndex: pb.params.swiper.initialSlide,
	      url: pb.params.url,
	      view: pb.params.view || app.views.main,
	      swipeToClose: {
	        allow: true,
	        isTouched: false,
	        diff: undefined,
	        start: undefined,
	        current: undefined,
	        started: false,
	        activeSlide: undefined,
	        timeStart: undefined,
	      },
	    });

	    // Install Modules
	    pb.useModules();

	    // Init
	    pb.init();
	  }

	  if ( Framework7Class$$1 ) PhotoBrowser.__proto__ = Framework7Class$$1;
	  PhotoBrowser.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  PhotoBrowser.prototype.constructor = PhotoBrowser;
	  PhotoBrowser.prototype.onSlideChange = function onSlideChange (swiper) {
	    var pb = this;
	    pb.activeIndex = swiper.activeIndex;

	    var current = swiper.activeIndex + 1;
	    var total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
	    if (swiper.params.loop) {
	      total -= 2;
	      current -= swiper.loopedSlides;
	      if (current < 1) { current = total + current; }
	      if (current > total) { current -= total; }
	    }

	    var $activeSlideEl = pb.params.virtualSlides
	      ? swiper.$wrapperEl.find((".swiper-slide[data-swiper-slide-index=\"" + (swiper.activeIndex) + "\"]"))
	      : swiper.slides.eq(swiper.activeIndex);
	    var $previousSlideEl = pb.params.virtualSlides
	      ? swiper.$wrapperEl.find((".swiper-slide[data-swiper-slide-index=\"" + (swiper.previousIndex) + "\"]"))
	      : swiper.slides.eq(swiper.previousIndex);

	    var $currentEl = pb.$el.find('.photo-browser-current');
	    var $totalEl = pb.$el.find('.photo-browser-total');
	    if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
	      var navbarEl = pb.app.navbar.getElByPage(pb.$el);
	      if (navbarEl) {
	        $currentEl = $$1$1(navbarEl).find('.photo-browser-current');
	        $totalEl = $$1$1(navbarEl).find('.photo-browser-total');
	      }
	    }
	    $currentEl.text(current);
	    $totalEl.text(total);

	    // Update captions
	    if (pb.captions.length > 0) {
	      var captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
	      pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
	      pb.$captionsContainerEl.find(("[data-caption-index=\"" + captionIndex + "\"]")).addClass('photo-browser-caption-active');
	    }

	    // Stop Video
	    var previousSlideVideo = $previousSlideEl.find('video');
	    if (previousSlideVideo.length > 0) {
	      if ('pause' in previousSlideVideo[0]) { previousSlideVideo[0].pause(); }
	    }
	  };
	  PhotoBrowser.prototype.onTouchStart = function onTouchStart () {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;
	    if (!swipeToClose.allow) { return; }
	    swipeToClose.isTouched = true;
	  };
	  PhotoBrowser.prototype.onTouchMove = function onTouchMove (e) {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;

	    if (!swipeToClose.isTouched) { return; }
	    if (!swipeToClose.started) {
	      swipeToClose.started = true;
	      swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (pb.params.virtualSlides) {
	        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
	      } else {
	        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
	      }
	      swipeToClose.timeStart = Utils.now();
	    }
	    e.preventDefault();
	    swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
	    var opacity = 1 - (Math.abs(swipeToClose.diff) / 300);
	    var color = pb.exposed || pb.params.theme === 'dark' ? 0 : 255;
	    swipeToClose.activeSlide.transform(("translate3d(0," + (-swipeToClose.diff) + "px,0)"));
	    pb.swiper.$el.css('background-color', ("rgba(" + color + ", " + color + ", " + color + ", " + opacity + ")")).transition(0);
	  };
	  PhotoBrowser.prototype.onTouchEnd = function onTouchEnd () {
	    var pb = this;
	    var swipeToClose = pb.swipeToClose;
	    swipeToClose.isTouched = false;
	    if (!swipeToClose.started) {
	      swipeToClose.started = false;
	      return;
	    }
	    swipeToClose.started = false;
	    swipeToClose.allow = false;
	    var diff = Math.abs(swipeToClose.diff);
	    var timeDiff = (new Date()).getTime() - swipeToClose.timeStart;
	    if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
	      Utils.nextTick(function () {
	        if (pb.$el) {
	          if (swipeToClose.diff < 0) { pb.$el.addClass('swipe-close-to-bottom'); }
	          else { pb.$el.addClass('swipe-close-to-top'); }
	        }
	        pb.emit('local::swipeToClose', pb);
	        pb.close();
	        swipeToClose.allow = true;
	      });
	      return;
	    }
	    if (diff !== 0) {
	      swipeToClose.activeSlide.addClass('photo-browser-transitioning').transitionEnd(function () {
	        swipeToClose.allow = true;
	        swipeToClose.activeSlide.removeClass('photo-browser-transitioning');
	      });
	    } else {
	      swipeToClose.allow = true;
	    }
	    pb.swiper.$el.transition('').css('background-color', '');
	    swipeToClose.activeSlide.transform('');
	  };

	  // Render Functions
	  PhotoBrowser.prototype.renderNavbar = function renderNavbar () {
	    var pb = this;
	    if (pb.params.renderNavbar) { return pb.params.renderNavbar.call(pb); }

	    var iconsColor = pb.params.iconsColor;
	    if (!pb.params.iconsColor && pb.params.theme === 'dark') { iconsColor = 'white'; }

	    var backLinkText = pb.app.theme === 'ios' && pb.params.backLinkText ? pb.params.backLinkText : '';

	    var isPopup = pb.params.type !== 'page';
	    var navbarHtml = ("\n      <div class=\"navbar\">\n        <div class=\"navbar-inner sliding\">\n          <div class=\"left\">\n            <a href=\"#\" class=\"link " + (isPopup ? 'popup-close' : '') + " " + (!backLinkText ? 'icon-only' : '') + " " + (!isPopup ? 'back' : '') + "\" " + (isPopup ? 'data-popup=".photo-browser-popup"' : '') + ">\n              <i class=\"icon icon-back " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n              " + (backLinkText ? ("<span>" + backLinkText + "</span>") : '') + "\n            </a>\n          </div>\n          <div class=\"title\">\n            <span class=\"photo-browser-current\"></span>\n            <span class=\"photo-browser-of\">" + (pb.params.navbarOfText) + "</span>\n            <span class=\"photo-browser-total\"></span>\n          </div>\n          <div class=\"right\"></div>\n        </div>\n      </div>\n    ").trim();
	    return navbarHtml;
	  };
	  PhotoBrowser.prototype.renderToolbar = function renderToolbar () {
	    var pb = this;
	    if (pb.params.renderToolbar) { return pb.params.renderToolbar.call(pb); }

	    var iconsColor = pb.params.iconsColor;
	    if (!pb.params.iconsColor && pb.params.theme === 'dark') { iconsColor = 'white'; }

	    var toolbarHtml = ("\n      <div class=\"toolbar tabbar toolbar-bottom-md\">\n        <div class=\"toolbar-inner\">\n          <a href=\"#\" class=\"link photo-browser-prev\">\n            <i class=\"icon icon-back " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n          </a>\n          <a href=\"#\" class=\"link photo-browser-next\">\n            <i class=\"icon icon-forward " + (iconsColor ? ("color-" + iconsColor) : '') + "\"></i>\n          </a>\n        </div>\n      </div>\n    ").trim();
	    return toolbarHtml;
	  };
	  PhotoBrowser.prototype.renderCaption = function renderCaption (caption, index) {
	    var pb = this;
	    if (pb.params.renderCaption) { return pb.params.renderCaption.call(pb, caption, index); }
	    var captionHtml = ("\n      <div class=\"photo-browser-caption\" data-caption-index=\"" + index + "\">\n        " + caption + "\n      </div>\n    ").trim();
	    return captionHtml;
	  };
	  PhotoBrowser.prototype.renderObject = function renderObject (photo, index) {
	    var pb = this;
	    if (pb.params.renderObject) { return pb.params.renderObject.call(pb, photo, index); }
	    var objHtml = "\n      <div class=\"photo-browser-slide photo-browser-object-slide swiper-slide\" data-swiper-slide-index=\"" + index + "\">" + (photo.html ? photo.html : photo) + "</div>\n    ";
	    return objHtml;
	  };
	  PhotoBrowser.prototype.renderLazyPhoto = function renderLazyPhoto (photo, index) {
	    var pb = this;
	    if (pb.params.renderLazyPhoto) { return pb.params.renderLazyPhoto.call(pb, photo, index); }
	    var photoHtml = ("\n      <div class=\"photo-browser-slide photo-browser-slide-lazy swiper-slide\" data-swiper-slide-index=\"" + index + "\">\n          <div class=\"preloader swiper-lazy-preloader " + (pb.params.theme === 'dark' ? 'color-white' : '') + "\">" + (pb.app.theme === 'md' ? Utils.mdPreloaderContent : '') + "</div>\n          <span class=\"swiper-zoom-container\">\n              <img data-src=\"" + (photo.url ? photo.url : photo) + "\" class=\"swiper-lazy\">\n          </span>\n      </div>\n    ").trim();
	    return photoHtml;
	  };
	  PhotoBrowser.prototype.renderPhoto = function renderPhoto (photo, index) {
	    var pb = this;
	    if (pb.params.renderPhoto) { return pb.params.renderPhoto.call(pb, photo, index); }
	    var photoHtml = ("\n      <div class=\"photo-browser-slide swiper-slide\" data-swiper-slide-index=\"" + index + "\">\n        <span class=\"swiper-zoom-container\">\n          <img src=\"" + (photo.url ? photo.url : photo) + "\">\n        </span>\n      </div>\n    ").trim();
	    return photoHtml;
	  };
	  PhotoBrowser.prototype.render = function render () {
	    var pb = this;
	    if (pb.params.render) { return pb.params.render.call(pb, pb.params); }
	    var html = ("\n      <div class=\"photo-browser photo-browser-" + (pb.params.theme) + "\">\n        <div class=\"view\">\n          <div class=\"page photo-browser-page photo-browser-page-" + (pb.params.theme) + " no-toolbar " + (!pb.params.navbar ? 'no-navbar' : '') + "\" data-name=\"photo-browser-page\">\n            " + (pb.params.navbar ? pb.renderNavbar() : '') + "\n            " + (pb.params.toolbar ? pb.renderToolbar() : '') + "\n            <div class=\"photo-browser-captions photo-browser-captions-" + (pb.params.captionsTheme || pb.params.theme) + "\">\n              " + (pb.params.photos.map(function (photo, index) {
	                if (photo.caption) { return pb.renderCaption(photo.caption, index); }
	                return '';
	              }).join(' ')) + "\n            </div>\n            <div class=\"photo-browser-swiper-container swiper-container\">\n              <div class=\"photo-browser-swiper-wrapper swiper-wrapper\">\n                " + (pb.params.virtualSlides ? '' : pb.params.photos.map(function (photo, index) {
	                  if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
	                    return pb.renderObject(photo, index);
	                  } else if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
	                    return pb.renderLazyPhoto(photo, index);
	                  }
	                  return pb.renderPhoto(photo, index);
	                }).join(' ')) + "\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    ").trim();
	    return html;
	  };
	  PhotoBrowser.prototype.renderStandalone = function renderStandalone () {
	    var pb = this;
	    if (pb.params.renderStandalone) { return pb.params.renderStandalone.call(pb); }
	    var standaloneHtml = "<div class=\"popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen\">" + (pb.render()) + "</div>";
	    return standaloneHtml;
	  };
	  PhotoBrowser.prototype.renderPage = function renderPage () {
	    var pb = this;
	    if (pb.params.renderPage) { return pb.params.renderPage.call(pb); }
	    var pageHtml = pb.render();

	    return pageHtml;
	  };
	  PhotoBrowser.prototype.renderPopup = function renderPopup () {
	    var pb = this;
	    if (pb.params.renderPopup) { return pb.params.renderPopup.call(pb); }
	    var popupHtml = "<div class=\"popup photo-browser-popup\">" + (pb.render()) + "</div>";

	    return popupHtml;
	  };

	  // Callbacks
	  PhotoBrowser.prototype.onOpen = function onOpen (type, el) {
	    var pb = this;
	    var app = pb.app;
	    var $el = $$1$1(el);

	    $el[0].f7PhotoBrowser = pb;

	    pb.$el = $el;
	    pb.el = $el[0];
	    pb.openedIn = type;
	    pb.opened = true;

	    pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
	    pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
	    pb.slides = pb.$el.find('.photo-browser-slide');
	    pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
	    pb.captions = pb.$el.find('.photo-browser-caption');

	    // Init Swiper
	    var swiperParams = Utils.extend({}, pb.params.swiper, {
	      initialSlide: pb.activeIndex,
	      on: {
	        tap: function tap(e) {
	          pb.emit('local::tap', e);
	        },
	        click: function click(e) {
	          if (pb.params.exposition) {
	            pb.expositionToggle();
	          }
	          pb.emit('local::click', e);
	        },
	        doubleTap: function doubleTap(e) {
	          pb.emit('local::doubleTap', e);
	        },
	        slideChange: function slideChange() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var swiper = this;
	          pb.onSlideChange(swiper);
	          pb.emit.apply(pb, [ 'local::slideChange' ].concat( args ));
	        },
	        transitionStart: function transitionStart() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::transitionStart' ].concat( args ));
	        },
	        transitionEnd: function transitionEnd() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::transitionEnd' ].concat( args ));
	        },
	        slideChangeStart: function slideChangeStart() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::slideChangeTransitionStart' ].concat( args ));
	        },
	        slideChangeEnd: function slideChangeEnd() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::slideChangeTransitionEnd' ].concat( args ));
	        },
	        lazyImageLoad: function lazyImageLoad() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          pb.emit.apply(pb, [ 'local::lazyImageLoad' ].concat( args ));
	        },
	        lazyImageReady: function lazyImageReady() {
	          var args = [], len = arguments.length;
	          while ( len-- ) args[ len ] = arguments[ len ];

	          var slideEl = args[0];
	          $$1$1(slideEl).removeClass('photo-browser-slide-lazy');
	          pb.emit.apply(pb, [ 'local::lazyImageReady' ].concat( args ));
	        },
	      },
	    });
	    if (pb.params.swipeToClose && pb.params.type !== 'page') {
	      Utils.extend(swiperParams.on, {
	        touchStart: function touchStart(e) {
	          pb.onTouchStart(e);
	          pb.emit('local::touchStart', e);
	        },
	        touchMoveOpposite: function touchMoveOpposite(e) {
	          pb.onTouchMove(e);
	          pb.emit('local::touchMoveOpposite', e);
	        },
	        touchEnd: function touchEnd(e) {
	          pb.onTouchEnd(e);
	          pb.emit('local::touchEnd', e);
	        },
	      });
	    }
	    if (pb.params.virtualSlides) {
	      Utils.extend(swiperParams, {
	        virtual: {
	          slides: pb.params.photos,
	          renderSlide: function renderSlide(photo, index) {
	            if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
	              return pb.renderObject(photo, index);
	            } else if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
	              return pb.renderLazyPhoto(photo, index);
	            }
	            return pb.renderPhoto(photo, index);
	          },
	        },
	      });
	    }

	    pb.swiper = app.swiper.create(pb.$swiperContainerEl, swiperParams);

	    if (pb.activeIndex === 0) {
	      pb.onSlideChange(pb.swiper);
	    }
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:open');
	    }
	    pb.emit('local::open photoBrowserOpen', pb);
	  };
	  PhotoBrowser.prototype.onOpened = function onOpened () {
	    var pb = this;

	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:opened');
	    }
	    pb.emit('local::opened photoBrowserOpened', pb);
	  };
	  PhotoBrowser.prototype.onClose = function onClose () {
	    var pb = this;
	    if (pb.destroyed) { return; }

	    // Destroy Swiper
	    if (pb.swiper && pb.swiper.destroy) {
	      pb.swiper.destroy(true, false);
	      pb.swiper = null;
	      delete pb.swiper;
	    }
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:close');
	    }
	    pb.emit('local::close photoBrowserClose', pb);
	  };
	  PhotoBrowser.prototype.onClosed = function onClosed () {
	    var pb = this;
	    if (pb.destroyed) { return; }
	    pb.opened = false;
	    pb.$el = null;
	    pb.el = null;
	    delete pb.$el;
	    delete pb.el;
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:closed');
	    }
	    pb.emit('local::closed photoBrowserClosed', pb);
	  };

	  // Open
	  PhotoBrowser.prototype.openPage = function openPage () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var pageHtml = pb.renderPage();

	    pb.view.router.navigate({
	      url: pb.url,
	      route: {
	        content: pageHtml,
	        path: pb.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            pb.view.$el.addClass(("with-photo-browser-page with-photo-browser-page-" + (pb.params.theme)));
	            pb.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            pb.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            pb.view.$el.removeClass(("with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-" + (pb.params.theme)));
	            pb.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            pb.onClosed('page', page.el);
	          },
	        },
	      },
	    });
	    return pb;
	  };

	  PhotoBrowser.prototype.openStandalone = function openStandalone () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var standaloneHtml = pb.renderStandalone();

	    var popupParams = {
	      backdrop: false,
	      content: standaloneHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          pb.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          pb.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          pb.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          pb.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (pb.params.routableModals) {
	      pb.view.router.navigate({
	        url: pb.url,
	        route: {
	          path: pb.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      pb.modal = pb.app.popup.create(popupParams).open();
	    }
	    return pb;
	  };

	  PhotoBrowser.prototype.openPopup = function openPopup () {
	    var pb = this;
	    if (pb.opened) { return pb; }

	    var popupHtml = pb.renderPopup();

	    var popupParams = {
	      content: popupHtml,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          pb.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          pb.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          pb.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          pb.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (pb.params.routableModals) {
	      pb.view.router.navigate({
	        url: pb.url,
	        route: {
	          path: pb.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      pb.modal = pb.app.popup.create(popupParams).open();
	    }
	    return pb;
	  };

	  // Exposition
	  PhotoBrowser.prototype.expositionEnable = function expositionEnable () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.addClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.addClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.addClass('photo-browser-captions-exposed'); }
	    pb.exposed = true;
	    return pb;
	  };
	  PhotoBrowser.prototype.expositionDisable = function expositionDisable () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.removeClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.removeClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed'); }
	    pb.exposed = false;
	    return pb;
	  };
	  PhotoBrowser.prototype.expositionToggle = function expositionToggle () {
	    var pb = this;
	    if (pb.params.type === 'page') {
	      pb.view.$el.toggleClass('with-photo-browser-page-exposed');
	    }
	    if (pb.$el) { pb.$el.toggleClass('photo-browser-exposed'); }
	    if (pb.params.expositionHideCaptions) { pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed'); }
	    pb.exposed = !pb.exposed;
	    return pb;
	  };
	  PhotoBrowser.prototype.open = function open (index) {
	    var pb = this;
	    var type = pb.params.type;
	    if (pb.opened) {
	      if (pb.swiper && typeof index !== 'undefined') {
	        pb.swiper.slideTo(parseInt(index, 10));
	      }
	      return pb;
	    } else if (typeof index !== 'undefined') {
	      pb.activeIndex = index;
	    }
	    if (type === 'standalone') {
	      pb.openStandalone();
	    }
	    if (type === 'page') {
	      pb.openPage();
	    }
	    if (type === 'popup') {
	      pb.openPopup();
	    }
	    return pb;
	  };
	  PhotoBrowser.prototype.close = function close () {
	    var pb = this;
	    if (!pb.opened) { return pb; }
	    if (pb.params.routableModals || pb.openedIn === 'page') {
	      if (pb.view) { pb.view.router.back(); }
	    } else {
	      pb.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          pb.modal.destroy();
	          delete pb.modal;
	        });
	      });
	      pb.modal.close();
	    }
	    return pb;
	  };
	  // eslint-disable-next-line
	  PhotoBrowser.prototype.init = function init () {};
	  PhotoBrowser.prototype.destroy = function destroy () {
	    var pb = this;
	    pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);
	    if (pb.$el) {
	      pb.$el.trigger('photobrowser:beforedestroy');
	      delete pb.$el[0].f7PhotoBrowser;
	    }
	    Utils.deleteProps(pb);
	    pb = null;
	  };

	  return PhotoBrowser;
	}(Framework7Class));

	var PhotoBrowser = {
	  name: 'photoBrowser',
	  params: {
	    photoBrowser: {
	      photos: [],
	      exposition: true,
	      expositionHideCaptions: false,
	      type: 'standalone',
	      navbar: true,
	      toolbar: true,
	      theme: 'light',
	      captionsTheme: undefined,
	      iconsColor: undefined,
	      swipeToClose: true,
	      backLinkText: 'Close',
	      navbarOfText: 'of',
	      view: undefined,
	      url: 'photos/',
	      routableModals: true,
	      virtualSlides: true,

	      renderNavbar: undefined,
	      renderToolbar: undefined,
	      renderCaption: undefined,
	      renderObject: undefined,
	      renderLazyPhoto: undefined,
	      renderPhoto: undefined,
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderStandalone: undefined,

	      swiper: {
	        initialSlide: 0,
	        spaceBetween: 20,
	        speed: 300,
	        loop: false,
	        preloadImages: true,
	        navigation: {
	          nextEl: '.photo-browser-next',
	          prevEl: '.photo-browser-prev',
	        },
	        zoom: {
	          enabled: true,
	          maxRatio: 3,
	          minRatio: 1,
	        },
	        lazy: {
	          enabled: true,
	        },
	      },
	    },
	  },
	  create: function create() {
	    var app = this;
	    app.photoBrowser = ConstructorMethods({
	      defaultSelector: '.photo-browser',
	      constructor: PhotoBrowser$1,
	      app: app,
	      domProp: 'f7PhotoBrowser',
	    });
	  },
	  static: {
	    PhotoBrowser: PhotoBrowser$1,
	  },
	};

	var Notification$1 = (function (Modal) {
	  function Notification(app, params) {
	    var extendedParams = Utils.extend({
	      on: {},
	    }, app.params.notification, params);

	    // Extends with open/close Modal methods;
	    Modal.call(this, app, extendedParams);

	    var notification = this;

	    notification.app = app;

	    notification.params = extendedParams;

	    var ref = notification.params;
	    var icon = ref.icon;
	    var title = ref.title;
	    var titleRightText = ref.titleRightText;
	    var subtitle = ref.subtitle;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var closeTimeout = ref.closeTimeout;
	    var cssClass = ref.cssClass;
	    var closeOnClick = ref.closeOnClick;

	    var $el;
	    if (!notification.params.el) {
	      // Find Element
	      var notificationHtml = notification.render({
	        icon: icon,
	        title: title,
	        titleRightText: titleRightText,
	        subtitle: subtitle,
	        text: text,
	        closeButton: closeButton,
	        cssClass: cssClass,
	      });

	      $el = $$1$1(notificationHtml);
	    } else {
	      $el = $$1$1(notification.params.el);
	    }

	    if ($el && $el.length > 0 && $el[0].f7Modal) {
	      return $el[0].f7Modal;
	    }

	    if ($el.length === 0) {
	      return notification.destroy();
	    }

	    Utils.extend(notification, {
	      $el: $el,
	      el: $el[0],
	      type: 'notification',
	    });

	    $el[0].f7Modal = notification;

	    if (closeButton) {
	      $el.find('.notification-close-button').on('click', function () {
	        notification.close();
	      });
	    }
	    $el.on('click', function (e) {
	      if (closeButton && $$1$1(e.target).closest('.notification-close-button').length) {
	        return;
	      }
	      notification.emit('local::click notificationClick', notification);
	      if (closeOnClick) { notification.close(); }
	    });

	    notification.on('beforeDestroy', function () {
	      $el.off('click');
	    });

	    /* Touch Events */
	    var isTouched;
	    var isMoved;
	    var isScrolling;
	    var touchesDiff;
	    var touchStartTime;
	    var notificationHeight;
	    var touchesStart = {};
	    function handleTouchStart(e) {
	      if (isTouched) { return; }
	      isTouched = true;
	      isMoved = false;
	      isScrolling = undefined;
	      touchStartTime = Utils.now();
	      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
	    }
	    function handleTouchMove(e) {
	      if (!isTouched) { return; }
	      var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	      var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	      if (typeof isScrolling === 'undefined') {
	        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
	      }
	      if (isScrolling) {
	        isTouched = false;
	        return;
	      }
	      e.preventDefault();
	      if (!isMoved) {
	        notification.$el.removeClass('notification-transitioning');
	        notification.$el.transition(0);
	        notificationHeight = notification.$el[0].offsetHeight / 2;
	      }
	      isMoved = true;
	      touchesDiff = (pageY - touchesStart.y);
	      var newTranslate = touchesDiff;
	      if (touchesDiff > 0) {
	        newTranslate = Math.pow( touchesDiff, 0.8 );
	      }
	      notification.$el.transform(("translate3d(0, " + newTranslate + "px, 0)"));
	    }
	    function handleTouchEnd() {
	      if (!isTouched || !isMoved) {
	        isTouched = false;
	        isMoved = false;
	        return;
	      }
	      isTouched = false;
	      isMoved = false;
	      if (touchesDiff === 0) {
	        return;
	      }

	      var timeDiff = Utils.now() - touchStartTime;
	      notification.$el.transition('');
	      notification.$el.addClass('notification-transitioning');
	      notification.$el.transform('');

	      if (
	        (touchesDiff < -10 && timeDiff < 300) ||
	        (-touchesDiff >= notificationHeight / 1)
	      ) {
	        notification.close();
	      }
	    }

	    function attachTouchEvents() {
	      {
	        notification.$el.on(app.touchEvents.start, handleTouchStart, { passive: true });
	        app.on('touchmove:active', handleTouchMove);
	        app.on('touchend:passive', handleTouchEnd);
	      }
	    }
	    function detachTouchEvents() {
	      {
	        notification.$el.off(app.touchEvents.start, handleTouchStart, { passive: true });
	        app.off('touchmove:active', handleTouchMove);
	        app.off('touchend:passive', handleTouchEnd);
	      }
	    }

	    var timeoutId;
	    function closeOnTimeout() {
	      timeoutId = Utils.nextTick(function () {
	        if (isTouched && isMoved) {
	          closeOnTimeout();
	          return;
	        }
	        notification.close();
	      }, closeTimeout);
	    }
	    notification.on('open', function () {
	      if (notification.params.swipeToClose) {
	        attachTouchEvents();
	      }
	      $$1$1('.notification.modal-in').each(function (index, openedEl) {
	        var notificationInstance = app.notification.get(openedEl);
	        if (openedEl !== notification.el && notificationInstance) {
	          notificationInstance.close();
	        }
	      });
	      if (closeTimeout) {
	        closeOnTimeout();
	      }
	    });
	    notification.on('close beforeDestroy', function () {
	      if (notification.params.swipeToClose) {
	        detachTouchEvents();
	      }
	      window.clearTimeout(timeoutId);
	    });

	    return notification;
	  }

	  if ( Modal ) Notification.__proto__ = Modal;
	  Notification.prototype = Object.create( Modal && Modal.prototype );
	  Notification.prototype.constructor = Notification;
	  Notification.prototype.render = function render () {
	    var notification = this;
	    if (notification.params.render) { return notification.params.render.call(notification, notification); }
	    var ref = notification.params;
	    var icon = ref.icon;
	    var title = ref.title;
	    var titleRightText = ref.titleRightText;
	    var subtitle = ref.subtitle;
	    var text = ref.text;
	    var closeButton = ref.closeButton;
	    var cssClass = ref.cssClass;
	    return ("\n      <div class=\"notification " + (cssClass || '') + "\">\n        <div class=\"notification-header\">\n          " + (icon ? ("<div class=\"notification-icon\">" + icon + "</div>") : '') + "\n          " + (title ? ("<div class=\"notification-title\">" + title + "</div>") : '') + "\n          " + (titleRightText ? ("<div class=\"notification-title-right-text\">" + titleRightText + "</div>") : '') + "\n          " + (closeButton ? '<span class="notification-close-button"></span>' : '') + "\n        </div>\n        <div class=\"notification-content\">\n          " + (subtitle ? ("<div class=\"notification-subtitle\">" + subtitle + "</div>") : '') + "\n          " + (text ? ("<div class=\"notification-text\">" + text + "</div>") : '') + "\n        </div>\n      </div>\n    ").trim();
	  };

	  return Notification;
	}(Modal$1));

	var Notification = {
	  name: 'notification',
	  static: {
	    Notification: Notification$1,
	  },
	  create: function create() {
	    var app = this;
	    app.notification = Utils.extend(
	      {},
	      ModalMethods({
	        app: app,
	        constructor: Notification$1,
	        defaultSelector: '.notification.modal-in',
	      })
	    );
	  },
	  params: {
	    notification: {
	      icon: null,
	      title: null,
	      titleRightText: null,
	      subtitle: null,
	      text: null,
	      closeButton: false,
	      closeTimeout: null,
	      closeOnClick: false,
	      swipeToClose: true,
	      cssClass: null,
	      render: null,
	    },
	  },
	};

	/* eslint "no-useless-escape": "off" */
	var Autocomplete$1 = (function (Framework7Class$$1) {
	  function Autocomplete(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);

	    var ac = this;
	    ac.app = app;

	    var defaults = Utils.extend({
	      on: {},
	    }, app.params.autocomplete);


	    // Extend defaults with modules params
	    ac.useModulesParams(defaults);

	    ac.params = Utils.extend(defaults, params);

	    var $openerEl;
	    if (ac.params.openerEl) {
	      $openerEl = $$1$1(ac.params.openerEl);
	      if ($openerEl.length) { $openerEl[0].f7Autocomplete = ac; }
	    }

	    var $inputEl;
	    if (ac.params.inputEl) {
	      $inputEl = $$1$1(ac.params.inputEl);
	      if ($inputEl.length) { $inputEl[0].f7Autocomplete = ac; }
	    }

	    var view;
	    if (ac.params.view) {
	      view = ac.params.view;
	    } else if ($openerEl || $inputEl) {
	      view = app.views.get($openerEl || $inputEl);
	    }
	    if (!view) { view = app.views.main; }

	    var id = Utils.now();

	    var url = params.url;
	    if (!url && $openerEl && $openerEl.length) {
	      if ($openerEl.attr('href')) { url = $openerEl.attr('href'); }
	      else if ($openerEl.find('a').length > 0) {
	        url = $openerEl.find('a').attr('href');
	      }
	    }
	    if (!url || url === '#' || url === '') { url = ac.params.url; }

	    var inputType = ac.params.multiple ? 'checkbox' : 'radio';

	    Utils.extend(ac, {
	      $openerEl: $openerEl,
	      openerEl: $openerEl && $openerEl[0],
	      $inputEl: $inputEl,
	      inputEl: $inputEl && $inputEl[0],
	      id: id,
	      view: view,
	      url: url,
	      value: ac.params.value || [],
	      inputType: inputType,
	      inputName: (inputType + "-" + id),
	      $modalEl: undefined,
	      $dropdownEl: undefined,
	    });

	    var previousQuery = '';
	    function onInputChange() {
	      var query = ac.$inputEl.val().trim();

	      if (!ac.params.source) { return; }
	      ac.params.source.call(ac, query, function (items) {
	        var itemsHTML = '';
	        var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
	        ac.items = items;
	        var regExp;
	        if (ac.params.highlightMatches) {
	          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	          regExp = new RegExp(("(" + query + ")"), 'i');
	        }

	        var firstValue;
	        var firstItem;
	        for (var i = 0; i < limit; i += 1) {
	          var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
	          var itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];
	          if (i === 0) {
	            firstValue = itemValue;
	            firstItem = ac.items[i];
	          }
	          itemsHTML += ac.renderItem({
	            value: itemValue,
	            text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText,
	          }, i);
	        }
	        if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
	          itemsHTML += ac.renderItem({
	            placeholder: true,
	            text: ac.params.dropdownPlaceholderText,
	          });
	        }
	        ac.$dropdownEl.find('ul').html(itemsHTML);
	        if (ac.params.typeahead) {
	          if (!firstValue || !firstItem) {
	            return;
	          }
	          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
	            return;
	          }
	          if (previousQuery.toLowerCase() === query.toLowerCase()) {
	            ac.value = [];
	            return;
	          }

	          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
	            previousQuery = query;
	            ac.value = [];
	            return;
	          }
	          $inputEl.val(firstValue);
	          $inputEl[0].setSelectionRange(query.length, firstValue.length);

	          var previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];
	          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
	            ac.value = [firstItem];
	            ac.emit('local::change autocompleteChange', [firstItem]);
	          }
	        }

	        previousQuery = query;
	      });
	    }
	    function onPageInputChange() {
	      var input = this;
	      var value = input.value;
	      var isValues = $$1$1(input).parents('.autocomplete-values').length > 0;
	      var item;
	      var itemValue;
	      var aValue;
	      if (isValues) {
	        if (ac.inputType === 'checkbox' && !input.checked) {
	          for (var i = 0; i < ac.value.length; i += 1) {
	            aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];
	            if (aValue === value || aValue * 1 === value * 1) {
	              ac.value.splice(i, 1);
	            }
	          }
	          ac.updateValues();
	          ac.emit('local::change autocompleteChange', ac.value);
	        }
	        return;
	      }

	      // Find Related Item
	      for (var i$1 = 0; i$1 < ac.items.length; i$1 += 1) {
	        itemValue = typeof ac.items[i$1] === 'object' ? ac.items[i$1][ac.params.valueProperty] : ac.items[i$1];
	        if (itemValue === value || itemValue * 1 === value * 1) { item = ac.items[i$1]; }
	      }
	      if (ac.inputType === 'radio') {
	        ac.value = [item];
	      } else if (input.checked) {
	        ac.value.push(item);
	      } else {
	        for (var i$2 = 0; i$2 < ac.value.length; i$2 += 1) {
	          aValue = typeof ac.value[i$2] === 'object' ? ac.value[i$2][ac.params.valueProperty] : ac.value[i$2];
	          if (aValue === value || aValue * 1 === value * 1) {
	            ac.value.splice(i$2, 1);
	          }
	        }
	      }

	      // Update Values Block
	      ac.updateValues();

	      // On Select Callback
	      if (((ac.inputType === 'radio' && input.checked) || ac.inputType === 'checkbox')) {
	        ac.emit('local::change autocompleteChange', ac.value);
	      }
	    }
	    function onHtmlClick(e) {
	      var $targetEl = $$1$1(e.target);
	      if ($targetEl.is(ac.$inputEl[0]) || ($targetEl.closest(ac.$dropdownEl[0]).length)) { return; }
	      ac.close();
	    }
	    function onOpenerClick() {
	      ac.open();
	    }
	    function onInputFocus() {
	      ac.open();
	    }
	    function onInputBlur() {
	      if (ac.$dropdownEl.find('label.active-state').length > 0) { return; }
	      ac.close();
	    }
	    function onResize() {
	      ac.positionDropDown();
	    }

	    function onKeyDown(e) {
	      if (ac.opened && e.keyCode === 13) {
	        e.preventDefault();
	        ac.$inputEl.blur();
	      }
	    }
	    function onDropdownclick() {
	      var $clickedEl = $$1$1(this);
	      var clickedItem;
	      for (var i = 0; i < ac.items.length; i += 1) {
	        var itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
	        var value = $clickedEl.attr('data-value');
	        if (itemValue === value || itemValue * 1 === value * 1) {
	          clickedItem = ac.items[i];
	        }
	      }
	      if (ac.params.updateInputValueOnSelect) {
	        ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
	        ac.$inputEl.trigger('input change');
	      }
	      ac.value = [clickedItem];
	      ac.emit('local::change autocompleteChange', [clickedItem]);

	      ac.close();
	    }

	    ac.attachEvents = function attachEvents() {
	      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
	        ac.$openerEl.on('click', onOpenerClick);
	      }
	      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
	        ac.$inputEl.on('focus', onInputFocus);
	        ac.$inputEl.on('input', onInputChange);
	        if (app.device.android) {
	          $$1$1('html').on('click', onHtmlClick);
	        } else {
	          ac.$inputEl.on('blur', onInputBlur);
	        }
	        if (ac.params.typeahead) {
	          ac.$inputEl.on('keydown', onKeyDown);
	        }
	      }
	    };
	    ac.detachEvents = function attachEvents() {
	      if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
	        ac.$openerEl.off('click', onOpenerClick);
	      }
	      if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
	        ac.$inputEl.off('focus', onInputFocus);
	        ac.$inputEl.off('input', onInputChange);
	        if (app.device.android) {
	          $$1$1('html').off('click', onHtmlClick);
	        } else {
	          ac.$inputEl.off('blur', onInputBlur);
	        }
	        if (ac.params.typeahead) {
	          ac.$inputEl.off('keydown', onKeyDown);
	        }
	      }
	    };
	    ac.attachDropdownEvents = function attachDropdownEvents() {
	      ac.$dropdownEl.on('click', 'label', onDropdownclick);
	      app.on('resize', onResize);
	    };
	    ac.detachDropdownEvents = function detachDropdownEvents() {
	      ac.$dropdownEl.off('click', 'label', onDropdownclick);
	      app.off('resize', onResize);
	    };

	    ac.attachPageEvents = function attachPageEvents() {
	      ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
	      if (ac.params.closeOnSelect && !ac.params.multiple) {
	        ac.$el.once('click', '.list label', function () {
	          Utils.nextTick(function () {
	            ac.close();
	          });
	        });
	      }
	    };
	    ac.detachPageEvents = function detachPageEvents() {
	      ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
	    };

	    // Install Modules
	    ac.useModules();

	    // Init
	    ac.init();

	    return ac;
	  }

	  if ( Framework7Class$$1 ) Autocomplete.__proto__ = Framework7Class$$1;
	  Autocomplete.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  Autocomplete.prototype.constructor = Autocomplete;
	  Autocomplete.prototype.positionDropDown = function positionDropDown () {
	    var obj;

	    var ac = this;
	    var $inputEl = ac.$inputEl;
	    var app = ac.app;
	    var $dropdownEl = ac.$dropdownEl;

	    var $pageContentEl = $inputEl.parents('.page-content');
	    if ($pageContentEl.length === 0) { return; }
	    var inputOffset = $inputEl.offset();
	    var inputOffsetWidth = $inputEl[0].offsetWidth;
	    var inputOffsetHeight = $inputEl[0].offsetHeight;
	    var $listEl = $inputEl.parents('.list');
	    var listOffset = $listEl.offset();
	    var paddingBottom = parseInt($pageContentEl.css('padding-top'), 10);
	    var listOffsetLeft = $listEl.length > 0 ? listOffset.left - $listEl.parent().offset().left : 0;
	    var inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
	    var inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);
	    var maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;

	    var paddingProp = app.rtl ? 'padding-right' : 'padding-left';
	    var paddingValue;
	    if ($listEl.length && !ac.params.expandInput) {
	      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
	    }


	    $dropdownEl.css({
	      left: (($listEl.length > 0 ? listOffsetLeft : inputOffsetLeft) + "px"),
	      top: ((inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight) + "px"),
	      width: (($listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth) + "px"),
	    });
	    $dropdownEl.children('.autocomplete-dropdown-inner').css(( obj = {
	      maxHeight: (maxHeight + "px")
	    }, obj[paddingProp] = $listEl.length > 0 && !ac.params.expandInput ? (paddingValue + "px") : '', obj ));
	  };
	  Autocomplete.prototype.focus = function focus () {
	    var ac = this;
	    ac.$el.find('input[type=search]').focus();
	  };
	  Autocomplete.prototype.source = function source (query) {
	    var ac = this;
	    if (!ac.params.source) { return; }

	    var $el = ac.$el;

	    ac.params.source.call(ac, query, function (items) {
	      var itemsHTML = '';
	      var limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
	      ac.items = items;
	      for (var i = 0; i < limit; i += 1) {
	        var selected = false;
	        var itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
	        for (var j = 0; j < ac.value.length; j += 1) {
	          var aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
	          if (aValue === itemValue || aValue * 1 === itemValue * 1) { selected = true; }
	        }
	        itemsHTML += ac.renderItem({
	          value: itemValue,
	          text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
	          inputType: ac.inputType,
	          id: ac.id,
	          inputName: ac.inputName,
	          selected: selected,
	        }, i);
	      }
	      $el.find('.autocomplete-found ul').html(itemsHTML);
	      if (items.length === 0) {
	        if (query.length !== 0) {
	          $el.find('.autocomplete-not-found').show();
	          $el.find('.autocomplete-found, .autocomplete-values').hide();
	        } else {
	          $el.find('.autocomplete-values').show();
	          $el.find('.autocomplete-found, .autocomplete-not-found').hide();
	        }
	      } else {
	        $el.find('.autocomplete-found').show();
	        $el.find('.autocomplete-not-found, .autocomplete-values').hide();
	      }
	    });
	  };
	  Autocomplete.prototype.updateValues = function updateValues () {
	    var ac = this;
	    var valuesHTML = '';
	    for (var i = 0; i < ac.value.length; i += 1) {
	      valuesHTML += ac.renderItem({
	        value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
	        text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
	        inputType: ac.inputType,
	        id: ac.id,
	        inputName: ((ac.inputName) + "-checked}"),
	        selected: true,
	      }, i);
	    }
	    ac.$el.find('.autocomplete-values ul').html(valuesHTML);
	  };
	  Autocomplete.prototype.preloaderHide = function preloaderHide () {
	    var ac = this;
	    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
	      ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
	    } else {
	      $$1$1('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
	    }
	  };
	  Autocomplete.prototype.preloaderShow = function preloaderShow () {
	    var ac = this;
	    if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
	      ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
	    } else {
	      $$1$1('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
	    }
	  };
	  Autocomplete.prototype.renderPreloader = function renderPreloader () {
	    var ac = this;
	    return ("\n      <div class=\"autocomplete-preloader preloader " + (ac.params.preloaderColor ? ("color-" + (ac.params.preloaderColor)) : '') + "\">" + (ac.app.theme === 'md' ? Utils.mdPreloaderContent : '') + "</div>\n    ").trim();
	  };
	  Autocomplete.prototype.renderSearchbar = function renderSearchbar () {
	    var ac = this;
	    if (ac.params.renderSearchbar) { return ac.params.renderSearchbar.call(ac); }
	    var searchbarHTML = ("\n      <form class=\"searchbar\">\n        <div class=\"searchbar-inner\">\n          <div class=\"searchbar-input-wrap\">\n            <input type=\"search\" placeholder=\"" + (ac.params.searchbarPlaceholder) + "\"/>\n            <i class=\"searchbar-icon\"></i>\n            <span class=\"input-clear-button\"></span>\n          </div>\n          <span class=\"searchbar-disable-button\">" + (ac.params.searchbarDisableText) + "</span>\n        </div>\n      </form>\n    ").trim();
	    return searchbarHTML;
	  };
	  Autocomplete.prototype.renderItem = function renderItem (item, index) {
	    var ac = this;
	    if (ac.params.renderItem) { return ac.params.renderItem.call(ac, item, index); }
	    var itemHtml;
	    if (ac.params.openIn !== 'dropdown') {
	      itemHtml = "\n        <li>\n          <label class=\"item-" + (item.inputType) + " item-content\">\n            <input type=\"" + (item.inputType) + "\" name=\"" + (item.inputName) + "\" value=\"" + (item.value) + "\" " + (item.selected ? 'checked' : '') + ">\n            <i class=\"icon icon-" + (item.inputType) + "\"></i>\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    } else if (!item.placeholder) {
	      // Dropdown
	      itemHtml = "\n        <li>\n          <label class=\"item-radio item-content\" data-value=\"" + (item.value) + "\">\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    } else {
	      // Dropwdown placeholder
	      itemHtml = "\n        <li class=\"autocomplete-dropdown-placeholder\">\n          <div class=\"item-content\">\n            <div class=\"item-inner\">\n              <div class=\"item-title\">" + (item.text) + "</div>\n            </div>\n          </label>\n        </li>\n      ";
	    }
	    return itemHtml.trim();
	  };

	  Autocomplete.prototype.renderNavbar = function renderNavbar () {
	    var ac = this;
	    if (ac.params.renderNavbar) { return ac.params.renderNavbar.call(ac); }
	    var pageTitle = ac.params.pageTitle;
	    if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
	      pageTitle = ac.$openerEl.find('.item-title').text().trim();
	    }
	    var navbarHtml = ("\n      <div class=\"navbar " + (ac.params.navbarColorTheme ? ("color-theme-" + (ac.params.navbarColorTheme)) : '') + "\">\n        <div class=\"navbar-inner " + (ac.params.navbarColorTheme ? ("color-theme-" + (ac.params.navbarColorTheme)) : '') + "\">\n          <div class=\"left sliding\">\n            <a href=\"#\" class=\"link " + (ac.params.openIn === 'page' ? 'back' : 'popup-close') + "\">\n              <i class=\"icon icon-back\"></i>\n              <span class=\"ios-only\">" + (ac.params.openIn === 'page' ? ac.params.pageBackLinkText : ac.params.popupCloseLinkText) + "</span>\n            </a>\n          </div>\n          " + (pageTitle ? ("<div class=\"title sliding\">" + pageTitle + "</div>") : '') + "\n          " + (ac.params.preloader ? ("\n          <div class=\"right\">\n            " + (ac.renderPreloader()) + "\n          </div>\n          ") : '') + "\n          <div class=\"subnavbar sliding\">" + (ac.renderSearchbar()) + "</div>\n        </div>\n      </div>\n    ").trim();
	    return navbarHtml;
	  };
	  Autocomplete.prototype.renderDropdown = function renderDropdown () {
	    var ac = this;
	    if (ac.params.renderDropdown) { return ac.params.renderDropdown.call(ac, ac.items); }
	    var dropdownHtml = ("\n      <div class=\"autocomplete-dropdown\">\n        <div class=\"autocomplete-dropdown-inner\">\n          <div class=\"list " + (!ac.params.expandInput ? 'no-ios-edge' : '') + "\">\n            <ul></ul>\n          </div>\n        </div>\n        " + (ac.params.preloader ? ac.renderPreloader() : '') + "\n      </div>\n    ").trim();
	    return dropdownHtml;
	  };
	  Autocomplete.prototype.renderPage = function renderPage () {
	    var ac = this;
	    if (ac.params.renderPage) { return ac.params.renderPage.call(ac, ac.items); }

	    var pageHtml = ("\n      <div class=\"page page-with-subnavbar autocomplete-page\" data-name=\"autocomplete-page\">\n        " + (ac.renderNavbar()) + "\n        <div class=\"searchbar-backdrop\"></div>\n        <div class=\"page-content\">\n          <div class=\"list autocomplete-list autocomplete-found autocomplete-list-" + (ac.id) + " " + (ac.params.formColorTheme ? ("color-theme-" + (ac.params.formColorTheme)) : '') + "\">\n            <ul></ul>\n          </div>\n          <div class=\"list autocomplete-not-found\">\n            <ul>\n              <li class=\"item-content\"><div class=\"item-inner\"><div class=\"item-title\">" + (ac.params.notFoundText) + "</div></div></li>\n            </ul>\n          </div>\n          <div class=\"list autocomplete-values\">\n            <ul></ul>\n          </div>\n        </div>\n      </div>\n    ").trim();
	    return pageHtml;
	  };
	  Autocomplete.prototype.renderPopup = function renderPopup () {
	    var ac = this;
	    if (ac.params.renderPopup) { return ac.params.renderPopup.call(ac, ac.items); }
	    var popupHtml = ("\n      <div class=\"popup autocomplete-popup\">\n        <div class=\"view\">\n          " + (ac.renderPage()) + ";\n        </div>\n      </div>\n    ").trim();
	    return popupHtml;
	  };
	  Autocomplete.prototype.onOpen = function onOpen (type, el) {
	    var ac = this;
	    var app = ac.app;
	    var $el = $$1$1(el);
	    ac.$el = $el;
	    ac.el = $el[0];
	    ac.openedIn = type;
	    ac.opened = true;

	    if (ac.params.openIn === 'dropdown') {
	      ac.attachDropdownEvents();

	      ac.$dropdownEl.addClass('autocomplete-dropdown-in');
	      ac.$inputEl.trigger('input');
	    } else {
	      // Init SB
	      var $searchbarEl = $el.find('.searchbar');
	      if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
	        $searchbarEl = $$1$1(app.navbar.getElByPage($el)).find('.searchbar');
	      }
	      ac.searchbar = app.searchbar.create({
	        el: $searchbarEl,
	        backdropEl: $el.find('.searchbar-backdrop'),
	        customSearch: true,
	        on: {
	          searchbarSearch: function searchbarSearch(sb, query) {
	            if (query.length === 0 && ac.searchbar.enabled) {
	              ac.searchbar.backdropShow();
	            } else {
	              ac.searchbar.backdropHide();
	            }
	            ac.source(query);
	          },
	        },
	      });

	      // Attach page events
	      ac.attachPageEvents();

	      // Update Values On Page Init
	      ac.updateValues();

	      // Source on load
	      if (ac.params.requestSourceOnOpen) { ac.source(''); }
	    }

	    ac.emit('local::open autocompleteOpen', ac);
	  };
	  Autocomplete.prototype.onOpened = function onOpened () {
	    var ac = this;
	    if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
	      ac.autoFocus();
	    }
	    ac.emit('local::opened autocompleteOpened', ac);
	  };
	  Autocomplete.prototype.onClose = function onClose () {
	    var ac = this;
	    if (ac.destroyed) { return; }

	    // Destroy SB
	    if (ac.searchbar && ac.searchbar.destroy) {
	      ac.searchbar.destroy();
	      ac.searchbar = null;
	      delete ac.searchbar;
	    }

	    if (ac.params.openIn === 'dropdown') {
	      ac.detachDropdownEvents();
	      ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
	      ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
	    } else {
	      ac.detachPageEvents();
	    }

	    ac.emit('local::close autocompleteClose', ac);
	  };
	  Autocomplete.prototype.onClosed = function onClosed () {
	    var ac = this;
	    if (ac.destroyed) { return; }
	    ac.opened = false;
	    ac.$el = null;
	    ac.el = null;
	    delete ac.$el;
	    delete ac.el;

	    ac.emit('local::closed autocompleteClosed', ac);
	  };
	  Autocomplete.prototype.openPage = function openPage () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var pageHtml = ac.renderPage();
	    ac.view.router.navigate({
	      url: ac.url,
	      route: {
	        content: pageHtml,
	        path: ac.url,
	        on: {
	          pageBeforeIn: function pageBeforeIn(e, page) {
	            ac.onOpen('page', page.el);
	          },
	          pageAfterIn: function pageAfterIn(e, page) {
	            ac.onOpened('page', page.el);
	          },
	          pageBeforeOut: function pageBeforeOut(e, page) {
	            ac.onClose('page', page.el);
	          },
	          pageAfterOut: function pageAfterOut(e, page) {
	            ac.onClosed('page', page.el);
	          },
	        },
	        options: {
	          animate: ac.params.animate,
	        },
	      },
	    });
	    return ac;
	  };
	  Autocomplete.prototype.openPopup = function openPopup () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var popupHtml = ac.renderPopup();

	    var popupParams = {
	      content: popupHtml,
	      animate: ac.params.animate,
	      on: {
	        popupOpen: function popupOpen(popup) {
	          ac.onOpen('popup', popup.el);
	        },
	        popupOpened: function popupOpened(popup) {
	          ac.onOpened('popup', popup.el);
	        },
	        popupClose: function popupClose(popup) {
	          ac.onClose('popup', popup.el);
	        },
	        popupClosed: function popupClosed(popup) {
	          ac.onClosed('popup', popup.el);
	        },
	      },
	    };

	    if (ac.params.routableModals) {
	      ac.view.router.navigate({
	        url: ac.url,
	        route: {
	          path: ac.url,
	          popup: popupParams,
	        },
	      });
	    } else {
	      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
	    }
	    return ac;
	  };
	  Autocomplete.prototype.openDropdown = function openDropdown () {
	    var ac = this;

	    if (!ac.$dropdownEl) {
	      ac.$dropdownEl = $$1$1(ac.renderDropdown());
	    }
	    var $listEl = ac.$inputEl.parents('.list');
	    if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
	      ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
	    }
	    ac.positionDropDown();
	    var $pageContentEl = ac.$inputEl.parents('.page-content');
	    if (ac.params.dropdownel) {
	      $$1$1(ac.params.dropdownel).append(ac.$dropdownEl);
	    } else if ($pageContentEl.length === 0) {
	      ac.$dropdownEl.insertAfter(ac.$inputEl);
	    } else {
	      $pageContentEl.append(ac.$dropdownEl);
	    }
	    ac.onOpen('dropdown', ac.$dropdownEl);
	    ac.onOpened('dropdown', ac.$dropdownEl);
	  };
	  Autocomplete.prototype.open = function open () {
	    var ac = this;
	    if (ac.opened) { return ac; }
	    var openIn = ac.params.openIn;
	    ac[("open" + (openIn.split('').map(function (el, index) {
	      if (index === 0) { return el.toUpperCase(); }
	      return el;
	    }).join('')))]();
	    return ac;
	  };
	  Autocomplete.prototype.close = function close () {
	    var ac = this;
	    if (!ac.opened) { return ac; }
	    if (ac.params.openIn === 'dropdown') {
	      ac.onClose();
	      ac.onClosed();
	    } else if (ac.params.routableModals || ac.openedIn === 'page') {
	      ac.view.router.back({ animate: ac.params.animate });
	    } else {
	      ac.modal.once('modalClosed', function () {
	        Utils.nextTick(function () {
	          ac.modal.destroy();
	          delete ac.modal;
	        });
	      });
	      ac.modal.close();
	    }
	    return ac;
	  };
	  Autocomplete.prototype.init = function init () {
	    var ac = this;
	    ac.attachEvents();
	  };
	  Autocomplete.prototype.destroy = function destroy () {
	    var ac = this;
	    ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
	    ac.detachEvents();
	    if (ac.$inputEl && ac.$inputEl[0]) {
	      delete ac.$inputEl[0].f7Autocomplete;
	    }
	    if (ac.$openerEl && ac.$openerEl[0]) {
	      delete ac.$openerEl[0].f7Autocomplete;
	    }
	    Utils.deleteProps(ac);
	    ac.destroyed = true;
	  };

	  return Autocomplete;
	}(Framework7Class));

	var Autocomplete = {
	  name: 'autocomplete',
	  params: {
	    autocomplete: {
	      openerEl: undefined,
	      inputEl: undefined,
	      view: undefined,

	      // DropDown
	      dropdownContainerEl: undefined,
	      dropdownPlaceholderText: undefined,
	      typeahead: false,
	      highlightMatches: true,
	      expandInput: false,
	      updateInputValueOnSelect: true,

	      value: undefined,
	      multiple: false,

	      source: undefined,
	      limit: undefined,
	      valueProperty: 'id',
	      textProperty: 'text',

	      openIn: 'page', // or 'popup' or 'dropdown'
	      pageBackLinkText: 'Back',
	      popupCloseLinkText: 'Close',
	      pageTitle: undefined,
	      searchbarPlaceholder: 'Search...',
	      searchbarDisableText: 'Cancel',

	      animate: true,

	      autoFocus: false,
	      closeOnSelect: false,
	      notFoundText: 'Nothing found',
	      requestSourceOnOpen: false,

	      // Preloader
	      preloaderColor: undefined,
	      preloader: false,

	      // Colors
	      formColorTheme: undefined,
	      navbarColorTheme: undefined,

	      // Routing
	      routableModals: true,
	      url: 'select/',

	      // Custom render functions
	      renderDropdown: undefined,
	      renderPage: undefined,
	      renderPopup: undefined,
	      renderItem: undefined,
	      renderSearchbar: undefined,
	      renderNavbar: undefined,

	    },
	  },
	  static: {
	    Autocomplete: Autocomplete$1,
	  },
	  create: function create() {
	    var app = this;
	    app.autocomplete = Utils.extend(
	      ConstructorMethods({
	        defaultSelector: undefined,
	        constructor: Autocomplete$1,
	        app: app,
	        domProp: 'f7Autocomplete',
	      }),
	      {
	        open: function open(autocompleteEl) {
	          var ac = app.autocomplete.get(autocompleteEl);
	          if (ac && ac.open) { return ac.open(); }
	          return undefined;
	        },
	        close: function close(autocompleteEl) {
	          var ac = app.autocomplete.get(autocompleteEl);
	          if (ac && ac.close) { return ac.close(); }
	          return undefined;
	        },
	      }
	    );
	  },
	};

	var ViAd = (function (Framework7Class$$1) {
	  function ViAd(app, params) {
	    if ( params === void 0 ) params = {};

	    Framework7Class$$1.call(this, params, [app]);
	    var vi = this;
	    if (!window.vi) {
	      throw new Error('f7:vi SDK not found.');
	    }

	    var orientation;
	    if (typeof window.orientation !== 'undefined') {
	      orientation = window.orientation === -90 || window.orientation === 90 ? 'horizontal' : 'vertical';
	    }
	    var defaults = Utils.extend(
	      {},
	      app.params.vi,
	      {
	        appId: app.id,
	        appVer: app.version,
	        language: app.language,
	        width: app.width,
	        height: app.height,
	        os: Device.os,
	        osVersion: Device.osVersion,
	        orientation: orientation,
	      }
	    );

	    // Extend defaults with modules params
	    vi.useModulesParams(defaults);

	    vi.params = Utils.extend(defaults, params);

	    var adParams = {};
	    var skipParams = ('on autoplay fallbackOverlay fallbackOverlayText enabled').split(' ');
	    Object.keys(vi.params).forEach(function (paramName) {
	      if (skipParams.indexOf(paramName) >= 0) { return; }
	      var paramValue = vi.params[paramName];
	      if ([null, undefined].indexOf(paramValue) >= 0) { return; }
	      adParams[paramName] = paramValue;
	    });

	    if (!vi.params.appId) {
	      throw new Error('Framework7:"app.id" is required to display an ad. Make sure you have specified it on app initialization.');
	    }
	    if (!vi.params.placementId) {
	      throw new Error('Framework7:"placementId" is required to display an ad.');
	    }

	    function onResize() {
	      var $viFrame = $$1$1('iframe#viAd');
	      if ($viFrame.length === 0) { return; }
	      $viFrame
	        .css({
	          width: ((app.width) + "px"),
	          height: ((app.height) + "px"),
	        });
	    }

	    function removeOverlay() {
	      if (!vi.$overlayEl) { return; }
	      vi.$overlayEl.off('click touchstart');
	      vi.$overlayEl.remove();
	    }
	    function createOverlay(videoEl) {
	      if (!videoEl) { return; }
	      vi.$overlayEl = $$1$1(("\n        <div class=\"vi-overlay no-fastclick\">\n          " + (vi.params.fallbackOverlayText ? ("<div class=\"vi-overlay-text\">" + (vi.params.fallbackOverlayText) + "</div>") : '') + "\n          <div class=\"vi-overlay-play-button\"></div>\n        </div>\n      ").trim());

	      var touchStartTime;
	      vi.$overlayEl.on('touchstart', function () {
	        touchStartTime = Utils.now();
	      });
	      vi.$overlayEl.on('click', function () {
	        var timeDiff = Utils.now() - touchStartTime;
	        if (timeDiff > 300) { return; }
	        if (videoEl) {
	          videoEl.play();
	          removeOverlay();
	          return;
	        }
	        vi.start();
	        removeOverlay();
	      });
	      app.root.append(vi.$overlayEl);
	    }

	    // Create ad
	    vi.ad = new window.vi.Ad(adParams);

	    Utils.extend(vi.ad, {
	      onAdReady: function onAdReady() {
	        app.on('resize', onResize);
	        vi.emit('local::ready');
	        if (vi.params.autoplay) {
	          vi.start();
	        }
	      },
	      onAdStarted: function onAdStarted() {
	        vi.emit('local::started');
	      },
	      onAdClick: function onAdClick(targetUrl) {
	        vi.emit('local::click', targetUrl);
	      },
	      onAdImpression: function onAdImpression() {
	        vi.emit('local::impression');
	      },
	      onAdStopped: function onAdStopped(reason) {
	        app.off('resize', onResize);
	        removeOverlay();

	        vi.emit('local::stopped', reason);
	        if (reason === 'complete') {
	          vi.emit('local::complete');
	          vi.emit('local::completed');
	        }
	        if (reason === 'userexit') {
	          vi.emit('local::userexit');
	        }
	        vi.destroyed = true;
	      },
	      onAutoPlayFailed: function onAutoPlayFailed(reason, videoEl) {
	        vi.emit('local::autoplayFailed', reason, videoEl);
	        if (reason && reason.name && reason.name.indexOf('NotAllowedError') !== -1 && vi.params.fallbackOverlay) {
	          createOverlay(videoEl);
	        }
	      },
	      onAdError: function onAdError(msg) {
	        removeOverlay();
	        app.off('resize', onResize);
	        vi.emit('local::error', msg);
	        vi.destroyed = true;
	      },
	    });

	    vi.init();

	    Utils.extend(vi, {
	      app: app,
	    });
	  }

	  if ( Framework7Class$$1 ) ViAd.__proto__ = Framework7Class$$1;
	  ViAd.prototype = Object.create( Framework7Class$$1 && Framework7Class$$1.prototype );
	  ViAd.prototype.constructor = ViAd;
	  ViAd.prototype.start = function start () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.startAd(); }
	  };
	  ViAd.prototype.pause = function pause () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.pauseAd(); }
	  };
	  ViAd.prototype.resume = function resume () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.resumeAd(); }
	  };
	  ViAd.prototype.stop = function stop () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.stopAd(); }
	  };
	  ViAd.prototype.init = function init () {
	    var vi = this;
	    if (vi.destroyed) { return; }
	    if (vi.ad) { vi.ad.initAd(); }
	  };
	  ViAd.prototype.destroy = function destroy () {
	    var vi = this;
	    vi.destroyed = true;
	    vi.emit('local::beforeDestroy');
	    Utils.deleteProps(vi);
	  };

	  return ViAd;
	}(Framework7Class));

	var Vi = {
	  name: 'vi',
	  params: {
	    vi: {
	      enabled: false,
	      autoplay: true,
	      fallbackOverlay: true,
	      fallbackOverlayText: 'Please watch this ad',
	      showMute: true,
	      startMuted: (Device.ios || Device.android) && !Device.cordova,
	      appId: null,
	      appVer: null,
	      language: null,
	      width: null,
	      height: null,
	      placementId: 'pltd4o7ibb9rc653x14',
	      placementType: 'interstitial',
	      videoSlot: null,
	      showProgress: true,
	      showBranding: true,
	      os: null,
	      osVersion: null,
	      orientation: null,
	      age: null,
	      gender: null,
	      advertiserId: null,
	      latitude: null,
	      longitude: null,
	      accuracy: null,
	      storeId: null,
	      ip: null,
	      manufacturer: null,
	      model: null,
	      connectionType: null,
	      connectionProvider: null,
	    },
	  },
	  create: function create() {
	    var app = this;
	    app.vi = {
	      sdkReady: false,
	      createAd: function createAd(adParams) {
	        return new ViAd(app, adParams);
	      },
	      loadSdk: function loadSdk() {
	        if (app.vi.skdReady) { return; }
	        var script = document.createElement('script');
	        script.onload = function onload() {
	          app.emit('viSdkReady');
	          app.vi.skdReady = true;
	        };
	        script.src = 'http://c.vi-serve.com/viadshtml/vi.min.js';
	        $$1$1('head').append(script);
	      },
	    };
	  },
	  on: {
	    init: function init() {
	      var app = this;
	      if (app.params.vi.enabled || (app.passedParams.vi && app.passedParams.vi.enabled !== false)) { app.vi.loadSdk(); }
	    },
	  },
	};

	var Typography = {
	  name: 'typography',
	};

	// F7 Class
	// Import Helpers


	// Core Modules
	// Core Components
	{
	  // Template7
	  if (!window.Template7) { window.Template7 = Template7; }

	  // Dom7
	  if (!window.Dom7) { window.Dom7 = $$1$1; }
	}

	// Install Core Modules & Components
	Framework7$1.use([
	  DeviceModule,
	  SupportModule,
	  UtilsModule,
	  ResizeModule,
	  RequestModule,
	  TouchModule,
	  ClicksModule,
	  Router,
	  HistoryModule,
	  StorageModule,
	  Statusbar$1,
	  View$2,
	  Navbar$1,
	  Toolbar$1,
	  Subnavbar,
	  TouchRipple,
	  Modal,
	  Dialog,
	  Popup,
	  LoginScreen,
	  Popover,
	  Actions,
	  Sheet,
	  Toast,
	  Preloader$1,
	  Progressbar$1,
	  Sortable$1,
	  Swipeout$1,
	  Accordion$1,
	  VirtualList,
	  Timeline,
	  Tabs,
	  Panel,
	  Card,
	  Chip,
	  Form,
	  Input$1,
	  Checkbox,
	  Radio,
	  Toggle,
	  Range,
	  SmartSelect,
	  Grid,
	  Calendar,
	  Picker,
	  InfiniteScroll$1,
	  PullToRefresh,
	  Lazy$1,
	  DataTable,
	  Fab$1,
	  Searchbar,
	  Messages,
	  Messagebar,
	  Swiper,
	  PhotoBrowser,
	  Notification,
	  Autocomplete,
	  Vi,
	  Typography
	]);

	return Framework7$1;

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var foo = exports.foo = function foo(text) {
	  console.log('foo says: "' + text + '"');
	};

/***/ })
/******/ ]);